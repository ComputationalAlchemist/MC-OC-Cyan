{version="0.1.0",name="deviceutils",depends={"init"},contents={["/usr/man/label"]="NAME\13\n  label - show or change the label of file systems\13\n\13\nSYNOPSIS\13\n  label FILE [STRING]\13\n  label -a ADDRESS [STRING]\13\n\13\nDESCRIPTION\13\n  `label` allows reading and writing the label of file systems. The file system can either be specified by a path to or into a mount, or by its address.\13\n\13\nEXAMPLES\13\n  label /home\13\n    Write the label of the file system mounted at `/home` to the standard output.\13\n\13\n  label -a 93f test\13\n    Change the label of the file system of which the address starts with `93f` to `test`.",["/bin/shutdown.lua"]="local computer = require(\"computer\")\13\nlocal term = require(\"term\")\13\n\13\nterm.clear()\13\ncomputer.shutdown()",["/bin/label.lua"]="local fs = require(\"filesystem\")\13\nlocal shell = require(\"shell\")\13\n\13\nlocal args, options = shell.parse(...)\13\nif #args < 1 then\13\n  io.write(\"Usage: label [-a] <fs> [<label>]\\n\")\13\n  io.write(\" -a  File system is specified via label or address instead of by path.\")\13\n  return\13\nend\13\n\13\nlocal proxy, reason\13\nif options.a then\13\n  proxy, reason = fs.proxy(args[1])\13\nelse\13\n  proxy, reason = fs.get(args[1])\13\nend\13\nif not proxy then\13\n  io.stderr:write(reason)\13\n  return\13\nend\13\n\13\nif #args < 2 then\13\n  io.stderr:write(proxy.getLabel() or \"no label\")\13\nelse\13\n  local result, reason = proxy.setLabel(args[2])\13\n  if not result then\13\n    io.stderr:write(reason or \"could not set label\")\13\n  end\13\nend\13\n",["/bin/mount.lua"]="local fs = require(\"filesystem\")\13\nlocal shell = require(\"shell\")\13\n\13\nlocal args = shell.parse(...)\13\nif #args == 0 then\13\n  for proxy, path in fs.mounts() do\13\n    local label = proxy.getLabel() or proxy.address\13\n    local mode = proxy.isReadOnly() and \"ro\" or \"rw\"\13\n    io.write(string.format(\"%s on %s (%s)\\n\", label, path, mode))\13\n  end\13\n  return\13\nend\13\nif #args < 2 then\13\n  io.write(\"Usage: mount [<label|address> <path>]\\n\")\13\n  io.write(\"Note that the address may be abbreviated.\")\13\n  return\13\nend\13\n\13\nlocal proxy, reason = fs.proxy(args[1])\13\nif not proxy then\13\n  io.stderr:write(reason)\13\n  return\13\nend\13\n\13\nlocal result, reason = fs.mount(proxy, shell.resolve(args[2]))\13\nif not result then\13\n  io.stderr:write(reason)\13\nend",["/bin/address.lua"]="local computer = require(\"computer\")\13\n\13\nio.write(computer.address())",["/bin/components.lua"]="local component = require(\"component\")\13\nlocal shell = require(\"shell\")\13\nlocal text = require(\"text\")\13\n\13\nlocal args, options = shell.parse(...)\13\nlocal count = tonumber(options.limit) or math.huge\13\n\13\nlocal components = {}\13\nlocal padTo = 1\13\n\13\nif #args == 0 then -- get all components if no filters given.\13\n  args[1] = \"\"\13\nend\13\nfor _, filter in ipairs(args) do\13\n  for address, name in component.list(filter) do\13\n    if name:len() > padTo then\13\n      padTo = name:len() + 2\13\n    end\13\n    components[address] = name\13\n  end\13\nend\13\n\13\npadTo = padTo + 8 - padTo % 8\13\nfor address, name in pairs(components) do\13\n  io.write(text.padRight(name, padTo) .. address .. '\\n')\13\n\13\n  if options.l then\13\n    local proxy = component.proxy(address)\13\n    local padTo = 1\13\n    local methods = {}\13\n    for name, member in pairs(proxy) do\13\n      if type(member) == \"table\" or type(member) == \"function\" then\13\n        if name:len() > padTo then\13\n          padTo = name:len() + 2\13\n        end\13\n        table.insert(methods, name)\13\n      end\13\n    end\13\n    table.sort(methods)\13\n    padTo = padTo + 8 - padTo % 8\13\n\13\n    for _, name in ipairs(methods) do\13\n      local doc = tostring(proxy[name])\13\n      io.write(\"  \" .. text.padRight(name, padTo) .. doc .. '\\n')\13\n    end\13\n  end\13\n\13\n  count = count - 1\13\n  if count <= 0 then\13\n    break\13\n  end\13\nend\13\n",["/bin/umount.lua"]="local fs = require(\"filesystem\")\13\nlocal shell = require(\"shell\")\13\n\13\nlocal args, options = shell.parse(...)\13\n\13\nif #args < 1 then\13\n  io.write(\"Usage: umount [-a] <mount>\\n\")\13\n  io.write(\" -a  Remove any mounts by file system label or address instead of by path. Note that the address may be abbreviated.\")\13\n  return\13\nend\13\n\13\nlocal proxy, reason\13\nif options.a then\13\n  proxy, reason = fs.proxy(args[1])\13\n  if proxy then\13\n    proxy = proxy.address\13\n  end\13\nelse\13\n  local path = shell.resolve(args[1])\13\n  proxy, reason = fs.get(path)\13\n  if proxy then\13\n    proxy = reason -- = path\13\n    if proxy ~= path then\13\n      io.stderr:write(\"not a mount point\")\13\n      return\13\n    end\13\n  end\13\nend\13\nif not proxy then\13\n  io.stderr:write(reason)\13\n  return\13\nend\13\n\13\nif not fs.umount(proxy) then\13\n  io.stderr:write(\"nothing to unmount here\")\13\nend",["/bin/resolution.lua"]="local component = require(\"component\")\13\nlocal shell = require(\"shell\")\13\nlocal term = require(\"term\")\13\n\13\nlocal args = shell.parse(...)\13\nif #args == 0 then\13\n  local w, h = component.gpu.getResolution()\13\n  io.write(w .. \" \" .. h)\13\n  return\13\nend\13\n\13\nif #args < 2 then\13\n  io.write(\"Usage: resolution [<width> <height>]\")\13\n  return\13\nend\13\n\13\nlocal w = tonumber(args[1])\13\nlocal h = tonumber(args[2])\13\nif not w or not h then\13\n  io.stderr:write(\"invalid width or height\")\13\n  return\13\nend\13\n\13\nlocal result, reason = component.gpu.setResolution(w, h)\13\nif not result then\13\n  if reason then -- otherwise we didn't change anything\13\n    io.stderr:write(reason)\13\n  end\13\n  return\13\nend\13\nterm.clear()",["/usr/man/umount"]="NAME\13\n  umount - remove a file system mount\13\n\13\nSYNOPSIS\13\n  umount PATH\13\n  umount -a LABEL\13\n  umount -a ADDRESS\13\n\13\nDESCRIPTION\13\n  Removes either a single mount point if given the path into a mount, or all mount points for a specified file system if given the label or address of the file system.\13\n\13\nEXAMPLES\13\n  umount /mnt/82f\13\n    Unmounts the automatically generated mountpoint at `/mnt/82f`.\13\n\13\n  unmount -a 82f\13\n    Removes all mounts of the file system for which the address starts with `82f`.",["/usr/man/shutdown"]="NAME\13\n  shutdown - shut down the computer\13\n\13\nSYNOPSIS\13\n  shutdown\13\n\13\nDESCRIPTION\13\n  Immediately shuts down the computer.\13\n\13\nEXAMPLES\13\n  shutdown\13\n    Stops the computer.",["/bin/reboot.lua"]="local computer = require(\"computer\")\13\n\13\nio.write(\"Rebooting...\")\13\ncomputer.shutdown(true)",["/usr/man/primary"]="NAME\13\n  primary - get or set primary components\13\n\13\nSYNOPSIS\13\n  primary TYPE\13\n  primary TYPE ADDRESS\13\n\13\nDESCRIPTION\13\n  This program allows reading the address of the current primary component of the specified type. It also allows chaning the current primary component for a specified type by providing the (abbreviated) address of the new primary component.\13\n\13\nEXAMPLES\13\n  primary gpu\13\n    Writes the address of the current primary GPU to the standard output.\13\n\13\n  primary gpu 24a\13\n    Makes the GPU of which the address starts with `24a` the new primary GPU.",["/usr/man/reboot"]="NAME\13\n  reboot - restarts the computer\13\n\13\nSYNOPSIS\13\n  reboot\13\n\13\nDESCRIPTION\13\n  `reboot` will immediately issue a reboot of the computer, shutting it down then starting it back up.\13\n\13\nEXAMPLES\13\n  reboot\13\n    Reboots the computer.",["/bin/primary.lua"]="local component = require(\"component\")\13\nlocal shell = require(\"shell\")\13\n\13\nlocal args = shell.parse(...)\13\nif #args == 0 then\13\n  io.write(\"Usage: primary <type> [<address>]\\n\")\13\n  io.write(\"Note that the address may be abbreviated.\")\13\n  return\13\nend\13\n\13\nlocal componentType = args[1]\13\n\13\nif #args > 1 then\13\n  local address = args[2]\13\n  if not component.get(address) then\13\n    io.stderr:write(\"no component with this address\")\13\n    return\13\n  else\13\n    component.setPrimary(componentType, address)\13\n    os.sleep(0.1) -- allow signals to be processed\13\n  end\13\nend\13\nif component.isAvailable(componentType) then\13\n  io.write(component.getPrimary(componentType).address)\13\nelse\13\n  io.stderr:write(\"no primary component for this type\")\13\nend\13\n",["/usr/man/mount"]="NAME\13\n  mount - mount a file system\13\n\13\nSYNOPSIS\13\n  mount\13\n  mount LABEL PATH\13\n  mount ADDRESS PATH\13\n\13\nDESCRIPTION\13\n  All files accessible in OpenOS are arranged in one big tree, starting with the root node, '/'. The files are the leaves of the tree, directories are inner nodes of the tree. Files can be distributed across several devices (file system components, such as hard drives and floppies). The `mount` command is used to attach a file system to this tree. The `umount` command can be used to remove a mounted file system from the tree (note that `rm` works for this, too).\13\n\13\nEXAMPLES\13\n  mount\13\n    Display a list of all currently mounted file systems.\13\n\13\n  mount test /home\13\n    Mounts the file system labeled `test` at `/home`.\13\n\13\n  mount 56f /var\13\n    Mounts the file system of which the address starts with `56f` at `/var`.",["/usr/man/address"]="NAME\13\n  address - display the computer's address\13\n\13\nSYNOPSIS\13\n  address\13\n\13\nDESCRIPTION\13\n  `address` allows printing the computer's component address. This can be useful to quickly look up a computer's address without an Analyzer. Knowing a computer's address can be useful if you wish to directly send network messages between two computers.\13\n\13\nEXAMPLES\13\n  address\13\n    Displays the address of the computer the program is run on.",["/usr/man/resolution"]="NAME\13\n  resolution - get or set screen resolution\13\n\13\nSYNOPSIS\13\n  resolution\13\n  resolution WIDTH HEIGHT\13\n\13\nDESCRIPTION\13\n  The `resolution` program is used to write the resolution of the current primary screen to the standard output, or to change the resolution to a new value.\13\n\13\nEXAMPLES\13\n  resolution\13\n    Displays the current screen resolution.\13\n\13\n  resoltution 30 10\13\n    Sets the screen's resolution to 30 by 10 characters."},conflicts={"binaries-0.1"}}