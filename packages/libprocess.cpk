{contents={["/lib/process.lua"]="local process = {}\13\n\13\n-------------------------------------------------------------------------------\13\n\13\nlocal running = setmetatable({}, {__mode=\"k\"})\13\nlocal coroutine_create = coroutine.create\13\n\13\nlocal function findProcess(co)\13\n  co = co or coroutine.running()\13\n  for _, process in pairs(running) do\13\n    for _, instance in pairs(process.instances) do\13\n      if instance == co then\13\n        return process\13\n      end\13\n    end\13\n  end\13\nend\13\n\13\n-------------------------------------------------------------------------------\13\n\13\nfunction process.load(path, env, init, name)\13\n  checkArg(1, path, \"string\")\13\n  checkArg(2, env, \"table\", \"nil\")\13\n  checkArg(3, init, \"function\", \"nil\")\13\n  checkArg(4, name, \"string\", \"nil\")\13\n\13\n  local process = findProcess()\13\n  if process then\13\n    env = env or process.env\13\n  end\13\n  env = setmetatable({}, {__index=env or _G})\13\n  local f, reason = io.open(path)\13\n  if not f then\13\n    return nil, reason\13\n  end\13\n  local code, reason\13\n  if f:read(2) == \"#!\" then\13\n    local command = f:read()\13\n    if require(\"text\").trim(command) == \"\" then\13\n      reason = \"no exec command\"\13\n    else\13\n      code = function()\13\n        return require(\"shell\").execute(command, env, path)\13\n      end\13\n    end\13\n  else\13\n    code, reason = loadfile(path, \"t\", env)\13\n  end\13\n  f:close()\13\n  if not code then\13\n    return nil, reason\13\n  end\13\n\13\n  local thread = coroutine_create(function(...)\13\n    if init then\13\n      init()\13\n    end\13\n    return code(...)\13\n  end)\13\n  running[thread] = {\13\n    path = path,\13\n    command = name,\13\n    env = env,\13\n    parent = process,\13\n    instances = setmetatable({thread}, {__mode=\"v\"})\13\n  }\13\n  return thread\13\nend\13\n\13\nfunction process.running(level)\13\n  level = level or 1\13\n  local process = findProcess()\13\n  while level > 1 and process do\13\n    process = process.parent\13\n    level = level - 1\13\n  end\13\n  if process then\13\n    return process.path, process.env, process.command\13\n  end\13\nend\13\n\13\nfunction process.install(path, name)\13\n  _G.coroutine.create = function(f)\13\n    local co = coroutine_create(f)\13\n    table.insert(findProcess().instances, co)\13\n    return co\13\n  end\13\n  local load = load\13\n  _G.load = function(ld, source, mode, env)\13\n    env = env or select(2, process.running())\13\n    return load(ld, source, mode, env)\13\n  end\13\n  local thread = coroutine.running()\13\n  running[thread] = {\13\n    path = path,\13\n    command = name,\13\n    env = _ENV,\13\n    instances = setmetatable({thread}, {__mode=\"v\"})\13\n  }\13\nend\13\n\13\nreturn process"},name="libprocess",depends={"init"},version="0.1",conflicts={}}