{version="0.1",name="libserialization",depends={},contents={["/lib/serialization.lua"]="local serialization = {}\13\n\13\n-- Important: pretty formatting will allow presenting non-serializable values\13\n-- but may generate output that cannot be unserialized back.\13\nfunction serialization.serialize(value, pretty)\13\n  local kw =  {[\"and\"]=true, [\"break\"]=true, [\"do\"]=true, [\"else\"]=true,\13\n               [\"elseif\"]=true, [\"end\"]=true, [\"false\"]=true, [\"for\"]=true,\13\n               [\"function\"]=true, [\"goto\"]=true, [\"if\"]=true, [\"in\"]=true,\13\n               [\"local\"]=true, [\"nil\"]=true, [\"not\"]=true, [\"or\"]=true,\13\n               [\"repeat\"]=true, [\"return\"]=true, [\"then\"]=true, [\"true\"]=true,\13\n               [\"until\"]=true, [\"while\"]=true}\13\n  local id = \"^[%a_][%w_]*$\"\13\n  local ts = {}\13\n  local function s(v, l)\13\n    local t = type(v)\13\n    if t == \"nil\" then\13\n      return \"nil\"\13\n    elseif t == \"boolean\" then\13\n      return v and \"true\" or \"false\"\13\n    elseif t == \"number\" then\13\n      if v ~= v then\13\n        return \"0/0\"\13\n      elseif v == math.huge then\13\n        return \"math.huge\"\13\n      elseif v == -math.huge then\13\n        return \"-math.huge\"\13\n      else\13\n        return tostring(v)\13\n      end\13\n    elseif t == \"string\" then\13\n      return string.format(\"%q\", v):gsub(\"\\\\\\n\",\"\\\\n\")\13\n    elseif t == \"table\" and pretty and getmetatable(v) and getmetatable(v).__tostring then\13\n      return tostring(v)\13\n    elseif t == \"table\" then\13\n      if ts[v] then\13\n        if pretty then\13\n          return \"recursion\"\13\n        else\13\n          error(\"tables with cycles are not supported\")\13\n        end\13\n      end\13\n      ts[v] = true\13\n      local i, r = 1, nil\13\n      local f\13\n      if pretty then\13\n        local ks, sks, oks = {}, {}, {}\13\n        for k in pairs(v) do\13\n          if type(k) == \"number\" then\13\n            table.insert(ks, k)\13\n          elseif type(k) == \"string\" then\13\n            table.insert(sks, k)\13\n          else\13\n            table.insert(oks, k)\13\n          end\13\n        end\13\n        table.sort(sks)\13\n        for _, k in ipairs(sks) do\13\n          table.insert(ks, k)\13\n        end\13\n        for _, k in ipairs(oks) do\13\n          table.insert(ks, k)\13\n        end\13\n        local n = 0\13\n        f = table.pack(function()\13\n          n = n + 1\13\n          local k = ks[n]\13\n          if k ~= nil then\13\n            return k, v[k]\13\n          else\13\n            return nil\13\n          end\13\n        end)\13\n      else\13\n        f = table.pack(pairs(v))\13\n      end\13\n      for k, v in table.unpack(f) do\13\n        if r then\13\n          r = r .. \",\" .. (pretty and (\"\\n\" .. string.rep(\" \", l)) or \"\")\13\n        else\13\n          r = \"{\"\13\n        end\13\n        local tk = type(k)\13\n        if tk == \"number\" and k == i then\13\n          i = i + 1\13\n          r = r .. s(v, l + 1)\13\n        else\13\n          if tk == \"string\" and not kw[k] and string.match(k, id) then\13\n            r = r .. k\13\n          else\13\n            r = r .. \"[\" .. s(k, l + 1) .. \"]\"\13\n          end\13\n          r = r .. \"=\" .. s(v, l + 1)\13\n        end\13\n      end\13\n      ts[v] = nil -- allow writing same table more than once\13\n      return (r or \"{\") .. \"}\"\13\n    else\13\n      if pretty then\13\n        return tostring(t)\13\n      else\13\n        error(\"unsupported type: \" .. t)\13\n      end\13\n    end\13\n  end\13\n  local result = s(value, 1)\13\n  local limit = type(pretty) == \"number\" and pretty or 10\13\n  if pretty then\13\n    local truncate = 0\13\n    while limit > 0 and truncate do\13\n      truncate = string.find(result, \"\\n\", truncate + 1, true)\13\n      limit = limit - 1\13\n    end\13\n    if truncate then\13\n      return result:sub(1, truncate) .. \"...\"\13\n    end\13\n  end\13\n  return result\13\nend\13\n\13\nfunction serialization.unserialize(data)\13\n  checkArg(1, data, \"string\")\13\n  local result, reason = load(\"return \" .. data, \"=data\", _, {math={huge=math.huge}})\13\n  if not result then\13\n    return nil, reason\13\n  end\13\n  local ok, output = pcall(result)\13\n  if not ok then\13\n    return nil, output\13\n  end\13\n  return output\13\nend\13\n\13\nreturn serialization\13\n"},conflicts={}}