{name="init",contents={["/lib/filesystem.lua"]="local component = require(\"component\")\13\nlocal unicode = require(\"unicode\")\13\n\13\nlocal filesystem, fileStream = {}, {}\13\nlocal isAutorunEnabled = nil\13\nlocal mtab = {name=\"\", children={}, links={}}\13\n\13\nlocal function segments(path)\13\n  path = path:gsub(\"\\\\\", \"/\")\13\n  repeat local n; path, n = path:gsub(\"//\", \"/\") until n == 0\13\n  local parts = {}\13\n  for part in path:gmatch(\"[^/]+\") do\13\n    table.insert(parts, part)\13\n  end\13\n  local i = 1\13\n  while i <= #parts do\13\n    if parts[i] == \".\" then\13\n      table.remove(parts, i)\13\n    elseif parts[i] == \"..\" then\13\n      table.remove(parts, i)\13\n      i = i - 1\13\n      if i > 0 then\13\n        table.remove(parts, i)\13\n      else\13\n        i = 1\13\n      end\13\n    else\13\n      i = i + 1\13\n    end\13\n  end\13\n  return parts\13\nend\13\n\13\nlocal function saveConfig()\13\n  local root = filesystem.get(\"/\")\13\n  if root and not root.isReadOnly() then\13\n    filesystem.makeDirectory(\"/etc\")\13\n    local f = io.open(\"/etc/filesystem.cfg\", \"w\")\13\n    if f then\13\n      f:write(\"autorun=\"..tostring(isAutorunEnabled))\13\n      f:close()\13\n    end\13\n  end\13\nend\13\n\13\nlocal function findNode(path, create, depth)\13\n  checkArg(1, path, \"string\")\13\n  depth = depth or 0\13\n  if depth > 100 then\13\n    error(\"link cycle detected\")\13\n  end\13\n  local parts = segments(path)\13\n  local node = mtab\13\n  while #parts > 0 do\13\n    local part = parts[1]\13\n    if not node.children[part] then\13\n      if node.links[part] then\13\n        return findNode(filesystem.concat(node.links[part], table.concat(parts, \"/\", 2)), create, depth + 1)\13\n      else\13\n        if create then\13\n          node.children[part] = {name=part, parent=node, children={}, links={}}\13\n        else\13\n          local vnode, vrest = node, table.concat(parts, \"/\")\13\n          local rest = vrest\13\n          while node and not node.fs do\13\n            rest = filesystem.concat(node.name, rest)\13\n            node = node.parent\13\n          end\13\n          return node, rest, vnode, vrest\13\n        end\13\n      end\13\n    end\13\n    node = node.children[part]\13\n    table.remove(parts, 1)\13\n  end\13\n  local vnode, vrest = node, nil\13\n  local rest = nil\13\n  while node and not node.fs do\13\n    rest = rest and filesystem.concat(node.name, rest) or node.name\13\n    node = node.parent\13\n  end\13\n  return node, rest, vnode, vrest\13\nend\13\n\13\nlocal function removeEmptyNodes(node)\13\n  while node and node.parent and not node.fs and not next(node.children) and not next(node.links) do\13\n    node.parent.children[node.name] = nil\13\n    node = node.parent\13\n  end\13\nend\13\n\13\n-------------------------------------------------------------------------------\13\n\13\nfunction filesystem.isAutorunEnabled()\13\n  if isAutorunEnabled == nil then\13\n    local env = {}\13\n    local config = loadfile(\"/etc/filesystem.cfg\", nil, env)\13\n    if config then\13\n      pcall(config)\13\n      isAutorunEnabled = not not env.autorun\13\n    else\13\n      isAutorunEnabled = true\13\n    end\13\n    saveConfig()\13\n  end\13\n  return isAutorunEnabled\13\nend\13\n\13\nfunction filesystem.setAutorunEnabled(value)\13\n  checkArg(1, value, \"boolean\")\13\n  isAutorunEnabled = value\13\n  saveConfig()\13\nend\13\n\13\nfunction filesystem.segments(path)\13\n  return segments(path)\13\nend\13\n\13\nfunction filesystem.canonical(path)\13\n  local result = table.concat(segments(path), \"/\")\13\n  if unicode.sub(path, 1, 1) == \"/\" then\13\n    return \"/\" .. result\13\n  else\13\n    return result\13\n  end\13\nend\13\n\13\nfunction filesystem.concat(pathA, pathB, ...)\13\n  checkArg(1, pathA, \"string\")\13\n  local function concat(n, a, b, ...)\13\n    if not b then\13\n      return a\13\n    end\13\n    checkArg(n, b, \"string\")\13\n    return concat(n + 1, a .. \"/\" .. b, ...)\13\n  end\13\n  return filesystem.canonical(concat(2, pathA, pathB, ...))\13\nend\13\n\13\nfunction filesystem.get(path)\13\n  local node, rest = findNode(path)\13\n  if node.fs then\13\n    local proxy = component.proxy(node.fs)\13\n    path = \"\"\13\n    while node and node.parent do\13\n      path = filesystem.concat(node.name, path)\13\n      node = node.parent\13\n    end\13\n    path = filesystem.canonical(path)\13\n    if path ~= \"/\" then\13\n      path = \"/\" .. path\13\n    end\13\n    return proxy, path\13\n  end\13\n  return nil, \"no such file system\"\13\nend\13\n\13\nfunction filesystem.isLink(path)\13\n  local node, rest, vnode, vrest = findNode(filesystem.path(path))\13\n  return not vrest and vnode.links[filesystem.name(path)] ~= nil\13\nend\13\n\13\nfunction filesystem.link(target, linkpath)\13\n  checkArg(1, target, \"string\")\13\n  checkArg(2, linkpath, \"string\")\13\n\13\n  if filesystem.exists(linkpath) then\13\n    return nil, \"file already exists\"\13\n  end\13\n\13\n  local node, rest, vnode, vrest = findNode(filesystem.path(linkpath), true)\13\n  vnode.links[filesystem.name(linkpath)] = target\13\n  return true\13\nend\13\n\13\nfunction filesystem.mount(fs, path)\13\n  checkArg(1, fs, \"string\", \"table\")\13\n  if type(fs) == \"string\" then\13\n    fs = filesystem.proxy(fs)\13\n  end\13\n  assert(type(fs) == \"table\", \"bad argument #1 (file system proxy or address expected)\")\13\n  checkArg(2, path, \"string\")\13\n\13\n  if path ~= \"/\" and filesystem.exists(path) then\13\n    return nil, \"file already exists\"\13\n  end\13\n\13\n  local node, rest, vnode, vrest = findNode(path, true)\13\n  if vnode.fs then\13\n    return nil, \"another filesystem is already mounted here\"\13\n  end\13\n  vnode.fs = fs.address\13\n  return true\13\nend\13\n\13\nfunction filesystem.mounts()\13\n  local function path(node)\13\n    local result = \"/\"\13\n    while node and node.parent do\13\n      for name, child in pairs(node.parent.children) do\13\n        if child == node then\13\n          result = \"/\" .. name .. result\13\n          break\13\n        end\13\n      end\13\n      node = node.parent\13\n    end\13\n    return result\13\n  end\13\n  local queue = {mtab}\13\n  return function()\13\n    while #queue > 0 do\13\n      local node = table.remove(queue)\13\n      for _, child in pairs(node.children) do\13\n        table.insert(queue, child)\13\n      end\13\n      if node.fs then\13\n        return component.proxy(node.fs) or node.fs, path(node)\13\n      end\13\n    end\13\n  end\13\nend\13\n\13\nfunction filesystem.path(path)\13\n  local parts = segments(path)\13\n  local result = table.concat(parts, \"/\", 1, #parts - 1) .. \"/\"\13\n  if unicode.sub(path, 1, 1) == \"/\" and unicode.sub(result, 1, 1) ~= \"/\" then\13\n    return \"/\" .. result\13\n  else\13\n    return result\13\n  end\13\nend\13\n\13\nfunction filesystem.name(path)\13\n  local parts = segments(path)\13\n  return parts[#parts]\13\nend\13\n\13\nfunction filesystem.proxy(filter)\13\n  checkArg(1, filter, \"string\")\13\n  local address\13\n  for c in component.list(\"filesystem\") do\13\n    if component.invoke(c, \"getLabel\") == filter then\13\n      address = c\13\n      break\13\n    end\13\n    if c:sub(1, filter:len()) == filter then\13\n      address = c\13\n      break\13\n    end\13\n  end\13\n  if not address then\13\n    return nil, \"no such file system\"\13\n  end\13\n  return component.proxy(address)\13\nend\13\n\13\nfunction filesystem.umount(fsOrPath)\13\n  checkArg(1, fsOrPath, \"string\", \"table\")\13\n  if type(fsOrPath) == \"string\" then\13\n    local node, rest, vnode, vrest = findNode(fsOrPath)\13\n    if not vrest and vnode.fs then\13\n      vnode.fs = nil\13\n      removeEmptyNodes(vnode)\13\n      return true\13\n    end\13\n  end\13\n  local address = type(fsOrPath) == \"table\" and fsOrPath.address or fsOrPath\13\n  local result = false\13\n  for proxy, path in filesystem.mounts() do\13\n    local addr = type(proxy) == \"table\" and proxy.address or proxy\13\n    if string.sub(addr, 1, address:len()) == address then\13\n      local node, rest, vnode, vrest = findNode(path)\13\n      vnode.fs = nil\13\n      removeEmptyNodes(vnode)\13\n      result = true\13\n    end\13\n  end\13\n  return result\13\nend\13\n\13\nfunction filesystem.exists(path)\13\n  local node, rest, vnode, vrest = findNode(path)\13\n  if not vrest or vnode.links[vrest] then -- virtual directory or symbolic link\13\n    return true\13\n  end\13\n  if node and node.fs then\13\n    return component.proxy(node.fs).exists(rest)\13\n  end\13\n  return false\13\nend\13\n\13\nfunction filesystem.size(path)\13\n  local node, rest, vnode, vrest = findNode(path)\13\n  if not vnode.fs and (not vrest or vnode.links[vrest]) then\13\n    return 0 -- virtual directory or symlink\13\n  end\13\n  if node.fs and rest then\13\n    return component.proxy(node.fs).size(rest)\13\n  end\13\n  return 0 -- no such file or directory\13\nend\13\n\13\nfunction filesystem.isDirectory(path)\13\n  local node, rest, vnode, vrest = findNode(path)\13\n  if not vnode.fs and not vrest then\13\n    return true -- virtual directory\13\n  end\13\n  if node.fs then\13\n    return not rest or component.proxy(node.fs).isDirectory(rest)\13\n  end\13\n  return false\13\nend\13\n\13\nfunction filesystem.lastModified(path)\13\n  local node, rest, vnode, vrest = findNode(path)\13\n  if not vnode.fs and not vrest then\13\n    return 0 -- virtual directory\13\n  end\13\n  if node.fs and rest then\13\n    return component.proxy(node.fs).lastModified(rest)\13\n  end\13\n  return 0 -- no such file or directory\13\nend\13\n\13\nfunction filesystem.list(path)\13\n  local node, rest, vnode, vrest = findNode(path)\13\n  if not vnode.fs and vrest and not (node and node.fs) then\13\n    return nil, \"no such file or directory\"\13\n  end\13\n  local result, reason\13\n  if node and node.fs then\13\n    result, reason = component.proxy(node.fs).list(rest or \"\")\13\n  end\13\n  result = result or {}\13\n  if not vrest then\13\n    for k in pairs(vnode.children) do\13\n      table.insert(result, k .. \"/\")\13\n    end\13\n    for k in pairs(vnode.links) do\13\n      table.insert(result, k)\13\n    end\13\n  end\13\n  table.sort(result)\13\n  local i, f = 1, nil\13\n  while i <= #result do\13\n    if result[i] == f then\13\n      table.remove(result, i)\13\n    else\13\n      f = result[i]\13\n    end\13\n    i = i + 1\13\n  end\13\n  local i = 0\13\n  return function()\13\n    i = i + 1\13\n    return result[i]\13\n  end\13\nend\13\n\13\nfunction filesystem.makeDirectory(path)\13\n  if filesystem.exists(path) then\13\n    return nil, \"file or directory with that name already exists\"\13\n  end\13\n  local node, rest = findNode(path)\13\n  if node.fs and rest then\13\n    return component.proxy(node.fs).makeDirectory(rest)\13\n  end\13\n  if node.fs then\13\n    return nil, \"virtual directory with that name already exists\"\13\n  end\13\n  return nil, \"cannot create a directory in a virtual directory\"\13\nend\13\n\13\nfunction filesystem.remove(path)\13\n  local node, rest, vnode, vrest = findNode(filesystem.path(path))\13\n  local name = filesystem.name(path)\13\n  if vnode.children[name] then\13\n    vnode.children[name] = nil\13\n    removeEmptyNodes(vnode)\13\n    return true\13\n  elseif vnode.links[name] then\13\n    vnode.links[name] = nil\13\n    removeEmptyNodes(vnode)\13\n    return true\13\n  else\13\n    node, rest = findNode(path)\13\n    if node.fs and rest then\13\n      return component.proxy(node.fs).remove(rest)\13\n    end\13\n    return nil, \"no such file or directory\"\13\n  end\13\nend\13\n\13\nfunction filesystem.rename(oldPath, newPath)\13\n  if filesystem.isLink(oldPath) then\13\n    local node, rest, vnode, vrest = findNode(filesystem.path(oldPath))\13\n    local target = vnode.links[filesystem.name(oldPath)]\13\n    local result, reason = filesystem.link(target, newPath)\13\n    if result then\13\n      filesystem.remove(oldPath)\13\n    end\13\n    return result, reason\13\n  else\13\n    local oldNode, oldRest = findNode(oldPath)\13\n    local newNode, newRest = findNode(newPath)\13\n    if oldNode.fs and oldRest and newNode.fs and newRest then\13\n      if oldNode.fs == newNode.fs then\13\n        return component.proxy(oldNode.fs).rename(oldRest, newRest)\13\n      else\13\n        local result, reason = filesystem.copy(oldPath, newPath)\13\n        if result then\13\n          return filesystem.remove(oldPath)\13\n        else\13\n          return nil, reason\13\n        end\13\n      end\13\n    end\13\n    return nil, \"trying to read from or write to virtual directory\"\13\n  end\13\nend\13\n\13\nfunction filesystem.copy(fromPath, toPath)\13\n  if filesystem.isDirectory(fromPath) then\13\n    return nil, \"cannot copy folders\"\13\n  end\13\n  local input, reason = io.open(fromPath, \"rb\")\13\n  if not input then\13\n    return nil, reason\13\n  end\13\n  local output, reason = io.open(toPath, \"wb\")\13\n  if not output then\13\n    input:close()\13\n    return nil, reason\13\n  end\13\n  repeat\13\n    local buffer, reason = input:read(1024)\13\n    if not buffer and reason then\13\n      return nil, reason\13\n    elseif buffer then\13\n      local result, reason = output:write(buffer)\13\n      if not result then\13\n        input:close()\13\n        output:close()\13\n        return nil, reason\13\n      end\13\n    end\13\n  until not buffer\13\n  input:close()\13\n  output:close()\13\n  return true\13\nend\13\n\13\nfunction fileStream:close()\13\n  if self.handle then\13\n    component.proxy(self.fs).close(self.handle)\13\n    self.handle = nil\13\n  end\13\nend\13\n\13\nfunction fileStream:read(n)\13\n  if not self.handle then\13\n    return nil, \"file is closed\"\13\n  end\13\n  return component.proxy(self.fs).read(self.handle, n)\13\nend\13\n\13\nfunction fileStream:seek(whence, offset)\13\n  if not self.handle then\13\n    return nil, \"file is closed\"\13\n  end\13\n  return component.proxy(self.fs).seek(self.handle, whence, offset)\13\nend\13\n\13\nfunction fileStream:write(str)\13\n  if not self.handle then\13\n    return nil, \"file is closed\"\13\n  end\13\n  return component.proxy(self.fs).write(self.handle, str)\13\nend\13\n\13\nfunction filesystem.open(path, mode)\13\n  checkArg(1, path, \"string\")\13\n  mode = tostring(mode or \"r\")\13\n  checkArg(2, mode, \"string\")\13\n  assert(({r=true, rb=true, w=true, wb=true, a=true, ab=true})[mode],\13\n    \"bad argument #2 (r[b], w[b] or a[b] expected, got \" .. mode .. \")\")\13\n\13\n  local node, rest = findNode(path)\13\n  if not node.fs or not rest then\13\n    return nil, \"file not found\"\13\n  end\13\n\13\n  local handle, reason = component.proxy(node.fs).open(rest, mode)\13\n  if not handle then\13\n    return nil, reason\13\n  end\13\n\13\n  local stream = {fs = node.fs, handle = handle}\13\n\13\n  local function cleanup(self)\13\n    if not self.handle then return end\13\n    local proxy = component.proxy(self.fs)\13\n    if proxy then pcall(proxy.close, self.handle) end\13\n  end\13\n  local metatable = {__index = fileStream,\13\n                     __gc = cleanup,\13\n                     __metatable = \"filestream\"}\13\n  return setmetatable(stream, metatable)\13\nend\13\n\13\n-------------------------------------------------------------------------------\13\n\13\nreturn filesystem\13\n",["/boot/03_component.lua"]="local component = require(\"component\")\13\nlocal computer = require(\"computer\")\13\nlocal event = require(\"event\")\13\n\13\nlocal adding = {}\13\nlocal removing = {}\13\nlocal primaries = {}\13\n\13\n-------------------------------------------------------------------------------\13\n\13\n-- This allows writing component.modem.open(123) instead of writing\13\n-- component.getPrimary(\"modem\").open(123), which may be nicer to read.\13\nsetmetatable(component, { __index = function(_, key)\13\n                                      return component.getPrimary(key)\13\n                                    end })\13\n\13\nfunction component.get(address, componentType)\13\n  checkArg(1, address, \"string\")\13\n  checkArg(2, componentType, \"string\", \"nil\")\13\n  for c in component.list(componentType, true) do\13\n    if c:sub(1, address:len()) == address then\13\n      return c\13\n    end\13\n  end\13\n  return nil, \"no such component\"\13\nend\13\n\13\nfunction component.isAvailable(componentType)\13\n  checkArg(1, componentType, \"string\")\13\n  if not primaries[componentType] then\13\n    -- This is mostly to avoid out of memory errors preventing proxy\13\n    -- creation cause confusion by trying to create the proxy again,\13\n    -- causing the oom error to be thrown again.\13\n    component.setPrimary(componentType, component.list(componentType, true)())\13\n  end\13\n  return primaries[componentType] ~= nil\13\nend\13\n\13\nfunction component.isPrimary(address)\13\n  local componentType = component.type(address)\13\n  if componentType then\13\n    if component.isAvailable(componentType) then\13\n      return primaries[componentType].address == address\13\n    end\13\n  end\13\n  return false\13\nend\13\n\13\nfunction component.getPrimary(componentType)\13\n  checkArg(1, componentType, \"string\")\13\n  assert(component.isAvailable(componentType),\13\n    \"no primary '\" .. componentType .. \"' available\")\13\n  return primaries[componentType]\13\nend\13\n\13\nfunction component.setPrimary(componentType, address)\13\n  checkArg(1, componentType, \"string\")\13\n  checkArg(2, address, \"string\", \"nil\")\13\n  if address ~= nil then\13\n    address = component.get(address, componentType)\13\n    assert(address, \"no such component\")\13\n  end\13\n\13\n  local wasAvailable = primaries[componentType]\13\n  if wasAvailable and address == wasAvailable.address then\13\n    return\13\n  end\13\n  local wasAdding = adding[componentType]\13\n  if wasAdding and address == wasAdding.address then\13\n    return\13\n  end\13\n  if wasAdding then\13\n    event.cancel(wasAdding.timer)\13\n  end\13\n  primaries[componentType] = nil\13\n  adding[componentType] = nil\13\n\13\n  local primary = address and component.proxy(address) or nil\13\n  if wasAvailable then\13\n    computer.pushSignal(\"component_unavailable\", componentType)\13\n  end\13\n  if primary then\13\n    if wasAvailable or wasAdding then\13\n      adding[componentType] = {\13\n        address=address,\13\n        timer=event.timer(0.1, function()\13\n          adding[componentType] = nil\13\n          primaries[componentType] = primary\13\n          computer.pushSignal(\"component_available\", componentType)\13\n        end)\13\n      }\13\n    else\13\n      primaries[componentType] = primary\13\n      computer.pushSignal(\"component_available\", componentType)\13\n    end\13\n  end\13\nend\13\n\13\n-------------------------------------------------------------------------------\13\n\13\nfor address in component.list('screen') do\13\n  if #component.invoke(address,'getKeyboards') > 0 then\13\n    component.setPrimary('screen',address)\13\n  end\13\nend\13\n\13\nlocal function onComponentAdded(_, address, componentType)\13\n  if not (primaries[componentType] or adding[componentType]) then\13\n    component.setPrimary(componentType, address)\13\n  end\13\nend\13\n\13\nlocal function onComponentRemoved(_, address, componentType)\13\n  if primaries[componentType] and primaries[componentType].address == address or\13\n     adding[componentType] and adding[componentType].address == address\13\n  then\13\n    component.setPrimary(componentType, component.list(componentType, true)())\13\n  end\13\nend\13\n\13\nevent.listen(\"component_added\", onComponentAdded)\13\nevent.listen(\"component_removed\", onComponentRemoved)\13\n",["/lib/text.lua"]="local unicode = require(\"unicode\")\13\n\13\nlocal text = {}\13\n\13\nfunction text.detab(value, tabWidth)\13\n  checkArg(1, value, \"string\")\13\n  checkArg(2, tabWidth, \"number\", \"nil\")\13\n  tabWidth = tabWidth or 8\13\n  local function rep(match)\13\n    local spaces = tabWidth - match:len() % tabWidth\13\n    return match .. string.rep(\" \", spaces)\13\n  end\13\n  local result = value:gsub(\"([^\\n]-)\\t\", rep) -- truncate results\13\n  return result\13\nend\13\n\13\nfunction text.padRight(value, length)\13\n  checkArg(1, value, \"string\", \"nil\")\13\n  checkArg(2, length, \"number\")\13\n  if not value or unicode.wlen(value) == 0 then\13\n    return string.rep(\" \", length)\13\n  else\13\n    return value .. string.rep(\" \", length - unicode.wlen(value))\13\n  end\13\nend\13\n\13\nfunction text.padLeft(value, length)\13\n  checkArg(1, value, \"string\", \"nil\")\13\n  checkArg(2, length, \"number\")\13\n  if not value or unicode.wlen(value) == 0 then\13\n    return string.rep(\" \", length)\13\n  else\13\n    return string.rep(\" \", length - unicode.wlen(value)) .. value\13\n  end\13\nend\13\n\13\nfunction text.trim(value) -- from http://lua-users.org/wiki/StringTrim\13\n  local from = string.match(value, \"^%s*()\")\13\n  return from > #value and \"\" or string.match(value, \".*%S\", from)\13\nend\13\n\13\nfunction text.wrap(value, width, maxWidth)\13\n  checkArg(1, value, \"string\")\13\n  checkArg(2, width, \"number\")\13\n  checkArg(3, maxWidth, \"number\")\13\n  local line, nl = value:match(\"([^\\r\\n]*)(\\r?\\n?)\") -- read until newline\13\n  if unicode.wlen(line) > width then -- do we even need to wrap?\13\n    local partial = unicode.wtrunc(line, width)\13\n    local wrapped = partial:match(\"(.*[^a-zA-Z0-9._()'`=])\")\13\n    if wrapped or unicode.wlen(line) > maxWidth then\13\n      partial = wrapped or partial\13\n      return partial, unicode.sub(value, unicode.len(partial) + 1), true\13\n    else\13\n      return \"\", value, true -- write in new line.\13\n    end\13\n  end\13\n  local start = unicode.len(line) + unicode.len(nl) + 1\13\n  return line, start <= unicode.len(value) and unicode.sub(value, start) or nil, unicode.len(nl) > 0\13\nend\13\n\13\nfunction text.wrappedLines(value, width, maxWidth)\13\n  local line, nl\13\n  return function()\13\n    if value then\13\n      line, value, nl = text.wrap(value, width, maxWidth)\13\n      return line\13\n    end\13\n  end\13\nend\13\n\13\n-------------------------------------------------------------------------------\13\n\13\nfunction text.tokenize(value)\13\n  checkArg(1, value, \"string\")\13\n  local tokens, token = {}, \"\"\13\n  local escaped, quoted, start = false, false, -1\13\n  for i = 1, unicode.len(value) do\13\n    local char = unicode.sub(value, i, i)\13\n    if escaped then -- escaped character\13\n      escaped = false\13\n      token = token .. char\13\n    elseif char == \"\\\\\" and quoted ~= \"'\" then -- escape character?\13\n      escaped = true\13\n      token = token .. char\13\n    elseif char == quoted then -- end of quoted string\13\n      quoted = false\13\n      token = token .. char\13\n    elseif (char == \"'\" or char == '\"') and not quoted then\13\n      quoted = char\13\n      start = i\13\n      token = token .. char\13\n    elseif string.find(char, \"%s\") and not quoted then -- delimiter\13\n      if token ~= \"\" then\13\n        table.insert(tokens, token)\13\n        token = \"\"\13\n      end\13\n    else -- normal char\13\n      token = token .. char\13\n    end\13\n  end\13\n  if quoted then\13\n    return nil, \"unclosed quote at index \" .. start\13\n  end\13\n  if token ~= \"\" then\13\n    table.insert(tokens, token)\13\n  end\13\n  return tokens\13\nend\13\n\13\n-------------------------------------------------------------------------------\13\n\13\nreturn text\13\n",["/lib/buffer.lua"]="local computer = require(\"computer\")\13\nlocal unicode = require(\"unicode\")\13\n\13\nlocal buffer = {}\13\n\13\nfunction buffer.new(mode, stream)\13\n  local result = {\13\n    mode = {},\13\n    stream = stream,\13\n    bufferRead = \"\",\13\n    bufferWrite = \"\",\13\n    bufferSize = math.max(512, math.min(8 * 1024, computer.freeMemory() / 8)),\13\n    bufferMode = \"full\",\13\n    readTimeout = math.huge\13\n  }\13\n  mode = mode or \"r\"\13\n  for i = 1, unicode.len(mode) do\13\n    result.mode[unicode.sub(mode, i, i)] = true\13\n  end\13\n  local metatable = {\13\n    __index = buffer,\13\n    __metatable = \"file\"\13\n  }\13\n  return setmetatable(result, metatable)\13\nend\13\n\13\nfunction buffer:close()\13\n  if self.mode.w or self.mode.a then\13\n    self:flush()\13\n  end\13\n  self.closed = true\13\n  return self.stream:close()\13\nend\13\n\13\nfunction buffer:flush()\13\n  local result, reason = self.stream:write(self.bufferWrite)\13\n  if result then\13\n    self.bufferWrite = \"\"\13\n  else\13\n    if reason then\13\n      return nil, reason\13\n    else\13\n      return nil, \"bad file descriptor\"\13\n    end\13\n  end\13\n\13\n  return self\13\nend\13\n\13\nfunction buffer:lines(...)\13\n  local args = table.pack(...)\13\n  return function()\13\n    local result = table.pack(self:read(table.unpack(args, 1, args.n)))\13\n    if not result[1] and result[2] then\13\n      error(result[2])\13\n    end\13\n    return table.unpack(result, 1, result.n)\13\n  end\13\nend\13\n\13\nfunction buffer:read(...)\13\n  local timeout = computer.uptime() + self.readTimeout\13\n\13\n  local function readChunk()\13\n    if computer.uptime() > timeout then\13\n      error(\"timeout\")\13\n    end\13\n    local result, reason = self.stream:read(self.bufferSize)\13\n    if result then\13\n      self.bufferRead = self.bufferRead .. result\13\n      return self\13\n    else -- error or eof\13\n      return nil, reason\13\n    end\13\n  end\13\n\13\n  local function readBytesOrChars(n)\13\n    n = math.max(n, 0)\13\n    local len, sub\13\n    if self.mode.b then\13\n      len = rawlen\13\n      sub = string.sub\13\n    else\13\n      len = unicode.len\13\n      sub = unicode.sub\13\n    end\13\n    local buffer = \"\"\13\n    repeat\13\n      if len(self.bufferRead) == 0 then\13\n        local result, reason = readChunk()\13\n        if not result then\13\n          if reason then\13\n            return nil, reason\13\n          else -- eof\13\n            return #buffer > 0 and buffer or nil\13\n          end\13\n        end\13\n      end\13\n      local left = n - len(buffer)\13\n      buffer = buffer .. sub(self.bufferRead, 1, left)\13\n      self.bufferRead = sub(self.bufferRead, left + 1)\13\n    until len(buffer) == n\13\n    return buffer\13\n  end\13\n\13\n  local function readLine(chop)\13\n    local start = 1\13\n    while true do\13\n      local l = self.bufferRead:find(\"\\n\", start, true)\13\n      if l then\13\n        local result = self.bufferRead:sub(1, l + (chop and -1 or 0))\13\n        self.bufferRead = self.bufferRead:sub(l + 1)\13\n        return result\13\n      else\13\n        start = #self.bufferRead\13\n        local result, reason = readChunk()\13\n        if not result then\13\n          if reason then\13\n            return nil, reason\13\n          else -- eof\13\n            local result = #self.bufferRead > 0 and self.bufferRead or nil\13\n            self.bufferRead = \"\"\13\n            return result\13\n          end\13\n        end\13\n      end\13\n    end\13\n  end\13\n\13\n  local function readAll()\13\n    repeat\13\n      local result, reason = readChunk()\13\n      if not result and reason then\13\n        return nil, reason\13\n      end\13\n    until not result -- eof\13\n    local result = self.bufferRead\13\n    self.bufferRead = \"\"\13\n    return result\13\n  end\13\n\13\n  local function read(n, format)\13\n    if type(format) == \"number\" then\13\n      return readBytesOrChars(format)\13\n    else\13\n      if type(format) ~= \"string\" or unicode.sub(format, 1, 1) ~= \"*\" then\13\n        error(\"bad argument #\" .. n .. \" (invalid option)\")\13\n      end\13\n      format = unicode.sub(format, 2, 2)\13\n      if format == \"n\" then\13\n        --[[ TODO ]]\13\n        error(\"not implemented\")\13\n      elseif format == \"l\" then\13\n        return readLine(true)\13\n      elseif format == \"L\" then\13\n        return readLine(false)\13\n      elseif format == \"a\" then\13\n        return readAll()\13\n      else\13\n        error(\"bad argument #\" .. n .. \" (invalid format)\")\13\n      end\13\n    end\13\n  end\13\n\13\n  if self.mode.w or self.mode.a then\13\n    self:flush()\13\n  end\13\n\13\n  local results = {}\13\n  local formats = table.pack(...)\13\n  if formats.n == 0 then\13\n    return readLine(true)\13\n  end\13\n  for i = 1, formats.n do\13\n    local result, reason = read(i, formats[i])\13\n    if result then\13\n      results[i] = result\13\n    elseif reason then\13\n      return nil, reason\13\n    end\13\n  end\13\n  return table.unpack(results, 1, formats.n)\13\nend\13\n\13\nfunction buffer:seek(whence, offset)\13\n  whence = tostring(whence or \"cur\")\13\n  assert(whence == \"set\" or whence == \"cur\" or whence == \"end\",\13\n    \"bad argument #1 (set, cur or end expected, got \" .. whence .. \")\")\13\n  offset = offset or 0\13\n  checkArg(2, offset, \"number\")\13\n  assert(math.floor(offset) == offset, \"bad argument #2 (not an integer)\")\13\n\13\n  if self.mode.w or self.mode.a then\13\n    self:flush()\13\n  elseif whence == \"cur\" then\13\n    offset = offset - #self.bufferRead\13\n  end\13\n  local result, reason = self.stream:seek(whence, offset)\13\n  if result then\13\n    self.bufferRead = \"\"\13\n    return result\13\n  else\13\n    return nil, reason\13\n  end\13\nend\13\n\13\nfunction buffer:setvbuf(mode, size)\13\n  mode = mode or self.bufferMode\13\n  size = size or self.bufferSize\13\n\13\n  assert(mode == \"no\" or mode == \"full\" or mode == \"line\",\13\n    \"bad argument #1 (no, full or line expected, got \" .. tostring(mode) .. \")\")\13\n  assert(mode == \"no\" or type(size) == \"number\",\13\n    \"bad argument #2 (number expected, got \" .. type(size) .. \")\")\13\n\13\n  self.bufferMode = mode\13\n  self.bufferSize = size\13\n\13\n  return self.bufferMode, self.bufferSize\13\nend\13\n\13\nfunction buffer:getTimeout()\13\n  return self.readTimeout\13\nend\13\n\13\nfunction buffer:setTimeout(value)\13\n  self.readTimeout = tonumber(value)\13\nend\13\n\13\nfunction buffer:write(...)\13\n  if self.closed then\13\n    return nil, \"bad file descriptor\"\13\n  end\13\n  local args = table.pack(...)\13\n  for i = 1, args.n do\13\n    if type(args[i]) == \"number\" then\13\n      args[i] = tostring(args[i])\13\n    end\13\n    checkArg(i, args[i], \"string\")\13\n  end\13\n\13\n  for i = 1, args.n do\13\n    local arg = args[i]\13\n    local result, reason\13\n\13\n    if self.bufferMode == \"full\" then\13\n      if self.bufferSize - #self.bufferWrite < #arg then\13\n        result, reason = self:flush()\13\n        if not result then\13\n          return nil, reason\13\n        end\13\n      end\13\n      if #arg > self.bufferSize then\13\n        result, reason = self.stream:write(arg)\13\n      else\13\n        self.bufferWrite = self.bufferWrite .. arg\13\n        result = self\13\n      end\13\n\13\n    elseif self.bufferMode == \"line\" then\13\n      local l\13\n      repeat\13\n        local idx = arg:find(\"\\n\", (l or 0) + 1, true)\13\n        if idx then\13\n          l = idx\13\n        end\13\n      until not idx\13\n      if l or #arg > self.bufferSize then\13\n        result, reason = self:flush()\13\n        if not result then\13\n          return nil, reason\13\n        end\13\n      end\13\n      if l then\13\n        result, reason = self.stream:write(arg:sub(1, l))\13\n        if not result then\13\n          return nil, reason\13\n        end\13\n        arg = arg:sub(l + 1)\13\n      end\13\n      if #arg > self.bufferSize then\13\n        result, reason = self.stream:write(arg)\13\n      else\13\n        self.bufferWrite = self.bufferWrite .. arg\13\n        result = self\13\n      end\13\n\13\n    else -- self.bufferMode == \"no\"\13\n      result, reason = self.stream:write(arg)\13\n    end\13\n\13\n    if not result then\13\n      return nil, reason\13\n    end\13\n  end\13\n\13\n  return self\13\nend\13\n\13\nreturn buffer",["/lib/shell.lua"]="local fs = require(\"filesystem\")\13\nlocal text = require(\"text\")\13\nlocal unicode = require(\"unicode\")\13\n\13\nlocal shell = {}\13\nlocal aliases = {}\13\n\13\n-- Cache loaded shells for command execution. This puts the requirement on\13\n-- shells that they do not keep a global state, since they may be called\13\n-- multiple times, but reduces memory usage a lot.\13\nlocal shells = setmetatable({}, {__mode=\"v\"})\13\n\13\nlocal function getShell()\13\n  local shellName, reason = shell.resolve(os.getenv(\"SHELL\"), \"lua\")\13\n  if not shellName then\13\n    return nil, \"cannot resolve shell \" .. os.getenv(\"SHELL\") .. \": \" .. reason\13\n  end\13\n  if shells[shellName] then\13\n    return shells[shellName]\13\n  end\13\n  local sh, reason = loadfile(shellName, \"t\", env)\13\n  if sh then\13\n    shells[shellName] = sh\13\n  end\13\n  return sh, reason\13\nend\13\n\13\nlocal function findFile(name, ext)\13\n  checkArg(1, name, \"string\")\13\n  local function findIn(dir)\13\n    if dir:sub(1, 1) ~= \"/\" then\13\n      dir = shell.resolve(dir)\13\n    end\13\n    dir = fs.concat(fs.concat(dir, name), \"..\")\13\n    local name = fs.name(name)\13\n    local list = fs.list(dir)\13\n    if list then\13\n      local files = {}\13\n      for file in list do\13\n        files[file] = true\13\n      end\13\n      if ext and unicode.sub(name, -(1 + unicode.len(ext))) == \".\" .. ext then\13\n        -- Name already contains extension, prioritize.\13\n        if files[name] then\13\n          return true, fs.concat(dir, name)\13\n        end\13\n      elseif files[name] then\13\n        -- Check exact name.\13\n        return true, fs.concat(dir, name)\13\n      elseif ext then\13\n        -- Check name with automatially added extension.\13\n        local name = name .. \".\" .. ext\13\n        if files[name] then\13\n          return true, fs.concat(dir, name)\13\n        end\13\n      end\13\n    end\13\n    return false\13\n  end\13\n  if unicode.sub(name, 1, 1) == \"/\" then\13\n    local found, where = findIn(\"/\")\13\n    if found then return where end\13\n  elseif unicode.sub(name, 1, 2) == \"./\" then\13\n    local found, where = findIn(shell.getWorkingDirectory())\13\n    if found then return where end\13\n  else\13\n    for path in string.gmatch(shell.getPath(), \"[^:]+\") do\13\n      local found, where = findIn(path)\13\n      if found then return where end\13\n    end\13\n  end\13\n  return false\13\nend\13\n\13\n-------------------------------------------------------------------------------\13\n\13\nfunction shell.getAlias(alias)\13\n  return aliases[alias]\13\nend\13\n\13\nfunction shell.setAlias(alias, value)\13\n  checkArg(1, alias, \"string\")\13\n  checkArg(2, value, \"string\", \"nil\")\13\n  aliases[alias] = value\13\nend\13\n\13\nfunction shell.aliases()\13\n  return pairs(aliases)\13\nend\13\n\13\nfunction shell.resolveAlias(command, args)\13\n  checkArg(1, command, \"string\")\13\n  checkArg(2, args, \"table\", \"nil\")\13\n  args = args or {}\13\n  local program, lastProgram = command, nil\13\n  while true do\13\n    local tokens = text.tokenize(shell.getAlias(program) or program)\13\n    program = tokens[1]\13\n    if program == lastProgram then\13\n      break\13\n    end\13\n    lastProgram = program\13\n    for i = #tokens, 2, -1 do\13\n      table.insert(args, 1, tokens[i])\13\n    end\13\n  end\13\n  return program, args\13\nend\13\n\13\nfunction shell.getWorkingDirectory()\13\n  return os.getenv(\"PWD\")\13\nend\13\n\13\nfunction shell.setWorkingDirectory(dir)\13\n  checkArg(1, dir, \"string\")\13\n  dir = fs.canonical(dir) .. \"/\"\13\n  if dir == \"//\" then dir = \"/\" end\13\n  if fs.isDirectory(dir) then\13\n    os.setenv(\"PWD\", dir)\13\n    return true\13\n  else\13\n    return nil, \"not a directory\"\13\n  end\13\nend\13\n\13\nfunction shell.getPath()\13\n  return os.getenv(\"PATH\")\13\nend\13\n\13\nfunction shell.setPath(value)\13\n  os.setenv(\"PATH\", value)\13\nend\13\n\13\nfunction shell.resolve(path, ext)\13\n  if ext then\13\n    checkArg(2, ext, \"string\")\13\n    local where = findFile(path, ext)\13\n    if where then\13\n      return where\13\n    else\13\n      return nil, \"file not found\"\13\n    end\13\n  else\13\n    if unicode.sub(path, 1, 1) == \"/\" then\13\n      return fs.canonical(path)\13\n    else\13\n      return fs.concat(shell.getWorkingDirectory(), path)\13\n    end\13\n  end\13\nend\13\n\13\nfunction shell.execute(command, env, ...)\13\n  local sh, reason = getShell()\13\n  if not sh then\13\n    return false, reason\13\n  end\13\n  local result = table.pack(pcall(sh, env, command, ...))\13\n  if not result[1] and type(result[2]) == \"table\" and result[2].reason == \"terminated\" then\13\n    if result[2].code then\13\n      return true\13\n    else\13\n      return false, \"terminated\"\13\n    end\13\n  end\13\n  return table.unpack(result, 1, result.n)\13\nend\13\n\13\nfunction shell.parse(...)\13\n  local params = table.pack(...)\13\n  local args = {}\13\n  local options = {}\13\n  local doneWithOptions = false\13\n  for i = 1, params.n do\13\n    local param = params[i]\13\n    if not doneWithOptions and type(param) == \"string\" then\13\n      if param == \"--\" then\13\n        doneWithOptions = true -- stop processing options at `--`\13\n      elseif unicode.sub(param, 1, 2) == \"--\" then\13\n        if param:match(\"%-%-(.-)=\") ~= nil then\13\n          options[param:match(\"%-%-(.-)=\")] = param:match(\"=(.*)\")\13\n        else\13\n          options[unicode.sub(param, 3)] = true\13\n        end\13\n      elseif unicode.sub(param, 1, 1) == \"-\" and param ~= \"-\" then\13\n        for j = 2, unicode.len(param) do\13\n          options[unicode.sub(param, j, j)] = true\13\n        end\13\n      else\13\n        table.insert(args, param)\13\n      end\13\n    else\13\n      table.insert(args, param)\13\n    end\13\n  end\13\n  return args, options\13\nend\13\n\13\n-------------------------------------------------------------------------------\13\n\13\nreturn shell\13\n",["/boot/93_term.lua"]="local computer = require(\"computer\")\13\nlocal event = require(\"event\")\13\n\13\nlocal gpuAvailable, screenAvailable = false, false\13\n\13\nlocal function isAvailable()\13\n  return gpuAvailable and screenAvailable\13\nend\13\n\13\nlocal function onComponentAvailable(_, componentType)\13\n  local wasAvailable = isAvailable()\13\n  if componentType == \"gpu\" then\13\n    gpuAvailable = true\13\n  elseif componentType == \"screen\" then\13\n    screenAvailable = true\13\n  end\13\n  if not wasAvailable and isAvailable() then\13\n    computer.pushSignal(\"term_available\")\13\n  end\13\nend\13\n\13\nlocal function onComponentUnavailable(_, componentType)\13\n  local wasAvailable = isAvailable()\13\n  if componentType == \"gpu\" then\13\n    gpuAvailable = false\13\n  elseif componentType == \"screen\" then\13\n    screenAvailable = false\13\n  end\13\n  if wasAvailable and not isAvailable() then\13\n    computer.pushSignal(\"term_unavailable\")\13\n  end\13\nend\13\n\13\nevent.listen(\"component_available\", onComponentAvailable)\13\nevent.listen(\"component_unavailable\", onComponentUnavailable)\13\n",["/lib/event.lua"]="local computer = require(\"computer\")\13\nlocal keyboard = require(\"keyboard\")\13\n\13\nlocal event, listeners, timers = {}, {}, {}\13\nlocal lastInterrupt = -math.huge\13\n\13\nlocal function matches(signal, name, filter)\13\n  if name and not (type(signal[1]) == \"string\" and signal[1]:match(name))\13\n  then\13\n    return false\13\n  end\13\n  for i = 1, filter.n do\13\n    if filter[i] ~= nil and filter[i] ~= signal[i + 1] then\13\n      return false\13\n    end\13\n  end\13\n  return true\13\nend\13\n\13\nlocal function call(callback, ...)\13\n  local result, message = pcall(callback, ...)\13\n  if not result and type(event.onError) == \"function\" then\13\n    pcall(event.onError, message)\13\n    return\13\n  end\13\n  return message\13\nend\13\n\13\nlocal function dispatch(signal, ...)\13\n  if listeners[signal] then\13\n    local function callbacks()\13\n      local list = {}\13\n      for index, listener in ipairs(listeners[signal]) do\13\n        list[index] = listener\13\n      end\13\n      return list\13\n    end\13\n    for _, callback in ipairs(callbacks()) do\13\n      if call(callback, signal, ...) == false then\13\n        event.ignore(signal, callback) -- alternative method of removing a listener\13\n      end\13\n    end\13\n  end\13\nend\13\n\13\nlocal function tick()\13\n  local function elapsed()\13\n    local list = {}\13\n    for id, timer in pairs(timers) do\13\n      if timer.after <= computer.uptime() then\13\n        table.insert(list, timer.callback)\13\n        timer.times = timer.times - 1\13\n        if timer.times <= 0 then\13\n          timers[id] = nil\13\n        else\13\n          timer.after = computer.uptime() + timer.interval\13\n        end\13\n      end\13\n    end\13\n    return list\13\n  end\13\n  for _, callback in ipairs(elapsed()) do\13\n    call(callback)\13\n  end\13\nend\13\n\13\n-------------------------------------------------------------------------------\13\n\13\nfunction event.cancel(timerId)\13\n  checkArg(1, timerId, \"number\")\13\n  if timers[timerId] then\13\n    timers[timerId] = nil\13\n    return true\13\n  end\13\n  return false\13\nend\13\n\13\nfunction event.ignore(name, callback)\13\n  checkArg(1, name, \"string\")\13\n  checkArg(2, callback, \"function\")\13\n  if listeners[name] then\13\n    for i = 1, #listeners[name] do\13\n      if listeners[name][i] == callback then\13\n        table.remove(listeners[name], i)\13\n        if #listeners[name] == 0 then\13\n          listeners[name] = nil\13\n        end\13\n        return true\13\n      end\13\n    end\13\n  end\13\n  return false\13\nend\13\n\13\nfunction event.listen(name, callback)\13\n  checkArg(1, name, \"string\")\13\n  checkArg(2, callback, \"function\")\13\n  if listeners[name] then\13\n    for i = 1, #listeners[name] do\13\n      if listeners[name][i] == callback then\13\n        return false\13\n      end\13\n    end\13\n  else\13\n    listeners[name] = {}\13\n  end\13\n  table.insert(listeners[name], callback)\13\n  return true\13\nend\13\n\13\nfunction event.onError(message)\13\n  local log = io.open(\"/tmp/event.log\", \"a\")\13\n  if log then\13\n    log:write(message .. \"\\n\")\13\n    log:close()\13\n  end\13\nend\13\n\13\nfunction event.pull(...)\13\n  local args = table.pack(...)\13\n  local seconds, name, filter\13\n  if type(args[1]) == \"string\" then\13\n    name = args[1]\13\n    filter = table.pack(table.unpack(args, 2, args.n))\13\n  else\13\n    checkArg(1, args[1], \"number\", \"nil\")\13\n    checkArg(2, args[2], \"string\", \"nil\")\13\n    seconds = args[1]\13\n    name = args[2]\13\n    filter = table.pack(table.unpack(args, 3, args.n))\13\n  end\13\n\13\n  local hasFilter = name ~= nil\13\n  if not hasFilter then\13\n    for i = 1, filter.n do\13\n      hasFilter = hasFilter or filter[i] ~= nil\13\n    end\13\n  end\13\n\13\n  local deadline = seconds and\13\n                   (computer.uptime() + seconds) or\13\n                   (hasFilter and math.huge or 0)\13\n  repeat\13\n    local closest = seconds and deadline or math.huge\13\n    for _, timer in pairs(timers) do\13\n      closest = math.min(closest, timer.after)\13\n    end\13\n    local signal = table.pack(computer.pullSignal(closest - computer.uptime()))\13\n    if signal.n > 0 then\13\n      dispatch(table.unpack(signal, 1, signal.n))\13\n    end\13\n    tick()\13\n    if event.shouldInterrupt() then\13\n      lastInterrupt = computer.uptime()\13\n      error(\"interrupted\", 0)\13\n    end\13\n    if not (seconds or hasFilter) or matches(signal, name, filter) then\13\n      return table.unpack(signal, 1, signal.n)\13\n    end\13\n  until computer.uptime() >= deadline\13\nend\13\n\13\nfunction event.shouldInterrupt()\13\n  return computer.uptime() - lastInterrupt > 1 and\13\n         keyboard.isControlDown() and\13\n         keyboard.isAltDown() and\13\n         keyboard.isKeyDown(keyboard.keys.c)\13\nend\13\n\13\nfunction event.timer(interval, callback, times)\13\n  checkArg(1, interval, \"number\")\13\n  checkArg(2, callback, \"function\")\13\n  checkArg(3, times, \"number\", \"nil\")\13\n  local id\13\n  repeat\13\n    id = math.floor(math.random(1, 0x7FFFFFFF))\13\n  until not timers[id]\13\n  timers[id] = {\13\n    interval = interval,\13\n    after = computer.uptime() + interval,\13\n    callback = callback,\13\n    times = times or 1\13\n  }\13\n  return id\13\nend\13\n\13\n-------------------------------------------------------------------------------\13\n\13\nreturn event\13\n",["/boot/01_os.lua"]="local computer = require(\"computer\")\13\nlocal event = require(\"event\")\13\nlocal fs = require(\"filesystem\")\13\nlocal shell = require(\"shell\")\13\nlocal unicode = require(\"unicode\")\13\n\13\nlocal env = {\13\n  EDITOR=\"/bin/edit\",\13\n  HISTSIZE=\"10\",\13\n  HOME=\"/home\",\13\n  IFS=\" \",\13\n  MANPATH=\"/usr/man:.\",\13\n  PAGER=\"/bin/more\",\13\n  PATH=\"/bin:/usr/bin:/home/bin:.\",\13\n  PS1=\"$PWD# \",\13\n  PWD=\"/\",\13\n  SHELL=\"/bin/sh\",\13\n  TMP=\"/tmp\", -- Deprecated\13\n  TMPDIR=\"/tmp\"\13\n}\13\n\13\nos.execute = function(command)\13\n  if not command then\13\n    return type(shell) == \"table\"\13\n  end\13\n  return shell.execute(command)\13\nend\13\n\13\nfunction os.exit(code)\13\n  error({reason=\"terminated\", code=code~=false}, 0)\13\nend\13\n\13\nfunction os.getenv(varname)\13\n  if varname == '#' then\13\n    return #env\13\n  elseif varname ~= nil then\13\n    return env[varname]\13\n  else\13\n    return env\13\n  end\13\nend\13\n\13\nfunction os.setenv(varname, value)\13\n  checkArg(1, varname, \"string\", \"number\")\13\n  if value == nil then\13\n    env[varname] = nil\13\n  else\13\n    local success, val = pcall(tostring, value)\13\n    if success then\13\n      env[varname] = val\13\n      return env[varname]\13\n    else\13\n      return nil, val\13\n    end\13\n  end\13\nend\13\n\13\nfunction os.remove(...)\13\n  return fs.remove(...)\13\nend\13\n\13\nfunction os.rename(...)\13\n  return fs.rename(...)\13\nend\13\n\13\nfunction os.sleep(timeout)\13\n  checkArg(1, timeout, \"number\", \"nil\")\13\n  local deadline = computer.uptime() + (timeout or 0)\13\n  repeat\13\n    event.pull(deadline - computer.uptime())\13\n  until computer.uptime() >= deadline\13\nend\13\n\13\nfunction os.tmpname()\13\n  local path = os.getenv(\"TMPDIR\") or \"/tmp\"\13\n  if fs.exists(path) then\13\n    for i = 1, 10 do\13\n      local name = fs.concat(path, tostring(math.random(1, 0x7FFFFFFF)))\13\n      if not fs.exists(name) then\13\n        return name\13\n      end\13\n    end\13\n  end\13\nend\13\n\13\nif computer.tmpAddress() then\13\n  fs.mount(computer.tmpAddress(), os.getenv(\"TMPDIR\") or \"/tmp\")\13\nend\13\n",["/lib/term.lua"]="local component = require(\"component\")\13\nlocal computer = require(\"computer\")\13\nlocal event = require(\"event\")\13\nlocal keyboard = require(\"keyboard\")\13\nlocal text = require(\"text\")\13\nlocal unicode = require(\"unicode\")\13\n\13\nlocal term = {}\13\nlocal cursorX, cursorY = 1, 1\13\nlocal cursorBlink = nil\13\n\13\nlocal function toggleBlink()\13\n  if term.isAvailable() then\13\n    cursorBlink.state = not cursorBlink.state\13\n    if cursorBlink.state then\13\n      cursorBlink.alt = component.gpu.get(cursorX, cursorY)\13\n      component.gpu.set(cursorX, cursorY, string.rep(unicode.char(0x2588), unicode.charWidth(cursorBlink.alt))) -- solid block\13\n    else\13\n      component.gpu.set(cursorX, cursorY, cursorBlink.alt)\13\n    end\13\n  end\13\nend\13\n\13\n-------------------------------------------------------------------------------\13\n\13\nfunction term.clear()\13\n  if term.isAvailable() then\13\n    local w, h = component.gpu.getResolution()\13\n    component.gpu.fill(1, 1, w, h, \" \")\13\n  end\13\n  cursorX, cursorY = 1, 1\13\nend\13\n\13\nfunction term.clearLine()\13\n  if term.isAvailable() then\13\n    local w = component.gpu.getResolution()\13\n    component.gpu.fill(1, cursorY, w, 1, \" \")\13\n  end\13\n  cursorX = 1\13\nend\13\n\13\nfunction term.getCursor()\13\n  return cursorX, cursorY\13\nend\13\n\13\nfunction term.setCursor(col, row)\13\n  checkArg(1, col, \"number\")\13\n  checkArg(2, row, \"number\")\13\n  if cursorBlink and cursorBlink.state then\13\n    toggleBlink()\13\n  end\13\n  local wide, right = term.isWide(cursorX, cursorY)\13\n  if wide and right then\13\n    cursorX = cursorX - 1\13\n  end\13\n  cursorX = math.floor(col)\13\n  cursorY = math.floor(row)\13\nend\13\n\13\nfunction term.getCursorBlink()\13\n  return cursorBlink ~= nil\13\nend\13\n\13\nfunction term.setCursorBlink(enabled)\13\n  checkArg(1, enabled, \"boolean\")\13\n  if enabled then\13\n    if not cursorBlink then\13\n      cursorBlink = {}\13\n      cursorBlink.id = event.timer(0.5, toggleBlink, math.huge)\13\n      cursorBlink.state = false\13\n    elseif not cursorBlink.state then\13\n      toggleBlink()\13\n    end\13\n  elseif cursorBlink then\13\n    event.cancel(cursorBlink.id)\13\n    if cursorBlink.state then\13\n      toggleBlink()\13\n    end\13\n    cursorBlink = nil\13\n  end\13\nend\13\n\13\nfunction term.isWide(x, y)\13\n  local char = component.gpu.get(x, y)\13\n  if unicode.isWide(char) then\13\n    -- The char at the specified position is a wide char.\13\n    return true\13\n  end\13\n  if char == \" \" and x > 1 then\13\n    local charLeft = component.gpu.get(x - 1, y)\13\n    if charLeft and unicode.isWide(charLeft) then\13\n      -- The char left to the specified position is a wide char.\13\n      return true, true\13\n    end\13\n  end\13\n  -- Not a wide char.\13\n  return false\13\nend\13\n\13\nfunction term.isAvailable()\13\n  return component.isAvailable(\"gpu\") and component.isAvailable(\"screen\")\13\nend\13\n\13\nfunction term.read(history, dobreak)\13\n  checkArg(1, history, \"table\", \"nil\")\13\n  history = history or {}\13\n  table.insert(history, \"\")\13\n  local offset = term.getCursor() - 1\13\n  local scrollX, scrollY = 0, #history - 1\13\n  local cursorX = 1\13\n\13\n  local function getCursor()\13\n    return cursorX, 1 + scrollY\13\n  end\13\n\13\n  local function line()\13\n    local _, cby = getCursor()\13\n    return history[cby]\13\n  end\13\n\13\n  local function setCursor(nbx, nby)\13\n    local w, h = component.gpu.getResolution()\13\n    local cx, cy = term.getCursor()\13\n\13\n    scrollY = nby - 1\13\n\13\n    nbx = math.max(1, math.min(unicode.len(history[nby]) + 1, nbx))\13\n    local ncx = nbx + offset - scrollX\13\n    if ncx > w then\13\n      local sx = nbx - (w - offset)\13\n      local dx = math.abs(scrollX - sx)\13\n      scrollX = sx\13\n      component.gpu.copy(1 + offset + dx, cy, w - offset - dx, 1, -dx, 0)\13\n      local str = unicode.sub(history[nby], nbx - (dx - 1), nbx)\13\n      str = text.padRight(str, dx)\13\n      component.gpu.set(1 + math.max(offset, w - dx), cy, unicode.sub(str, 1 + math.max(0, dx - (w - offset))))\13\n    elseif ncx < 1 + offset then\13\n      local sx = nbx - 1\13\n      local dx = math.abs(scrollX - sx)\13\n      scrollX = sx\13\n      component.gpu.copy(1 + offset, cy, w - offset - dx, 1, dx, 0)\13\n      local str = unicode.sub(history[nby], nbx, nbx + dx)\13\n      --str = text.padRight(str, dx)\13\n      component.gpu.set(1 + offset, cy, str)\13\n    end\13\n\13\n    cursorX = nbx\13\n    term.setCursor(nbx - scrollX + offset, cy)\13\n  end\13\n\13\n  local function copyIfNecessary()\13\n    local cbx, cby = getCursor()\13\n    if cby ~= #history then\13\n      history[#history] = line()\13\n      setCursor(cbx, #history)\13\n    end\13\n  end\13\n\13\n  local function redraw()\13\n    local cx, cy = term.getCursor()\13\n    local bx, by = 1 + scrollX, 1 + scrollY\13\n    local w, h = component.gpu.getResolution()\13\n    local l = w - offset\13\n    local str = unicode.sub(history[by], bx, bx + l)\13\n    str = text.padRight(str, l)\13\n    component.gpu.set(1 + offset, cy, str)\13\n  end\13\n\13\n  local function home()\13\n    local cbx, cby = getCursor()\13\n    setCursor(1, cby)\13\n  end\13\n\13\n  local function ende()\13\n    local cbx, cby = getCursor()\13\n    setCursor(unicode.len(line()) + 1, cby)\13\n  end\13\n\13\n  local function left()\13\n    local cbx, cby = getCursor()\13\n    if cbx > 1 then\13\n      setCursor(cbx - 1, cby)\13\n      return true -- for backspace\13\n    end\13\n  end\13\n\13\n  local function right(n)\13\n    n = n or 1\13\n    local cbx, cby = getCursor()\13\n    local be = unicode.len(line()) + 1\13\n    if cbx < be then\13\n      setCursor(math.min(be, cbx + n), cby)\13\n    end\13\n  end\13\n\13\n  local function up()\13\n    local cbx, cby = getCursor()\13\n    if cby > 1 then\13\n      setCursor(1, cby - 1)\13\n      redraw()\13\n      ende()\13\n    end\13\n  end\13\n\13\n  local function down()\13\n    local cbx, cby = getCursor()\13\n    if cby < #history then\13\n      setCursor(1, cby + 1)\13\n      redraw()\13\n      ende()\13\n    end\13\n  end\13\n\13\n  local function delete()\13\n    copyIfNecessary()\13\n    local cbx, cby = getCursor()\13\n    if cbx <= unicode.len(line()) then\13\n      local cw = unicode.charWidth(unicode.sub(line(), cbx))\13\n      history[cby] = unicode.sub(line(), 1, cbx - 1) ..\13\n                     unicode.sub(line(), cbx + 1)\13\n      local cx, cy = term.getCursor()\13\n      local w, h = component.gpu.getResolution()\13\n      component.gpu.copy(cx + cw, cy, w - cx, 1, -cw, 0)\13\n      local br = cbx + (w - cx)\13\n      local char = unicode.sub(line(), br, br)\13\n      if not char or unicode.wlen(char) == 0 then\13\n        char = \" \"\13\n      end\13\n      component.gpu.set(w, cy, char)\13\n    end\13\n  end\13\n\13\n  local function insert(value)\13\n    copyIfNecessary()\13\n    local cx, cy = term.getCursor()\13\n    local cbx, cby = getCursor()\13\n    local w, h = component.gpu.getResolution()\13\n    history[cby] = unicode.sub(line(), 1, cbx - 1) ..\13\n                   value ..\13\n                   unicode.sub(line(), cbx)\13\n    local len = unicode.wlen(value)\13\n    local n = w - (cx - 1) - len\13\n    if n > 0 then\13\n      component.gpu.copy(cx, cy, n, 1, len, 0)\13\n    end\13\n    component.gpu.set(cx, cy, value)\13\n    right(unicode.len(value))\13\n  end\13\n\13\n  local function onKeyDown(char, code)\13\n    term.setCursorBlink(false)\13\n    if code == keyboard.keys.back then\13\n      if left() then delete() end\13\n    elseif code == keyboard.keys.delete then\13\n      delete()\13\n    elseif code == keyboard.keys.left then\13\n      left()\13\n    elseif code == keyboard.keys.right then\13\n      right()\13\n    elseif code == keyboard.keys.home then\13\n      home()\13\n    elseif code == keyboard.keys[\"end\"] then\13\n      ende()\13\n    elseif code == keyboard.keys.up then\13\n      up()\13\n    elseif code == keyboard.keys.down then\13\n      down()\13\n    elseif code == keyboard.keys.enter then\13\n      local cbx, cby = getCursor()\13\n      if cby ~= #history then -- bring entry to front\13\n        history[#history] = line()\13\n        table.remove(history, cby)\13\n      end\13\n      return true, history[#history] .. \"\\n\"\13\n    elseif keyboard.isControlDown() and code == keyboard.keys.d then\13\n      if line() == \"\" then\13\n        history[#history] = \"\"\13\n        return true, nil\13\n      end\13\n    elseif keyboard.isControlDown() and code == keyboard.keys.c then\13\n      history[#history] = \"\"\13\n      return true, nil\13\n    elseif not keyboard.isControl(char) then\13\n      insert(unicode.char(char))\13\n    end\13\n    term.setCursorBlink(true)\13\n    term.setCursorBlink(true) -- force toggle to caret\13\n  end\13\n\13\n  local function onClipboard(value)\13\n    copyIfNecessary()\13\n    term.setCursorBlink(false)\13\n    local cbx, cby = getCursor()\13\n    local l = value:find(\"\\n\", 1, true)\13\n    if l then\13\n      history[cby] = unicode.sub(line(), 1, cbx - 1)\13\n      redraw()\13\n      insert(unicode.sub(value, 1, l - 1))\13\n      return true, line() .. \"\\n\"\13\n    else\13\n      insert(value)\13\n      term.setCursorBlink(true)\13\n      term.setCursorBlink(true) -- force toggle to caret\13\n    end\13\n  end\13\n\13\n  local function cleanup()\13\n    if history[#history] == \"\" then\13\n      table.remove(history)\13\n    end\13\n    term.setCursorBlink(false)\13\n    if term.getCursor() > 1 and dobreak ~= false then\13\n      print()\13\n    end\13\n  end\13\n\13\n  term.setCursorBlink(true)\13\n  while term.isAvailable() do\13\n    local ocx, ocy = getCursor()\13\n    local ok, name, address, charOrValue, code = pcall(event.pull)\13\n    if not ok then\13\n      cleanup()\13\n      error(\"interrupted\", 0)\13\n    end\13\n    local ncx, ncy = getCursor()\13\n    if ocx ~= ncx or ocy ~= ncy then\13\n      cleanup()\13\n      return \"\" -- soft fail the read if someone messes with the term\13\n    end\13\n    if term.isAvailable() and -- may have changed since pull\13\n       type(address) == \"string\" and\13\n       component.isPrimary(address)\13\n    then\13\n      local done, result\13\n      if name == \"key_down\" then\13\n        done, result = onKeyDown(charOrValue, code)\13\n      elseif name == \"clipboard\" then\13\n        done, result = onClipboard(charOrValue)\13\n      end\13\n      if done then\13\n        cleanup()\13\n        return result\13\n      end\13\n    end\13\n  end\13\n  cleanup()\13\n  return nil -- fail the read if term becomes unavailable\13\nend\13\n\13\nfunction term.write(value, wrap)\13\n  if not term.isAvailable() then\13\n    return\13\n  end\13\n  value = text.detab(tostring(value))\13\n  if unicode.wlen(value) == 0 then\13\n    return\13\n  end\13\n  do\13\n    local noBell = value:gsub(\"\\a\", \"\")\13\n    if #noBell ~= #value then\13\n      value = noBell\13\n      computer.beep()\13\n    end\13\n  end\13\n  local w, h = component.gpu.getResolution()\13\n  if not w then\13\n    return -- gpu lost its screen but the signal wasn't processed yet.\13\n  end\13\n  local blink = term.getCursorBlink()\13\n  term.setCursorBlink(false)\13\n  local line, nl\13\n  repeat\13\n    local wrapAfter, margin = math.huge, math.huge\13\n    if wrap then\13\n      wrapAfter, margin = w - (cursorX - 1), w\13\n    end\13\n    line, value, nl = text.wrap(value, wrapAfter, margin)\13\n    component.gpu.set(cursorX, cursorY, line)\13\n    cursorX = cursorX + unicode.wlen(line)\13\n    if nl or (cursorX > w and wrap) then\13\n      cursorX = 1\13\n      cursorY = cursorY + 1\13\n    end\13\n    if cursorY > h then\13\n      component.gpu.copy(1, 1, w, h, 0, -1)\13\n      component.gpu.fill(1, h, w, 1, \" \")\13\n      cursorY = h\13\n    end\13\n  until not value\13\n  term.setCursorBlink(blink)\13\nend\13\n\13\n-------------------------------------------------------------------------------\13\n\13\nreturn term\13\n",["/boot/00_base.lua"]="function dofile(filename)\13\n  local program, reason = loadfile(filename)\13\n  if not program then\13\n    return error(reason, 0)\13\n  end\13\n  return program()\13\nend\13\n\13\nfunction loadfile(filename, mode, env)\13\n  local file, reason = io.open(filename)\13\n  if not file then\13\n    return nil, reason\13\n  end\13\n  local source, reason = file:read(\"*a\")\13\n  file:close()\13\n  if not source then\13\n    return nil, reason\13\n  end\13\n  if string.sub(source, 1, 1) == \"#\" then\13\n    local endline = string.find(source, \"\\n\", 2, true)\13\n    if endline then\13\n      source = string.sub(source, endline + 1)\13\n    else\13\n      source = \"\"\13\n    end\13\n  end\13\n  return load(source, \"=\" .. filename, mode, env)\13\nend\13\n\13\nfunction print(...)\13\n  local args = table.pack(...)\13\n  io.stdout:setvbuf(\"line\")\13\n  for i = 1, args.n do\13\n    local arg = tostring(args[i])\13\n    if i > 1 then\13\n      arg = \"\\t\" .. arg\13\n    end\13\n    io.stdout:write(arg)\13\n  end\13\n  io.stdout:write(\"\\n\")\13\n  io.stdout:setvbuf(\"no\")\13\n  io.stdout:flush()\13\nend\13\n",["/init.lua"]="do\n  _G._OSVERSION = \"Cyan 0.1\" -- Based off of OpenOS 1.2 - very much the same code.\n\n  local component = component\n  local computer = computer\n  local unicode = unicode\n\n  -- Low level dofile implementation to read filesystem libraries.\n  local rom = {}\n  function rom.invoke(method, ...)\n    return component.invoke(computer.getBootAddress(), method, ...)\n  end\n  function rom.open(file) return rom.invoke(\"open\", file) end\n  function rom.read(handle) return rom.invoke(\"read\", handle, math.huge) end\n  function rom.close(handle) return rom.invoke(\"close\", handle) end\n  function rom.inits() return ipairs(rom.invoke(\"list\", \"boot\")) end\n  function rom.isDirectory(path) return rom.invoke(\"isDirectory\", path) end\n\n  local screen = component.list('screen')()\n  for address in component.list('screen') do\n    if #component.invoke(address, 'getKeyboards') > 0 then\n      screen = address\n    end\n  end\n\n  -- Report boot progress if possible.\n  local gpu = component.list(\"gpu\")()\n  local w, h\n  if gpu and screen then\n    component.invoke(gpu, \"bind\", screen)\n    w, h = component.invoke(gpu, \"getResolution\")\n    component.invoke(gpu, \"setResolution\", w, h)\n    component.invoke(gpu, \"setBackground\", 0x000000)\n    component.invoke(gpu, \"setForeground\", 0xFFFFFF)\n    component.invoke(gpu, \"fill\", 1, 1, w, h, \" \")\n  end\n  local y = 1\n  local function status(msg)\n    if gpu and screen then\n      component.invoke(gpu, \"set\", 1, y, msg)\n      if y == h then\n        component.invoke(gpu, \"copy\", 1, 2, w, h - 1, 0, -1)\n        component.invoke(gpu, \"fill\", 1, h, w, 1, \" \")\n      else\n        y = y + 1\n      end\n    end\n  end\n\n  status(\"Booting \" .. _OSVERSION .. \"...\")\n\n  -- Custom low-level loadfile/dofile implementation reading from our ROM.\n  local function loadfile(file)\n    status(\"> \" .. file)\n    local handle, reason = rom.open(file)\n    if not handle then\n      error(reason)\n    end\n    local buffer = \"\"\n    repeat\n      local data, reason = rom.read(handle)\n      if not data and reason then\n        error(reason)\n      end\n      buffer = buffer .. (data or \"\")\n    until not data\n    rom.close(handle)\n    return load(buffer, \"=\" .. file)\n  end\n\n  local function dofile(file)\n    local program, reason = loadfile(file)\n    if program then\n      local result = table.pack(pcall(program))\n      if result[1] then\n        return table.unpack(result, 2, result.n)\n      else\n        error(result[2])\n      end\n    else\n      error(reason)\n    end\n  end\n\n  status(\"Initializing package management...\")\n\n  -- Load file system related libraries we need to load other stuff moree\n  -- comfortably. This is basically wrapper stuff for the file streams\n  -- provided by the filesystem components.\n  local package = dofile(\"/lib/package.lua\")\n\n  do\n    -- Unclutter global namespace now that we have the package module.\n    _G.component = nil\n    _G.computer = nil\n    _G.process = nil\n    _G.unicode = nil\n\n    -- Initialize the package module with some of our own APIs.\n    package.preload[\"buffer\"] = loadfile(\"/lib/buffer.lua\")\n    package.preload[\"component\"] = function() return component end\n    package.preload[\"computer\"] = function() return computer end\n    package.preload[\"filesystem\"] = loadfile(\"/lib/filesystem.lua\")\n    package.preload[\"io\"] = loadfile(\"/lib/io.lua\")\n    package.preload[\"unicode\"] = function() return unicode end\n\n    -- Inject the package and io modules into the global namespace, as in Lua.\n    _G.package = package\n    _G.io = require(\"io\")\n  end\n\n  status(\"Initializing file system...\")\n\n  -- Mount the ROM and temporary file systems to allow working on the file\n  -- system module from this point on.\n  local filesystem = require(\"filesystem\")\n  filesystem.mount(computer.getBootAddress(), \"/\")\n\n  status(\"Running boot scripts...\")\n\n  -- Run library startup scripts. These mostly initialize event handlers.\n  local scripts = {}\n  for _, file in rom.inits() do\n    local path = \"boot/\" .. file\n    if not rom.isDirectory(path) then\n      table.insert(scripts, path)\n    end\n  end\n  table.sort(scripts)\n  for i = 1, #scripts do\n    dofile(scripts[i])\n  end\n\n  -- Initialize process module.\n  if filesystem.exists(\"/lib/process.lua\") then\n    require(\"process\").install(\"/init.lua\", \"init\")\n  else\n    status(\"Bypassing process.lua (not found)\")\n  end\n\n  status(\"Initializing components...\")\n\n  for c, t in component.list() do\n    computer.pushSignal(\"component_added\", c, t)\n  end\n  os.sleep(0.5) -- Allow signal processing by libraries.\n  computer.pushSignal(\"init\") -- so libs know components are initialized.\n\n  status(\"Starting shell...\")\nend\n\nlocal function motd()\n  local f = io.open(\"/etc/motd\")\n  if not f then\n    return\n  end\n  if f:read(2) == \"#!\" then\n    f:close()\n    os.execute(\"/etc/motd\")\n  else\n    f:seek(\"set\", 0)\n    print(f:read(\"*a\"))\n    f:close()\n  end\nend\n\nwhile true do\n  require(\"term\").clear()\n  motd()\n  local result, reason = os.execute(os.getenv(\"SHELL\"))\n  if not result then\n    io.stderr:write((tostring(reason) or \"unknown error\") .. \"\\n\")\n    print(\"Press any key to continue.\")\n    os.sleep(0.5)\n    require(\"event\").pull(\"key\")\n  end\nend",["/boot/91_gpu.lua"]="local component = require(\"component\")\13\nlocal event = require(\"event\")\13\n\13\nlocal function onComponentAvailable(_, componentType)\13\n  if (componentType == \"screen\" and component.isAvailable(\"gpu\")) or\13\n     (componentType == \"gpu\" and component.isAvailable(\"screen\"))\13\n  then\13\n    component.gpu.bind(component.screen.address)\13\n    local depth = 2^(component.gpu.getDepth())\13\n    os.setenv(\"TERM\", \"term-\"..depth..\"color\")\13\n  end\13\nend\13\n\13\nevent.listen(\"component_available\", onComponentAvailable)\13\n",["/boot/92_keyboard.lua"]="local component = require(\"component\")\13\nlocal event = require(\"event\")\13\nlocal keyboard = require(\"keyboard\")\13\n\13\nlocal function onKeyDown(_, address, char, code)\13\n  if component.isPrimary(address) then\13\n    keyboard.pressedChars[char] = true\13\n    keyboard.pressedCodes[code] = true\13\n  end\13\nend\13\n\13\nlocal function onKeyUp(_, address, char, code)\13\n  if component.isPrimary(address) then\13\n    keyboard.pressedChars[char] = nil\13\n    keyboard.pressedCodes[code] = nil\13\n  end\13\nend\13\n\13\nlocal function onComponentUnavailable(_, componentType)\13\n  if componentType == \"keyboard\" then\13\n    keyboard.pressedChars = {}\13\n    keyboard.pressedCodes = {}\13\n  end\13\nend\13\n\13\nevent.listen(\"key_down\", onKeyDown)\13\nevent.listen(\"key_up\", onKeyUp)\13\nevent.listen(\"component_unavailable\", onComponentUnavailable)\13\n",["/lib/io.lua"]="local io, file = {}, {}\13\n\13\nlocal input, output\13\nlocal programs = setmetatable({}, {__mode=\"k\"}) -- maps program envs to i/o\13\n\13\nlocal function findOverride(filter)\13\n  local override\13\n  pcall(function()\13\n    for level = 1, math.huge do\13\n      local path, env = require(\"process\").running(level)\13\n      if not path or override then\13\n        return\13\n      end\13\n      if programs[env] then\13\n        override = filter(programs[env])\13\n      end\13\n    end\13\n  end)\13\n  return override\13\nend\13\n\13\nlocal function setInput(value)\13\n  if not pcall(function()\13\n    local path, env = require(\"process\").running()\13\n    programs[env] = programs[env] or {}\13\n    programs[env].input = value\13\n  end)\13\n  then\13\n    input = value\13\n  end\13\nend\13\n\13\nlocal function setOutput(value)\13\n  if not pcall(function()\13\n    local path, env = require(\"process\").running()\13\n    programs[env] = programs[env] or {}\13\n    programs[env].output = value\13\n  end)\13\n  then\13\n    output = value\13\n  end\13\nend\13\n\13\n-------------------------------------------------------------------------------\13\n\13\nfunction io.close(file)\13\n  return (file or io.output()):close()\13\nend\13\n\13\nfunction io.flush()\13\n  return io.output():flush()\13\nend\13\n\13\nfunction io.input(file)\13\n  if file then\13\n    if type(file) == \"string\" then\13\n      local result, reason = io.open(file)\13\n      if not result then\13\n        error(reason, 2)\13\n      end\13\n      setInput(result)\13\n    elseif io.type(file) then\13\n      setInput(file)\13\n    else\13\n      error(\"bad argument #1 (string or file expected, got \" .. type(file) .. \")\", 2)\13\n    end\13\n  end\13\n  return findOverride(function(env) return env.input end) or input\13\nend\13\n\13\nfunction io.lines(filename, ...) -- Modified in CA's local copy.\13\n  if filename then\13\n    local file, reason = io.open(filename)\13\n    if not file then\13\n      error(reason, 2)\13\n    end\13\n    local args = table.pack(...)\13\n    return function()\13\n      local result = table.pack(file:read(table.unpack(args, 1, args.n)))\13\n      if not result[1] then\13\n        if result[2] then\13\n          error(result[2], 2)\13\n        else -- eof\13\n          file:close()\13\n          return nil\13\n        end\13\n      end\13\n      return table.unpack(result, 1, result.n)\13\n    end\13\n  else\13\n    return io.input():lines()\13\n  end\13\nend\13\n\13\nfunction io.open(path, mode)\13\n  -- These requires are not on top because this is a bootstrapped file.\13\n  local stream, result = require(\"filesystem\").open(path, mode)\13\n  if stream then\13\n    return require(\"buffer\").new(mode, stream)\13\n  else\13\n    return nil, result\13\n  end\13\nend\13\n\13\nfunction io.output(file)\13\n  if file then\13\n    if type(file) == \"string\" then\13\n      local result, reason = io.open(file, \"w\")\13\n      if not result then\13\n        error(reason, 2)\13\n      end\13\n      setOutput(result)\13\n    elseif io.type(file) then\13\n      setOutput(file)\13\n    else\13\n      error(\"bad argument #1 (string or file expected, got \" .. type(file) .. \")\", 2)\13\n    end\13\n  end\13\n  return findOverride(function(env) return env.output end) or output\13\nend\13\n\13\n-- TODO io.popen = function(prog, mode) end\13\n\13\nfunction io.read(...)\13\n  return io.input():read(...)\13\nend\13\n\13\nfunction io.tmpfile()\13\n  local name = os.tmpname()\13\n  if name then\13\n    return io.open(name, \"a\")\13\n  end\13\nend\13\n\13\nfunction io.type(object)\13\n  if type(object) == \"table\" then\13\n    if getmetatable(object) == \"file\" then\13\n      if object.stream.handle then\13\n        return \"file\"\13\n      else\13\n        return \"closed file\"\13\n      end\13\n    end\13\n  end\13\n  return nil\13\nend\13\n\13\nfunction io.write(...)\13\n  return io.output():write(...)\13\nend\13\n\13\n-------------------------------------------------------------------------------\13\n\13\nreturn io\13\n",["/boot/02_io.lua"]="local buffer = require(\"buffer\")\13\nlocal term = require(\"term\")\13\n\13\nlocal io_open = io.open\13\nfunction io.open(path, mode)\13\n  return io_open(require(\"shell\").resolve(path), mode)\13\nend\13\n\13\nlocal stdinStream = {handle=\"stdin\"}\13\nlocal stdoutStream = {handle=\"stdout\"}\13\nlocal stderrStream = {handle=\"stderr\"}\13\nlocal stdinHistory = {}\13\n\13\nlocal function badFileDescriptor()\13\n  return nil, \"bad file descriptor\"\13\nend\13\n\13\nfunction stdinStream:close()\13\n  return nil, \"cannot close standard file\"\13\nend\13\nstdoutStream.close = stdinStream.close\13\nstderrStream.close = stdinStream.close\13\n\13\nfunction stdinStream:read(n, dobreak)\13\n  local result = term.read(stdinHistory, dobreak)\13\n  while #stdinHistory > 10 do\13\n    table.remove(stdinHistory, 1)\13\n  end\13\n  return result\13\nend\13\n\13\nfunction stdoutStream:write(str)\13\n  term.write(str, true)\13\n  return self\13\nend\13\n\13\nfunction stderrStream:write(str)\13\n  local component = require(\"component\")\13\n  if component.isAvailable(\"gpu\") and component.gpu.getDepth() > 1 then\13\n    local foreground = component.gpu.setForeground(0xFF0000)\13\n    term.write(str, true)\13\n    component.gpu.setForeground(foreground)\13\n  else\13\n    term.write(str, true)\13\n  end\13\n  return self\13\nend\13\n\13\nstdinStream.seek = badFileDescriptor\13\nstdinStream.write = badFileDescriptor\13\nstdoutStream.read = badFileDescriptor\13\nstdoutStream.seek = badFileDescriptor\13\nstderrStream.read = badFileDescriptor\13\nstderrStream.seek = badFileDescriptor\13\n\13\nio.stdin = buffer.new(\"r\", stdinStream)\13\nio.stdout = buffer.new(\"w\", stdoutStream)\13\nio.stderr = buffer.new(\"w\", stderrStream)\13\n\13\nio.stdout:setvbuf(\"no\")\13\nio.stderr:setvbuf(\"no\")\13\n\13\nio.input(io.stdin)\13\nio.output(io.stdout)\13\n",["/lib/package.lua"]="local package = {}\13\n\13\npackage.path = \"/lib/?.lua;/usr/lib/?.lua;/home/lib/?.lua;./?.lua\"\13\n\13\nlocal loading = {}\13\n\13\nlocal loaded = {\13\n  [\"_G\"] = _G,\13\n  [\"bit32\"] = bit32,\13\n  [\"coroutine\"] = coroutine,\13\n  [\"math\"] = math,\13\n  [\"os\"] = os,\13\n  [\"package\"] = package,\13\n  [\"string\"] = string,\13\n  [\"table\"] = table\13\n}\13\npackage.loaded = loaded\13\n\13\nlocal preload = {}\13\npackage.preload = preload\13\n\13\npackage.searchers = {}\13\n\13\nfunction package.searchpath(name, path, sep, rep)\13\n  checkArg(1, name, \"string\")\13\n  checkArg(2, path, \"string\")\13\n  sep = sep or '.'\13\n  rep = rep or '/'\13\n  sep, rep = '%' .. sep, rep\13\n  name = string.gsub(name, sep, rep)\13\n  local fs = require(\"filesystem\")\13\n  local errorFiles = {}\13\n  for subPath in string.gmatch(path, \"([^;]+)\") do\13\n    subPath = string.gsub(subPath, \"?\", name)\13\n    if subPath:sub(1, 1) ~= \"/\" and os.getenv then\13\n      subPath = fs.concat(os.getenv(\"PWD\") or \"/\", subPath)\13\n    end\13\n    if fs.exists(subPath) then\13\n      local file = io.open(subPath, \"r\")\13\n      if file then\13\n        file:close()\13\n        return subPath\13\n      end\13\n    end\13\n    table.insert(errorFiles, \"\\tno file '\" .. subPath .. \"'\")\13\n  end\13\n  return nil, table.concat(errorFiles, \"\\n\")\13\nend\13\n\13\nlocal function preloadSearcher(module)\13\n  if preload[module] ~= nil then\13\n    return preload[module]\13\n  else\13\n    return \"\\tno field package.preload['\" .. module .. \"']\"\13\n  end\13\nend\13\n\13\nlocal function pathSearcher(module)\13\n  local filepath, reason = package.searchpath(module, package.path)\13\n  if filepath then\13\n    local loader, reason = loadfile(filepath, \"bt\", _G)\13\n    if loader then\13\n      return loader, filepath\13\n    else\13\n      return reason\13\n    end\13\n  else\13\n    return reason\13\n  end\13\nend\13\n\13\ntable.insert(package.searchers, preloadSearcher)\13\ntable.insert(package.searchers, pathSearcher)\13\n\13\nfunction require(module)\13\n  checkArg(1, module, \"string\")\13\n  if loaded[module] ~= nil then\13\n    return loaded[module]\13\n  elseif not loading[module] then\13\n    loading[module] = true\13\n    local loader, value, errorMsg = nil, nil, {\"module '\" .. module .. \"' not found:\"}\13\n    for i = 1, #package.searchers do\13\n      -- the pcall is mostly for out of memory errors\13\n      local ok, f, extra = pcall(package.searchers[i], module)\13\n      if not ok then\13\n        table.insert(errorMsg, \"\\t\" .. f)\13\n      elseif f and type(f) ~= \"string\" then\13\n        loader = f\13\n        value = extra\13\n        break\13\n      elseif f then\13\n        table.insert(errorMsg, f)\13\n      end\13\n    end\13\n    if loader then\13\n      local success, result = pcall(loader, module, value)\13\n      loading[module] = false\13\n      if not success then\13\n        error(result, 2)\13\n      end\13\n      if result then\13\n        loaded[module] = result\13\n      elseif not loaded[module] then\13\n        loaded[module] = true\13\n      end\13\n      return loaded[module]\13\n    else\13\n      loading[module] = false\13\n      error(table.concat(errorMsg, \"\\n\"), 2)\13\n    end\13\n  else\13\n    error(\"already loading: \" .. module, 2)\13\n  end\13\nend\13\n\13\n-------------------------------------------------------------------------------\13\n\13\nreturn package\13\n",["/lib/keyboard.lua"]="local keyboard = {pressedChars = {}, pressedCodes = {}}\13\n\13\nkeyboard.keys = {\13\n  [\"1\"]           = 0x02,\13\n  [\"2\"]           = 0x03,\13\n  [\"3\"]           = 0x04,\13\n  [\"4\"]           = 0x05,\13\n  [\"5\"]           = 0x06,\13\n  [\"6\"]           = 0x07,\13\n  [\"7\"]           = 0x08,\13\n  [\"8\"]           = 0x09,\13\n  [\"9\"]           = 0x0A,\13\n  [\"0\"]           = 0x0B,\13\n  a               = 0x1E,\13\n  b               = 0x30,\13\n  c               = 0x2E,\13\n  d               = 0x20,\13\n  e               = 0x12,\13\n  f               = 0x21,\13\n  g               = 0x22,\13\n  h               = 0x23,\13\n  i               = 0x17,\13\n  j               = 0x24,\13\n  k               = 0x25,\13\n  l               = 0x26,\13\n  m               = 0x32,\13\n  n               = 0x31,\13\n  o               = 0x18,\13\n  p               = 0x19,\13\n  q               = 0x10,\13\n  r               = 0x13,\13\n  s               = 0x1F,\13\n  t               = 0x14,\13\n  u               = 0x16,\13\n  v               = 0x2F,\13\n  w               = 0x11,\13\n  x               = 0x2D,\13\n  y               = 0x15,\13\n  z               = 0x2C,\13\n\13\n  apostrophe      = 0x28,\13\n  at              = 0x91,\13\n  back            = 0x0E, -- backspace\13\n  backslash       = 0x2B,\13\n  colon           = 0x92,\13\n  comma           = 0x33,\13\n  enter           = 0x1C,\13\n  equals          = 0x0D,\13\n  grave           = 0x29, -- accent grave\13\n  lbracket        = 0x1A,\13\n  lcontrol        = 0x1D,\13\n  lmenu           = 0x38, -- left Alt\13\n  lshift          = 0x2A,\13\n  minus           = 0x0C,\13\n  numlock         = 0x45,\13\n  pause           = 0xC5,\13\n  period          = 0x34,\13\n  rbracket        = 0x1B,\13\n  rcontrol        = 0x9D,\13\n  rmenu           = 0xB8, -- right Alt\13\n  rshift          = 0x36,\13\n  scroll          = 0x46, -- Scroll Lock\13\n  semicolon       = 0x27,\13\n  slash           = 0x35, -- / on main keyboard\13\n  space           = 0x39,\13\n  stop            = 0x95,\13\n  tab             = 0x0F,\13\n  underline       = 0x93,\13\n\13\n  -- Keypad (and numpad with numlock off)\13\n  up              = 0xC8,\13\n  down            = 0xD0,\13\n  left            = 0xCB,\13\n  right           = 0xCD,\13\n  home            = 0xC7,\13\n  [\"end\"]         = 0xCF,\13\n  pageUp          = 0xC9,\13\n  pageDown        = 0xD1,\13\n  insert          = 0xD2,\13\n  delete          = 0xD3,\13\n\13\n  -- Function keys\13\n  f1              = 0x3B,\13\n  f2              = 0x3C,\13\n  f3              = 0x3D,\13\n  f4              = 0x3E,\13\n  f5              = 0x3F,\13\n  f6              = 0x40,\13\n  f7              = 0x41,\13\n  f8              = 0x42,\13\n  f9              = 0x43,\13\n  f10             = 0x44,\13\n  f11             = 0x57,\13\n  f12             = 0x58,\13\n  f13             = 0x64,\13\n  f14             = 0x65,\13\n  f15             = 0x66,\13\n  f16             = 0x67,\13\n  f17             = 0x68,\13\n  f18             = 0x69,\13\n  f19             = 0x71,\13\n\13\n  -- Japanese keyboards\13\n  kana            = 0x70,\13\n  kanji           = 0x94,\13\n  convert         = 0x79,\13\n  noconvert       = 0x7B,\13\n  yen             = 0x7D,\13\n  circumflex      = 0x90,\13\n  ax              = 0x96,\13\n\13\n  -- Numpad\13\n  numpad0         = 0x52,\13\n  numpad1         = 0x4F,\13\n  numpad2         = 0x50,\13\n  numpad3         = 0x51,\13\n  numpad4         = 0x4B,\13\n  numpad5         = 0x4C,\13\n  numpad6         = 0x4D,\13\n  numpad7         = 0x47,\13\n  numpad8         = 0x48,\13\n  numpad9         = 0x49,\13\n  numpadmul       = 0x37,\13\n  numpaddiv       = 0xB5,\13\n  numpadsub       = 0x4A,\13\n  numpadadd       = 0x4E,\13\n  numpaddecimal   = 0x53,\13\n  numpadcomma     = 0xB3,\13\n  numpadenter     = 0x9C,\13\n  numpadequals    = 0x8D,\13\n}\13\n\13\n-- Create inverse mapping for name lookup.\13\ndo\13\n  local keys = {}\13\n  for k in pairs(keyboard.keys) do\13\n    table.insert(keys, k)\13\n  end\13\n  for _, k in pairs(keys) do\13\n    keyboard.keys[keyboard.keys[k]] = k\13\n  end\13\nend\13\n\13\n-------------------------------------------------------------------------------\13\n\13\nfunction keyboard.isAltDown()\13\n  return (keyboard.pressedCodes[keyboard.keys.lmenu] or keyboard.pressedCodes[keyboard.keys.rmenu]) ~= nil\13\nend\13\n\13\nfunction keyboard.isControl(char)\13\n  return type(char) == \"number\" and (char < 0x20 or (char >= 0x7F and char <= 0x9F))\13\nend\13\n\13\nfunction keyboard.isControlDown()\13\n  return (keyboard.pressedCodes[keyboard.keys.lcontrol] or keyboard.pressedCodes[keyboard.keys.rcontrol]) ~= nil\13\nend\13\n\13\nfunction keyboard.isKeyDown(charOrCode)\13\n  checkArg(1, charOrCode, \"string\", \"number\")\13\n  if type(charOrCode) == \"string\" then\13\n    return keyboard.pressedChars[charOrCode]\13\n  elseif type(charOrCode) == \"number\" then\13\n    return keyboard.pressedCodes[charOrCode]\13\n  end\13\nend\13\n\13\nfunction keyboard.isShiftDown()\13\n  return (keyboard.pressedCodes[keyboard.keys.lshift] or keyboard.pressedCodes[keyboard.keys.rshift]) ~= nil\13\nend\13\n\13\n-------------------------------------------------------------------------------\13\n\13\nreturn keyboard\13\n"},depends={},version="0.1.3",conflicts={}}