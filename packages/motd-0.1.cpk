{contents={["/etc/motd"]="#!/bin/lua\13\n\13\nlocal component = require(\"component\")\13\nlocal computer = require(\"computer\")\13\nlocal text = require(\"text\")\13\nlocal unicode = require(\"unicode\")\13\n\13\nif not component.isAvailable(\"gpu\") then\13\n  return\13\nend\13\nlocal lines = {_OSVERSION .. \" (\" .. math.floor(computer.totalMemory() / 1024) .. \"k RAM)\"}\13\nlocal maxWidth = unicode.len(lines[1])\13\nlocal f = io.open(\"/usr/misc/greetings.txt\")\13\nif f then\13\n  local greetings = {}\13\n  pcall(function()\13\n    for line in f:lines() do table.insert(greetings, line) end\13\n  end)\13\n  f:close()\13\n  local greeting = greetings[math.random(1, #greetings)]\13\n  if greeting then\13\n    local width = math.max(10, component.gpu.getResolution())\13\n    for line in text.wrappedLines(greeting, width - 4, width - 4) do\13\n      table.insert(lines, line)\13\n      maxWidth = math.max(maxWidth, unicode.len(line))\13\n    end\13\n  end\13\nend\13\nlocal borders = {{unicode.char(0x2552), unicode.char(0x2550), unicode.char(0x2555)},\13\n                 {unicode.char(0x2502), nil, unicode.char(0x2502)},\13\n                 {unicode.char(0x2514), unicode.char(0x2500), unicode.char(0x2518)}}\13\nio.write(borders[1][1] .. string.rep(borders[1][2], maxWidth + 2) .. borders[1][3] .. \"\\n\")\13\nfor _, line in ipairs(lines) do\13\n  io.write(borders[2][1] .. \" \" .. text.padRight(line, maxWidth) .. \" \" .. borders[2][3] .. \"\\n\")\13\nend\13\nio.write(borders[3][1] .. string.rep(borders[3][2], maxWidth + 2) .. borders[3][3] .. \"\\n\")\13\n",["/usr/misc/greetings.txt"]="Tier 2 and 3 screens can act as touch screens - don't attach a keyboard or sneak-activate them.\13\nYou can change the text size on screens by changing their resolution - run `resolution 40 16` in the shell.\13\nFiring arrows on touch capable screens can trigger touch events.\13\nItem colors indicate their tier - white is tier one, yellow is tier two and cyan is tier three.\13\nUse an Analyzer to get more information on blocks - for example, to find out why a computer crashed.\13\nKeyboards have to be attached to or placed next to a screen to work.\13\nYou can install OpenOS on a writable medium by running the `install` program.\13\nInternet Cards can be used to make HTTP requests and open raw TCP connections.\13\nIf you crafted something by mistake or don't need it any longer, throw it into a disassembler.\13\nHave a look at the code of the built-in programs for examples on how to use the APIs.\13\nMost programs can be interrupted by pressing Ctrl+Alt+C.\13\nPaste the contents of the clipboard using the middle mouse button or a configurable key (default: insert).\13\nComputers will consume less power while idling - i.e. when os.sleep(n > 0.05) is called.\13\nScreens will consume more power the more lit characters they display.\13\nMost blocks act as 'cables' - use switches and power distributes to create separate networks.\13\nWelcome to the dark side - here, have some cookies.\13\nScreens can display all of Codepage 437 - paste the special chars or use unicode.char.\13\nRun `help` or `man programname` for ingame help on programs shipped with OpenOS - start with `man man`.\13\nFor more help, there's a wiki on Github - or find the IRC loot disk and join #oc.\13\nComputers have a very basic, built-in speaker - control it using computer.beep().\13\nMany component methods have a short documentation - use `=component.componentName.methodName` in the Lua interpreter to see it.\13\nYou can get a list of all attached components using the `components` program.\13\nIf you encounter out of memory errors, throw more RAM at your computer.\13\nHave you tried turning it off and on again?\13\nTo disable this greeting, install OpenOS to a writeable medium and delete `/etc/motd`.\13\nChange the text size by changing the screen resolution - try using the `resolution` program."},name="motd",conflicts={},depends={"init"},version="0.1"}