{depends={"libcyan","init","libserialization","libcrypto"},name="cpt",contents={["/usr/lib/cptlock.lua"]="local cptlock = {}\13\n\13\nlocal locktaken = false\13\n\13\nfunction cptlock.lock() -- TODO: more robust locking?\13\n\9if locktaken then\13\n\9\9error(\"CPT caches already locked!\")\13\n\9end\13\n\9locktaken = true\13\nend\13\n\13\nfunction cptlock.unlock()\13\n\9if not locktaken then\13\n\9\9error(\"CPT caches not locked!\")\13\n\9end\13\n\9locktaken = false\13\nend\13\n\13\nreturn cptlock",["/usr/lib/cptcache.lua"]="local cptcache = {}\n\n-- TODO: include versioning in cache!\n\nlocal cyan = require(\"cyan\")\nlocal cptpack = require(\"cptpack\")\nlocal filesystem = require(\"filesystem\")\nlocal serialization = require(\"serialization\")\n\n-- Remote packages and cache synchronization\n\nfunction cptcache.remoteindexpath()\n\9return cptpack.toroot(filesystem.concat(cptcache.cachedir, \"remoteindex\"))\nend\n\nfunction cptcache.localindexpath()\n\9return cptpack.toroot(filesystem.concat(cptcache.cachedir, \"localindex\"))\nend\n\nlocal function mergeremote(index, source)\n\9local rindex\n\9if source:sub(1, 8) == \"local://\" then\n\9\9rindex = cptpack.readindex(source:sub(9))\n\9else\n\9\9rindex = cptpack.readremoteindex(source)\n\9end\n\9cptpack.setsources(rindex, source)\n\9cptpack.mergeindex(index, rindex)\nend\n\ncptcache.configpath = \"/etc/cpt.list\"\ncptcache.cachedir = \"/var/cache/cpt/\"\nfunction cptcache.synchronizerepos(unrootconfig)\n\9print(\"Synchronizing repository cache...\")\n\9print(\"Building remote index...\")\n\9local rindex = cptpack.makeindex()\n\9print(\"Loading remote repositories...\")\n\9local path = cptpack.toroot(cptcache.configpath)\n\9if unrootconfig then\n\9\9path = cptcache.configpath\n\9end\n\9for _, v in ipairs(cyan.readserialized(path)) do\n\9\9mergeremote(rindex, v)\n\9end\n\9print(\"Saving remote index...\")\n\9cyan.makeParentDirectory(cptcache.remoteindexpath())\n\9cptpack.writeindex(cptcache.remoteindexpath(), rindex)\n\9print(\"Completed index synchronization.\")\nend\n\nfunction cptcache.loadlocalindex()\n\9return cptpack.readindex(cptcache.localindexpath())\nend\n\nfunction cptcache.loadremoteindex()\n\9return cptpack.readindex(cptcache.remoteindexpath())\nend\n\nlocal function downloadpkg(name, source, target)\n\9local data\n\9if source:sub(1, 8) == \"local://\" then\n\9\9print(\"Fetching\", name, \"locally...\")\n\9\9data = cyan.readall(filesystem.concat(filesystem.path(source:sub(9)), name .. \".cpk\"))\n\9elseif source:sub(1, 8) == \"https://\" then\n\9\9print(\"Fetching\", name, \"remotely...\")\n\9\9data = cyan.readremote(\"https://\" .. filesystem.concat(filesystem.path(source:sub(9)), name .. \".cpk\"))\n\9elseif source:sub(1, 7) == \"http://\" then\n\9\9print(\"Fetching\", name, \"remotely...\")\n\9\9data = cyan.readremote(\"http://\" .. filesystem.concat(filesystem.path(source:sub(8)), name .. \".cpk\"))\n\9else\n\9\9error(\"Unknown source: \" .. source)\n\9end\n\9local hash = cptpack.packhash(data)\n\9cyan.writeall(target, data)\n\9return hash\nend\n\n-- Local packages\n\nfunction cptcache.verifyindex(index)\n\9local toremove = {}\n\9for name in cptpack.listindex(index) do\n\9\9if not filesystem.exists(cptcache.getpath(name)) then\n\9\9\9print(\"WARNING: Cannot find indexed package in cache: \" .. name)\n\9\9\9table.insert(toremove, name)\n\9\9end\n\9end\n\9for _, v in ipairs(toremove) do\n\9\9cptpack.removeindex(index, v)\n\9end\n\9if #toremove ~= 0 then\n\9\9print(\"Removed\", #toremove, \"missing packages from local index.\")\n\9end\nend\n\nfunction cptcache.getpackages(names)\n\9print(\"Getting\", #names, \"packages...\")\n\9print(\"Loading and verifying index...\")\n\9local lindex = cptcache.loadlocalindex()\n\9local rindex = cptcache.loadremoteindex()\n\9cptcache.verifyindex(lindex)\n\9print(\"Calculating deltas...\")\n\9local needed = {}\n\9for _, v in ipairs(names) do\n\9\9if not cptpack.hasindex(lindex, v) then\n\9\9\9table.insert(needed, v)\n\9\9end\n\9end\n\9if #needed == 0 then\n\9\9print(\"No packages need fetching.\")\n\9else\n\9\9print(\"Fetching\", #needed, \"packages and modifying local index...\")\n\9\9for _, name in ipairs(needed) do\n\9\9\9local hash = downloadpkg(name, cptpack.getsource(rindex, name), cptcache.getpath(name))\n\9\9\9if hash ~= cptpack.gethash(rindex, name) then\n\9\9\9\9error(\"Bad hash on package: \" .. name .. \": got \" .. hash .. \" instead of \" .. cptpack.gethash(rindex, name))\n\9\9\9end\n\9\9\9cptpack.mergesingleindex(lindex, rindex, name)\n\9\9end\n\9end\n\9print(\"Writing out local index...\")\n\9cyan.makeParentDirectory(cptcache.localindexpath())\n\9cptpack.writeindex(cptcache.localindexpath(), lindex)\n\9print(\"Completed get of\", #names, \"packages.\")\nend\n\nfunction cptcache.getpath(name)\n\9return cptpack.toroot(filesystem.concat(cptcache.cachedir, name .. \".cpk\"))\nend\n\nfunction cptcache.dumpcache()\n\9print(\"Remote index:\")\n\9cptpack.dumpindex(cptcache.loadremoteindex())\n\9print(\"Local index:\")\n\9cptpack.dumpindex(cptcache.loadlocalindex())\nend\n\nfunction cptcache.initcache()\n\9print(\"Building empty local index...\")\n\9if filesystem.exists(cptcache.localindexpath()) then\n\9\9error(\"Error: not overwriting existing local index.\")\n\9end\n\9cyan.makeParentDirectory(cptcache.localindexpath())\n\9cptpack.writeindex(cptcache.localindexpath(), cptpack.makeindex())\n\9print(\"Built empty local index!\")\nend\n\nfunction cptcache.flushcache()\n\9error(\"Cache flushing not currently implemented.\") -- Remember that cptinstall.lua requires that the local cache contains all of the currently-installed packages.\n\9--[[print(\"Flushing repository cache...\")\n\9local count = 0\n\9for name in filesystem.list(cptcache.cachedir) do\n\9\9if name:sub(#name - 3) == \".cpk\" then\n\9\9\9count = count + 1\n\9\9\9cyan.removesinglefile(name)\n\9\9end\n\9end\n\9print(\"Removed\", count, \"packages from cache.\")\n\9local cptcache.cachedir = dir or cptcache.cachedir\n\9local cached = cptcache.loadcache(cptcache.cachedir, initialize)\n\9local todelete = cyan.keylist(cached)\n\9print(\"Saving changes...\")\n\9cyan.writeserialized(cptpack.toroot(filesystem.concat(cptcache.cachedir, \"listing\")), {})\n\9print(\"Removing\", #todelete, \"packages.\")\n\9for i, name in ipairs(todelete) do\n\9\9print(\"Deleting cached version of\", name)\n\9\9local path = cptpack.toroot(filesystem.concat(cptcache.cachedir, name .. \".cpk\"))\n\9\9if filesystem.exists(path) then\n\9\9\9cyan.removeSingleFile(path)\n\9\9else\n\9\9\9print(\"(File did not exist, anyway.)\")\n\9\9end\n\9end\n\9print(\"Completed cache flush.\")]]\nend\n\nreturn cptcache",["/etc/cpt.list"]="{\"https://raw.githubusercontent.com/ComputationalAlchemist/MC-OC-Cyan/master/packages/core.cpt\"}",["/usr/lib/cptpack.lua"]="local cptpack = {}\13\nlocal filesystem = require(\"filesystem\")\13\nlocal cyan = require(\"cyan\")\13\nlocal shell = require(\"shell\")\13\nlocal crypto = require(\"crypto\")\13\n\13\ncptpack.root = \"/\"\13\n\13\nfunction cptpack.compareversion(a, b)\13\n\9if a == nil and b == nil then\13\n\9\9return 0\13\n\9elseif a == nil then\13\n\9\9return -1\13\n\9elseif b == nil then\13\n\9\9return 1\13\n\9end\13\n\9local ab, ar = cyan.cut(a, \"[.]\")\13\n\9local bb, br = cyan.cut(b, \"[.]\")\13\n\9local abn = tonumber(ab)\13\n\9if abn == nil then\13\n\9\9error(\"Bad version: not a number: \" .. ab .. \" in \" .. a)\13\n\9end\13\n\9local bbn = tonumber(bb)\13\n\9if bbn == nil then\13\n\9\9error(\"Bad version: not a number: \" .. bb .. \" in \" .. b)\13\n\9end\13\n\9if abn > bbn then\13\n\9\9return 1\13\n\9elseif abn < bbn then\13\n\9\9return -1\13\n\9else\13\n\9\9return cptpack.compareversion(ar, br)\13\n\9end\13\nend\13\n\13\nfunction cptpack.toroot(file)\13\n\9if file:sub(1, 1) == \"/\" then\13\n\9\9return filesystem.concat(cptpack.root, file:sub(2))\13\n\9else\13\n\9\9return file\13\n\9end\13\nend\13\n\13\nfunction cptpack.loadindex(path)\13\n\9local data = cyan.readserialized(path)\13\n\9data.listing = cyan.keylist(data.contents)\13\n\9data.contents = nil\13\n\9return data\13\nend\13\n\13\nlocal function tryremoveparents(file)\13\n\9local parent = filesystem.path(file)\13\n\9if cyan.isDirectoryEmpty(parent) then\13\n\9\9print(\"Parent directory is no longer in use:\", parent)\13\n\9\9filesystem.remove(parent)\13\n\9\9tryremoveparents(parent)\13\n\9end\13\nend\13\n\13\nfunction cptpack.uninstall(index, name)\13\n\9assert(cptpack.hasindex(index, name))\13\n\9print(\"Uninstalling\", name)\13\n\9for i, file in ipairs(cptpack.listingfromindex(index, name)) do\13\n\9\9if not filesystem.exists(cptpack.toroot(file)) then\13\n\9\9\9print(\"Would remove\", cptpack.toroot(file), \"but it didn't exist.\")\13\n\9\9else\13\n\9\9\9print(\"Removing\", cptpack.toroot(file))\13\n\9\9\9if file:sub(1, 1) ~= \"/\" then\13\n\9\9\9\9error(\"Invalid path - no leading slash!\")\13\n\9\9\9end\13\n\9\9\9cyan.removeSingleFile(cptpack.toroot(file))\13\n\9\9\9tryremoveparents(cptpack.toroot(file))\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction cptpack.install(pname, path)\13\n\9local data = cyan.readserialized(path)\13\n\9assert(pname == data.name .. \"-\" .. data.version)\13\n\9print(\"Installing\", pname)\13\n\9for name, data in pairs(data.contents) do\13\n\9\9if name:sub(1, 1) ~= \"/\" then\13\n\9\9\9error(\"Invalid path - no leading slash!\")\13\n\9\9end\13\n\9\9print(\"Adding\", cptpack.toroot(name))\13\n\9\9if filesystem.exists(cptpack.toroot(name)) then\13\n\9\9\9error(\"File already exists!\")\13\n\9\9end\13\n\9\9cyan.makeParentDirectory(cptpack.toroot(name))\13\n\9\9cyan.writeall(cptpack.toroot(name), data)\13\n\9end\13\nend\13\n\13\nfunction cptpack.makepkg(dir, verifier) -- Ignores root\13\n\9dir = filesystem.concat(shell.getWorkingDirectory(), dir)\13\n\9local loaded, err = loadfile(filesystem.concat(dir, \"PACKBUILD\"))\13\n\9if not loaded then\13\n\9\9error(\"Cannot load PACKBUILD: \" .. err)\13\n\9end\13\n\9local config = loaded(dir, fileout)\13\n\9if verifier and verifier(config) then -- Skip build.\13\n\9\9return nil\13\n\9end\13\n\9local pack = config.package or {}\13\n\9if not pack.contents then pack.contents = {} end\13\n\9for target, source in pairs(config.include or {}) do\13\n\9\9if source:sub(1, 1) == \"/\" then\13\n\9\9\9pack.contents[target] = cyan.readall(source)\13\n\9\9else\13\n\9\9\9pack.contents[target] = cyan.readall(filesystem.concat(dir, source))\13\n\9\9end\13\n\9end\13\n\9for _, field in ipairs({\"name\", \"version\", \"depends\", \"conflicts\"}) do\13\n\9\9if config[field] then\13\n\9\9\9assert(pack[field] == nil)\13\n\9\9\9pack[field] = config[field]\13\n\9\9end\13\n\9\9assert(pack[field], \"No package \" .. field .. \"!\")\13\n\9end\13\n\9return pack\13\nend\13\n\13\nfunction cptpack.buildpkg(dir, fileout) -- Ignores root\13\n\9cyan.writeserialized(fileout, cptpack.makepkg(dir))\13\nend\13\n\13\nfunction cptpack.makeindex()\13\n\9return {}\13\nend\13\n\13\nfunction cptpack.packhash(textual)\13\n\9return crypto.sha256(textual)\13\nend\13\n\13\nfunction cptpack.hasindex(index, name)\13\n\9return index[name] ~= nil\13\nend\13\n\13\nfunction cptpack.removeindex(index, name)\13\n\9index[name] = nil\13\nend\13\n\13\nfunction cptpack.listindex(index)\13\n\9return pairs(index)\13\nend\13\n\13\nfunction cptpack.addindex(index, pkg, hash, source)\13\n\9local ref = pkg.name .. \"-\" .. pkg.version\13\n\9if index[ref] then\13\n\9\9error(\"Ref already found in index: \" .. ref)\13\n\9end\13\n\9assert(hash ~= nil)\13\n\9index[ref] = {source=source, name=pkg.name, version=pkg.version, depends=pkg.depends, conflicts=pkg.conflicts, listing=cyan.keylist(pkg.contents), hash=hash}\13\nend\13\n\13\nfunction cptpack.gethash(index, name)\13\n\9return index[name].hash\13\nend\13\n\13\nfunction cptpack.listingfromindex(index, name)\13\n\9local pkg = index[name]\13\n\9assert(pkg, \"Package not found in index: \" .. name)\13\n\9return pkg.listing\13\nend\13\n\13\nfunction cptpack.dependsfromindex(index, name)\13\n\9return index[name].depends\13\nend\13\n\13\nfunction cptpack.conflictsfromindex(index, name)\13\n\9return index[name].conflicts\13\nend\13\n\13\nfunction cptpack.setsources(index, sourcename)\13\n\9for k, v in pairs(index) do\13\n\9\9v.source = sourcename\13\n\9end\13\nend\13\n\13\nfunction cptpack.getsource(index, name)\13\n\9local pkg = index[name]\13\n\9assert(pkg, \"Package not found in index: \" .. name)\13\n\9return pkg.source\13\nend\13\n\13\nfunction cptpack.mergeindex(target, source)\13\n\9for k, v in pairs(source) do\13\n\9\9if target[k] then\13\n\9\9\9error(\"Cannot merge indexes: duplicate on \" .. k)\13\n\9\9end\13\n\9\9target[k] = v\13\n\9end\13\nend\13\n\13\nfunction cptpack.mergesingleindex(target, source, name)\13\n\9if target[name] then\13\n\9\9error(\"Cannot merge indexes: duplicate on \" .. name)\13\n\9elseif not source[name] then\13\n\9\9error(\"Cannot merge indexes: not found: \" .. name)\13\n\9end\13\n\9target[name] = source[name]\13\nend\13\n\13\nfunction cptpack.writeindex(target, index)\13\n\9cyan.writeserialized(target, index)\13\nend\13\n\13\nfunction cptpack.readindex(source)\13\n\9return cyan.readserialized(source)\13\nend\13\n\13\nfunction cptpack.readremoteindex(url)\13\n\9return cyan.readremoteserialized(url)\13\nend\13\n\13\nfunction cptpack.countindex(index)\13\n\9local count = 0\13\n\9for k, v in pairs(index) do\13\n\9\9count = count + 1\13\n\9end\13\n\9return count\13\nend\13\n\13\nfunction cptpack.dumpindex(index)\13\n\9print(table.unpack(cyan.keylist(index)))\13\nend\13\n\13\nreturn cptpack",["/usr/bin/cpt.lua"]="local args = {...}\13\n\13\nif #args == 0 or args[1] == \"help\" then\13\n\9if #args > 1 then\13\n\9\9error(\"Too many parameters to help.\")\13\n\9end\13\n\9print(\"Usage: cpt (install|remove|update) PACKAGES...\")\13\n\9print(\"Usage: cpt (sync|flush|upgrade|init|init-installation|dump|force-lock|force-unlock|attempt-resume)\")\13\n\9print(\"Usage: cpt build DIR FILEOUT\")\13\n\9print(\"Usage: cpt no-preresolve (line from above)\")\13\n\9print(\"Usage: cpt reroot ROOT (line from above)\")\13\n\9return\13\nend\13\n\13\nlocal cptlock = require(\"cptlock\")\13\nlocal cptpack = require(\"cptpack\")\13\n\13\nlocal cmd = table.remove(args, 1)\13\n\13\nlocal root = \"/\"\13\n\13\nlocal preresolve = true\13\n\13\nif cmd == \"reroot\" then\13\n\9rootmod = table.remove(args, 1)\13\n\9cmd = table.remove(args, 1)\13\n\9if not cmd then\13\n\9\9print(\"Path and command expected after reroot.\")\13\n\9\9return\13\n\9end\13\nend\13\nif cmd == \"no-preresolve\" then\13\n\9cmd = table.remove(args, 1)\13\n\9if not cmd then\13\n\9\9print(\"Path and command expected after no-preresolve.\")\13\n\9\9return\13\n\9end\13\n\9preresolve = false\13\nend\13\n\13\nif cmd == \"force-lock\" then\13\n\9if #args > 0 then\13\n\9\9error(\"Too many parameters to force-lock.\")\13\n\9end\13\n\9cptlock.lock()\13\nelseif cmd == \"force-unlock\" then\13\n\9if #args > 0 then\13\n\9\9error(\"Too many parameters to force-unlock.\")\13\n\9end\13\n\9cptlock.unlock()\13\nelseif cmd == \"build\" then\13\n\9if #args ~= 2 then\13\n\9\9error(\"Wrong number of parameters to build.\")\13\n\9end\13\n\9require(\"cptpack\").buildpkg(args[1], args[2])\13\nelse\13\n\9function main()\13\n\9\9if cmd == \"sync\" then\13\n\9\9\9if #args > 0 then\13\n\9\9\9\9error(\"Too many parameters to sync.\")\13\n\9\9\9end\13\n\9\9\9require(\"cptcache\").synchronizerepos()\13\n\9\9elseif cmd == \"strap\" then\13\n\9\9\9local cptcache = require(\"cptcache\")\13\n\9\9\9cptcache.initcache()\13\n\9\9\9cptcache.synchronizerepos(true)\13\n\9\9\9local context = require(\"cptinstall\").strap()\13\n\9\9\9context:resolve()\13\n\9\9\9if #args == 0 then\13\n\9\9\9\9context:add(\"group_base\")\13\n\9\9\9else\13\n\9\9\9\9for i, packname in ipairs(args) do\13\n\9\9\9\9\9context:add(packname)\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9\9context:resolve(true)\13\n\9\9\9context:getpackages()\13\n\9\9\9context:dump()\13\n\9\9\9context:prompt()\13\n\9\9\9context:save(true)\13\n\9\9\9context:apply()\13\n\9\9\9context:save()\13\n\9\9elseif cmd == \"init\" then\13\n\9\9\9if #args > 0 then\13\n\9\9\9\9error(\"Too many parameters to init.\")\13\n\9\9\9end\13\n\9\9\9require(\"cptcache\").initcache()\13\n\9\9elseif cmd == \"init-installation\" then\13\n\9\9\9if #args > 0 then\13\n\9\9\9\9error(\"Too many parameters to init-installation.\")\13\n\9\9\9end\13\n\9\9\9local context = require(\"cptinstall\").strap()\13\n\9\9\9if preresolve then\13\n\9\9\9\9context:resolve()\13\n\9\9\9end\13\n\9\9\9context:resolve()\13\n\9\9\9context:getpackages()\13\n\9\9\9context:dump()\13\n\9\9\9context:prompt()\13\n\9\9\9context:save(true)\13\n\9\9\9context:apply()\13\n\9\9\9context:save()\13\n\9\9elseif cmd == \"flush\" then\13\n\9\9\9if #args > 0 then\13\n\9\9\9\9error(\"Too many parameters to flush.\")\13\n\9\9\9end\13\n\9\9\9require(\"cptcache\").flushcache()\13\n\9\9elseif cmd == \"upgrade\" then\13\n\9\9\9if #args > 0 then\13\n\9\9\9\9error(\"Too many parameters to upgrade.\")\13\n\9\9\9end\13\n\9\9\9local cptinstall = require(\"cptinstall\")\13\n\9\9\9local context = cptinstall.begin()\13\n\9\9\9if preresolve then\13\n\9\9\9\9context:resolve()\13\n\9\9\9end\13\n\9\9\9context:upgrade()\13\n\9\9\9context:resolve()\13\n\9\9\9context:getpackages()\13\n\9\9\9context:dump()\13\n\9\9\9if context:anyactions() then\13\n\9\9\9\9context:prompt()\13\n\9\9\9\9context:save(true)\13\n\9\9\9\9context:apply()\13\n\9\9\9\9context:save()\13\n\9\9\9else\13\n\9\9\9\9print(\"Nothing to do.\")\13\n\9\9\9end\13\n\9\9elseif cmd == \"dump\" then\13\n\9\9\9if #args > 0 then\13\n\9\9\9\9error(\"Too many parameters to dump.\")\13\n\9\9\9end\13\n\9\9\9require(\"cptcache\").dumpcache()\13\n\9\9\9local context = require(\"cptinstall\").begin()\13\n\9\9\9context:resolve()\13\n\9\9\9context:dump()\13\n\9\9elseif cmd == \"install\" then\13\n\9\9\9if #args <= 0 then\13\n\9\9\9\9error(\"Too few parameters to install.\")\13\n\9\9\9end\13\n\9\9\9local cptinstall = require(\"cptinstall\")\13\n\9\9\9local context = cptinstall.begin()\13\n\9\9\9if preresolve then\13\n\9\9\9\9context:resolve()\13\n\9\9\9end\13\n\9\9\9for i, packname in ipairs(args) do\13\n\9\9\9\9context:add(packname)\13\n\9\9\9end\13\n\9\9\9context:resolve(true)\13\n\9\9\9context:getpackages()\13\n\9\9\9context:dump()\13\n\9\9\9if context:anyactions() then\13\n\9\9\9\9context:prompt()\13\n\9\9\9\9context:save(true)\13\n\9\9\9\9context:apply()\13\n\9\9\9\9context:save()\13\n\9\9\9else\13\n\9\9\9\9print(\"Nothing to do.\")\13\n\9\9\9end\13\n\9\9elseif cmd == \"resume\" then\13\n\9\9\9if #args > 0 then\13\n\9\9\9\9error(\"Too many parameters to resume.\")\13\n\9\9\9end\13\n\9\9\9local cptinstall = require(\"cptinstall\")\13\n\9\9\9local context = cptinstall.resume()\13\n\9\9\9context:resolve()\13\n\9\9\9context:getpackages()\13\n\9\9\9context:dump()\13\n\9\9\9context:prompt()\13\n\9\9\9context:apply()\13\n\9\9\9context:save()\13\n\9\9elseif cmd == \"remove\" then\13\n\9\9\9if #args <= 0 then\13\n\9\9\9\9error(\"Too few parameters to remove.\")\13\n\9\9\9end\13\n\9\9\9local cptinstall = require(\"cptinstall\")\13\n\9\9\9local context = cptinstall.begin()\13\n\9\9\9if preresolve then\13\n\9\9\9\9context:resolve()\13\n\9\9\9end\13\n\9\9\9for i, packname in ipairs(args) do\13\n\9\9\9\9context:remove(packname)\13\n\9\9\9end\13\n\9\9\9context:resolve()\13\n\9\9\9context:getpackages()\13\n\9\9\9context:dump()\13\n\9\9\9if context:anyactions() then\13\n\9\9\9\9context:prompt()\13\n\9\9\9\9context:save(true)\13\n\9\9\9\9context:apply()\13\n\9\9\9\9context:save()\13\n\9\9\9else\13\n\9\9\9\9print(\"Nothing to do.\")\13\n\9\9\9end\13\n\9\9elseif cmd == \"update\" then\13\n\9\9\9if #args <= 0 then\13\n\9\9\9\9error(\"Too few parameters to update.\")\13\n\9\9\9end\13\n\9\9\9local cptinstall = require(\"cptinstall\")\13\n\9\9\9local context = cptinstall.begin()\13\n\9\9\9if preresolve then\13\n\9\9\9\9context:resolve()\13\n\9\9\9end\13\n\9\9\9for i, packname in ipairs(args) do\13\n\9\9\9\9context:remove(packname)\13\n\9\9\9\9context:add(packname)\13\n\9\9\9end\13\n\9\9\9context:resolve()\13\n\9\9\9context:getpackages()\13\n\9\9\9context:dump()\13\n\9\9\9if context:anyactions() then\13\n\9\9\9\9context:prompt()\13\n\9\9\9\9context:save(true)\13\n\9\9\9\9context:apply()\13\n\9\9\9\9context:save()\13\n\9\9\9else\13\n\9\9\9\9print(\"Nothing to do.\")\13\n\9\9\9end\13\n\9\9else\13\n\9\9\9error(\"Unsupported command: \" .. cmd)\13\n\9\9end\13\n\9end\13\n\13\n\9cptlock.lock()\13\n\9local opr = cptpack.root\13\n\9if rootmod then\13\n\9\9cptpack.root = rootmod\13\n\9end\13\n\9local success, err = pcall(main)\13\n\9if rootmod then\13\n\9\9cptpack.root = opr\13\n\9end\13\n\9cptlock.unlock()\13\n\9\13\n\9if not success then error(err) end\13\nend",["/usr/lib/cptinstall.lua"]="local filesystem = require(\"filesystem\")\13\nlocal cyan = require(\"cyan\")\13\nlocal cptcache = require(\"cptcache\")\13\nlocal cptpack = require(\"cptpack\")\13\nlocal term = require(\"term\")\13\n\13\nlocal cptinstall = {}\13\nlocal context = {}\13\n\13\ncptinstall.datadir = \"/var/lib/cpt/\"\13\n\13\nfunction cptinstall.loadstatus()\13\n\9return cyan.readserialized(cptpack.toroot(filesystem.concat(cptinstall.datadir, \"status\")))\13\nend\13\n\13\nfunction cptinstall.resume()\13\n\9return cptinstall.begin(nil, true)\13\nend\13\n\13\nfunction cptinstall.strap()\13\n\9return cptinstall.begin({installed={}})\13\nend\13\n\13\nfunction cptinstall.begin(base, resume)\13\n\9local out = cyan.instance(context, base or cptinstall.loadstatus())\13\n\9out.resolved = false\13\n\9out.haspackages = false\13\n\9out.localindex = cptcache.loadlocalindex()\13\n\9out.remoteindex = cptcache.loadremoteindex()\13\n\9if resume then\13\n\9\9if not out.intermediate then\13\n\9\9\9error(\"Installation set is not in an intermediate state! Cannot continue transaction.\")\13\n\9\9end\13\n\9else\13\n\9\9if out.intermediate then\13\n\9\9\9error(\"Installation set is in an intermediate state! Cannot begin transaction.\")\13\n\9\9end\13\n\9\9out.deltaadd = {}\13\n\9\9out.deltadel = {}\13\n\9end\13\n\9return out\13\nend\13\n\13\nfunction context:save(intermediate)\13\n\9assert(self.resolved)\13\n\9if not filesystem.isDirectory(cptpack.toroot(cptinstall.datadir)) then\13\n\9\9local success, err = filesystem.makeDirectory(cptpack.toroot(cptinstall.datadir))\13\n\9\9if not success then\13\n\9\9\9error(\"Cannot create directory \" .. cptpack.toroot(cptinstall.datadir) .. \": \" .. err)\13\n\9\9end\13\n\9end\13\n\9self.intermediate = intermediate\13\n\9local lindex = self.localindex\13\n\9local rindex = self.remoteindex\13\n\9self.localindex = nil\13\n\9self.remoteindex = nil\13\n\9cyan.writeinstance(cptpack.toroot(filesystem.concat(cptinstall.datadir, \"status\")), self)\13\n\9self.localindex = lindex\13\n\9self.remoteindex = rindex\13\nend\13\n\13\nfunction context:getpackages()\13\n\9if #self.deltaadd ~= 0 then\13\n\9\9cptcache.getpackages(self.deltaadd)\13\n\9end\13\n\9self.haspackages = true\13\nend\13\n\13\nfunction context:anyactions()\13\n\9return #self.deltaadd ~= 0 or #self.deltadel ~= 0\13\nend\13\n\13\nfunction context:apply()\13\n\9assert(self.resolved and self.haspackages)\13\n\9print(\"About to apply\", #self.deltadel, \"deletions and\", #self.deltaadd, \"additions.\")\13\n\9for i, name in ipairs(self.deltadel) do\13\n\9\9cptpack.uninstall(self.localindex, name)\13\n\9end\13\n\9for i, name in ipairs(self.deltaadd) do\13\n\9\9cptpack.install(name, cptcache.getpath(name))\13\n\9end\13\n\9print(\"Applied\", #self.deltadel + #self.deltaadd, \"changes.\")\13\nend\13\n\13\nfunction context:resolve(rectify)\13\n\9if self.resolved then return end\13\n\9local includedfull = cyan.valueset(self.installed)\13\n\9local included = {}\13\n\9for i, namever in ipairs(self.installed) do\13\n\9\9local name, version = cyan.cut(namever, \"-\", \"Bad name&version string: \" .. namever)\13\n\9\9if included[name] then\13\n\9\9\9error(\"Multiple versions of \" .. name .. \" are selected: \" .. version .. \" and \" .. included[name])\13\n\9\9end\13\n\9\9included[name] = version\13\n\9end\13\n\9local rectification = {}\13\n\9local anyrectification = false\13\n\9for i, name in ipairs(self.installed) do\13\n\9\9local depends, conflicts\13\n\9\9if cptpack.hasindex(self.localindex, name) then\13\n\9\9\9depends = cptpack.dependsfromindex(self.localindex, name)\13\n\9\9\9conflicts = cptpack.conflictsfromindex(self.localindex, name)\13\n\9\9elseif cptpack.hasindex(self.remoteindex, name) then\13\n\9\9\9depends = cptpack.dependsfromindex(self.remoteindex, name)\13\n\9\9\9conflicts = cptpack.conflictsfromindex(self.remoteindex, name)\13\n\9\9else\13\n\9\9\9error(\"Cannot find package \" .. name .. \" in any index!\")\13\n\9\9end\13\n\9\9for i, needed in ipairs(depends) do\13\n\9\9\9if not included[needed] and not includedfull[needed] then\13\n\9\9\9\9if rectify then\13\n\9\9\9\9\9rectification[needed] = true\13\n\9\9\9\9\9anyrectification = true\13\n\9\9\9\9else\13\n\9\9\9\9\9error(\"Dependency failed: \" .. name .. \" requires \" .. needed .. \" but it is not selected.\")\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9end\13\n\9\9for i, conflicted in ipairs(conflicts) do\13\n\9\9\9if included[conflicted] or includedfull[conflicted] then\13\n\9\9\9\9error(\"Conflict detected: \" .. name .. \" conflicts with \" .. conflicted .. \" and both are selected.\")\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\9if anyrectification then\13\n\9\9for name, _ in pairs(rectification) do\13\n\9\9\9print(\"Rectifier: adding\", name)\13\n\9\9\9self:add(name)\13\n\9\9end\13\n\9\9self:resolve(true)\13\n\9\9return\13\n\9end\13\n\9self.resolved = true\13\nend\13\n\13\nfunction context:upgrade()\13\n\9assert(self.resolved)\13\n\9local toremove = {}\13\n\9for i, namever in ipairs(self.installed) do\13\n\9\9local name, ver = cyan.cut(namever, \"-\", \"Bad name&version string: \" .. namever)\13\n\9\9local over = ver\13\n\9\9for k, v in cptpack.listindex(self.remoteindex) do\13\n\9\9\9local fname, fver = cyan.cut(k, \"-\", \"Bad name&version: \" .. k)\13\n\9\9\9if fname == name and ((not ver) or cptpack.compareversion(fver, ver) > 0) then\13\n\9\9\9\9ver = fver\13\n\9\9\9end\13\n\9\9end\13\n\9\9for k, v in cptpack.listindex(self.localindex) do\13\n\9\9\9local fname, fver = cyan.cut(k, \"-\", \"Bad name&version: \" .. k)\13\n\9\9\9if fname == name and ((not ver) or cptpack.compareversion(fver, ver) > 0) then\13\n\9\9\9\9ver = fver\13\n\9\9\9end\13\n\9\9end\13\n\9\9namever = name .. \"-\" .. ver\13\n\9\9if over ~= ver then\13\n\9\9\9self.resolved = false\13\n\9\9\9self.haspackages = false\13\n\9\9\9table.insert(toremove, i)\13\n\9\9\9table.insert(self.deltaadd, namever)\13\n\9\9\9table.insert(self.installed, namever)\13\n\9\9\9print(\"Found upgrade for \" .. name .. \" from \" .. over .. \" to \" .. ver)\13\n\9\9end\13\n\9end\13\n\9for _, i in ipairs(toremove) do\13\n\9\9table.insert(self.deltadel, self.installed[i])\13\n\9\9table.remove(self.installed, i)\13\n\9end\13\n\9print(\"Found\", #toremove, \"upgrades.\")\13\nend\13\n\13\nfunction context:add(namever)\13\n\9local name, ver = cyan.cut(namever, \"-\")\13\n\9if not ver then\13\n\9\9for k, v in cptpack.listindex(self.remoteindex) do\13\n\9\9\9local fname, fver = cyan.cut(k, \"-\", \"Bad name&version: \" .. k)\13\n\9\9\9if fname == name and ((not ver) or cptpack.compareversion(fver, ver) > 0) then\13\n\9\9\9\9ver = fver\13\n\9\9\9end\13\n\9\9end\13\n\9\9for k, v in cptpack.listindex(self.localindex) do\13\n\9\9\9local fname, fver = cyan.cut(k, \"-\", \"Bad name&version: \" .. k)\13\n\9\9\9if fname == name and ((not ver) or cptpack.compareversion(fver, ver) > 0) then\13\n\9\9\9\9ver = fver\13\n\9\9\9end\13\n\9\9end\13\n\9\9if not ver then\13\n\9\9\9error(\"Cannot find any package for: \" .. name)\13\n\9\9end\13\n\9\9namever = name .. \"-\" .. ver\13\n\9end\13\n\9for i, found in ipairs(self.installed) do\13\n\9\9if found == namever then\13\n\9\9\9error(\"Already selected: \" .. namever)\13\n\9\9end\13\n\9end\13\n\9if not cptpack.hasindex(self.remoteindex, namever) and not cptpack.hasindex(self.localindex, namever) then\13\n\9\9error(\"Package not in index: \" .. namever)\13\n\9end\13\n\9self.resolved = false\13\n\9self.haspackages = false\13\n\9table.insert(self.installed, namever)\13\n\9table.insert(self.deltaadd, namever)\13\nend\13\n\13\nfunction context:remove(name)\13\n\9for i, namever in ipairs(self.installed) do\13\n\9\9local lname, lver = cyan.cut(namever, \"-\")\13\n\9\9if name == lname or name == namever then\13\n\9\9\9self.resolved = false\13\n\9\9\9table.remove(self.installed, i)\13\n\9\9\9table.insert(self.deltadel, namever)\13\n\9\9\9return\13\n\9\9end\13\n\9end\13\n\9error(\"Package not installed: \" .. name)\13\nend\13\n\13\nfunction context:dump()\13\n\9print(\"Packages installed:\", #self.installed)\13\n\9print(table.unpack(self.installed))\13\n\9print(\"Packages in index:\", cptpack.countindex(self.localindex))\13\n\9cptpack.dumpindex(self.localindex) -- TODO: Some way to dump complete info about a package.\13\n\9print(\"Deltas:\", #self.deltadel + #self.deltaadd)\13\n\9for i, v in ipairs(self.deltadel) do\13\n\9\9print(\"Remove package\", v)\13\n\9end\13\n\9for i, v in ipairs(self.deltaadd) do\13\n\9\9print(\"Add package\", v)\13\n\9end\13\nend\13\n\13\nfunction context:prompt()\13\n\9term.write(\"Continue? (y/n) \")\13\n\9local line = term.read()\13\n\9if #line == 0 or (line:sub(1, 1) ~= \"y\" and line:sub(1, 1) ~= \"Y\") then\13\n\9\9error(\"Aborting.\")\13\n\9end\13\nend\13\n\13\nreturn cptinstall\13\n"},conflicts={},version="0.3.15"}