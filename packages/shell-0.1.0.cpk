{version="0.1.0",name="shell",depends={"init","libprocess"},contents={["/usr/man/unalias"]="NAME\13\n  unalias - removes aliases for programs\13\n\13\nSYNOPSIS\13\n  unalias name\13\n\13\nDESCRIPTION\13\n  Allows removal of aliases created with the `alias` command.\13\n\13\nEXAMPLES\13\n  unalias dir\13\n    Removes the `dir` alias (usually an alias for `ls`).",["/bin/unalias.lua"]="local shell = require(\"shell\")\13\n\13\nlocal args = shell.parse(...)\13\nif #args < 1 then\13\n  io.write(\"Usage: unalias <name>\")\13\n  return\13\nend\13\n\13\nlocal result = shell.getAlias(args[1])\13\nif not result then\13\n  io.stderr:write(\"no such alias\")\13\nelse\13\n  shell.setAlias(args[1], nil)\13\n  io.write(\"alias removed: \" .. args[1] .. \" -> \" .. result)\13\nend",["/bin/alias.lua"]="local shell = require(\"shell\")\13\n\13\nlocal args = shell.parse(...)\13\n\13\nif #args == 0 then\13\n  for name, value in shell.aliases() do\13\n    io.write(name .. \" \" .. value .. \"\\n\")\13\n  end\13\nelseif #args == 1 then\13\n  local value = shell.getAlias(args[1])\13\n  if value then\13\n    io.write(value)\13\n  else\13\n    io.stderr:write(\"no such alias\")\13\n  end\13\nelse\13\n  shell.setAlias(args[1], args[2])\13\n  io.write(\"alias created: \" .. args[1] .. \" -> \" .. args[2])\13\nend",["/bin/sh.lua"]="local component = require(\"component\")\13\nlocal computer = require(\"computer\")\13\nlocal event = require(\"event\")\13\nlocal fs = require(\"filesystem\")\13\nlocal process = require(\"process\")\13\nlocal shell = require(\"shell\")\13\nlocal term = require(\"term\")\13\nlocal text = require(\"text\")\13\n\13\nlocal function expand(value)\13\n  local result = value:gsub(\"%$(%w+)\", os.getenv):gsub(\"%$%b{}\",\13\n    function(match) return os.getenv(expand(match:sub(3, -2))) or match end)\13\n  return result\13\nend\13\n\13\nlocal function glob(value)\13\n  if not value:find(\"*\", 1, true) and not value:find(\"?\", 1, true) then\13\n    -- Nothing to do here.\13\n    return {expand(value)}\13\n  end\13\n  local segments = fs.segments(value)\13\n  local paths = {value:sub(1, 1) == \"/\" and \"/\" or shell.getWorkingDirectory()}\13\n  for i, segment in ipairs(segments) do\13\n    local nextPaths = {}\13\n    local pattern = segment:gsub(\"*\", \".*\"):gsub(\"?\", \".\")\13\n    if pattern == segment then\13\n      -- Nothing to do, concatenate as-is.\13\n      for _, path in ipairs(paths) do\13\n        table.insert(nextPaths, fs.concat(path, segment))\13\n      end\13\n    else\13\n      pattern = \"^(\" .. pattern .. \")/?$\"\13\n      for _, path in ipairs(paths) do\13\n        for file in fs.list(path) do\13\n          if file:match(pattern) then\13\n            table.insert(nextPaths, fs.concat(path, file))\13\n          end\13\n        end\13\n      end\13\n      if #nextPaths == 0 then\13\n        error(\"no matches found: \" .. segment)\13\n      end\13\n    end\13\n    paths = nextPaths\13\n  end\13\n  for i, path in ipairs(paths) do\13\n    paths[i] = expand(path)\13\n  end\13\n  return paths\13\nend\13\n\13\nlocal function evaluate(value)\13\n  local init, results = 1, {\"\"}\13\n  repeat\13\n    local match = value:match(\"^%b''\", init)\13\n    if match then -- single quoted string. no variable expansion.\13\n      match = match:sub(2, -2)\13\n      init = init + 2\13\n      for i, result in ipairs(results) do\13\n        results[i] = result .. match\13\n      end\13\n    else\13\n      match = value:match('^%b\"\"', init)\13\n      if match then -- double quoted string.\13\n        match = match:sub(2, -2)\13\n        init = init + 2\13\n      else\13\n        -- plaintext?\13\n        match = value:match(\"^([^']+)%b''\", init)\13\n        if not match then -- unmatched single quote.\13\n          match = value:match('^([^\"]+)%b\"\"', init)\13\n          if not match then -- unmatched double quote.\13\n            match = value:sub(init)\13\n          end\13\n        end\13\n      end\13\n      local newResults = {}\13\n      for _, globbed in ipairs(glob(match)) do\13\n        for i, result in ipairs(results) do\13\n          table.insert(newResults, result .. globbed)\13\n        end\13\n      end\13\n      results = newResults\13\n    end\13\n    init = init + #match\13\n  until init > #value\13\n  return results\13\nend\13\n\13\nlocal function execute(env, command, ...)\13\n  local parts, reason = text.tokenize(command)\13\n  if not parts then\13\n    return false, reason\13\n  elseif #parts == 0 then\13\n    return true\13\n  end\13\n  local program, args = shell.resolveAlias(parts[1], table.pack(select(2, table.unpack(parts))))\13\n  local eargs = {}\13\n  program = evaluate(program)\13\n  for i = 2, #program do\13\n    table.insert(eargs, program[i])\13\n  end\13\n  local program, reason = shell.resolve(program[1], \"lua\")\13\n  if not program then\13\n    return false, reason\13\n  end\13\n  for i = 1, #args do\13\n    for _, arg in ipairs(evaluate(args[i])) do\13\n      table.insert(eargs, arg)\13\n    end\13\n  end\13\n  args = eargs\13\n  for _, arg in ipairs(table.pack(...)) do\13\n    table.insert(args, arg)\13\n  end\13\n  table.insert(args, 1, true)\13\n  args.n = #args\13\n  local thread, reason = process.load(program, env, nil, command)\13\n  if not thread then\13\n    return false, reason\13\n  end \13\n  os.setenv(\"_\", program)\13\n  local result = nil\13\n  -- Emulate CC behavior by making yields a filtered event.pull()\13\n  while args[1] and coroutine.status(thread) ~= \"dead\" do\13\n    result = table.pack(coroutine.resume(thread, table.unpack(args, 2, args.n)))\13\n    if coroutine.status(thread) ~= \"dead\" then\13\n      if type(result[2]) == \"string\" then\13\n        args = table.pack(pcall(event.pull, table.unpack(result, 2, result.n)))\13\n      else\13\n        args = {true, n=1}\13\n      end\13\n    end\13\n  end\13\n  if not args[1] then\13\n    return false, args[2]\13\n  end\13\n  if not result[1] and type(result[2]) == \"table\" and result[2].reason == \"terminated\" then\13\n    if result[2].code then\13\n      return true\13\n    else\13\n      return false, \"terminated\"\13\n    end\13\n  end\13\n  return table.unpack(result, 1, result.n)\13\nend\13\n\13\nlocal args, options = shell.parse(...)\13\nlocal history = {}\13\n\13\nif #args == 0 and (io.input() == io.stdin or options.i) and not options.c then\13\n  -- interactive shell.\13\n  while true do\13\n    if not term.isAvailable() then -- don't clear unless we lost the term\13\n      while not term.isAvailable() do\13\n        event.pull(\"term_available\")\13\n      end\13\n      term.clear()\13\n    end\13\n    while term.isAvailable() do\13\n      local foreground = component.gpu.setForeground(0xFF0000)\13\n      term.write(expand(os.getenv(\"PS1\") or \"$ \"))\13\n      component.gpu.setForeground(foreground)\13\n      local command = term.read(history)\13\n      if not command then\13\n        term.write(\"exit\\n\")\13\n        return -- eof\13\n      end\13\n      while #history > (tonumber(os.getenv(\"HISTSIZE\")) or 10) do\13\n        table.remove(history, 1)\13\n      end\13\n      command = text.trim(command)\13\n      if command == \"exit\" then\13\n        return\13\n      elseif command ~= \"\" then\13\n        local result, reason = os.execute(command)\13\n        if term.getCursor() > 1 then\13\n          term.write(\"\\n\")\13\n        end\13\n        if not result then\13\n          io.stderr:write((tostring(reason) or \"unknown error\").. \"\\n\")\13\n        end\13\n      end\13\n    end\13\n  end\13\nelse\13\n  -- execute command.\13\n  local result = table.pack(execute(...))\13\n  if not result[1] then\13\n    error(result[2], 0)\13\n  end\13\n  return table.unpack(result, 2)\13\nend\13\n",["/usr/man/alias"]="NAME\13\n  alias - displays and manipulates aliases for programs\13\n\13\nSYNOPSIS\13\n  alias\13\n  alias name\13\n  alias name value\13\n\13\nDESCRIPTION\13\n  `alias` allows listing and editing aliases for programs. An alias is an alternative name that can be used to start a program. A program can have multiple aliases. Aliases can also contain parameters and options to pass to the actual program. An alias can also, in turn, have aliases.\13\n\13\nEXAMPLES\13\n  alias\13\n    Displays the list of all current aliases.\13\n\13\n  alias name\13\n    Displays the value the specified alias, i.e. what the specified alias stands for.\13\n\13\n  alias name value\13\n    Sets the value of the alias with the specified name.",["/bin/unset.lua"]="local args = {...}\13\n\13\nif #args < 1 then\13\n  print(\"Usage: unset <varname>[ <varname2> [...]]\")\13\nelse\13\n  for _, k in ipairs(args) do\13\n    os.setenv(k, nil)\13\n  end\13\nend",["/bin/set.lua"]="local args = {...}\13\n\13\nif #args < 1 then\13\n  for k,v in pairs(os.getenv()) do\13\n    io.write(k .. \"='\" .. string.gsub(v, \"'\", [['\"'\"']]) .. \"'\\n\")\13\n  end\13\nelse\13\n  local count = 0 \13\n  for _, expr in ipairs(args) do\13\n    local k, v = string.match(expr, \"(.-)=(.*)\")\13\n    if v then\13\n      os.setenv(k, v)\13\n    else\13\n      if count == 0 then\13\n        for i = 1, os.getenv('#') do\13\n          os.setenv(i, nil)\13\n        end\13\n      end\13\n      count = count + 1\13\n      os.setenv(count, expr)\13\n    end\13\n  end\13\nend\13\n",["/bin/cd.lua"]="local shell = require(\"shell\")\13\n\13\nlocal args = shell.parse(...)\13\nif #args == 0 then\13\n  io.write(\"Usage: cd <dirname>\")\13\nelse\13\n  local result, reason = shell.setWorkingDirectory(shell.resolve(args[1]))\13\n  if not result then\13\n    io.stderr:write(reason)\13\n  end\13\nend\13\n",["/usr/man/sh"]="NAME\13\n  sh - command interpreter (shell)\13\n\13\nSYNOPSIS\13\n  sh\13\n\13\nDESCRIPTION\13\n  This is the basic, built-in standard shell of OpenOS. It provides very basic functionality compared to what real OS's shells can achieve, but does the job for getting started. To run a command, enter it and press enter. The first token in a command will usually be a program. Any additional parameters will be passed along to the program.\13\n\13\n  Arguments to programs can be quoted, to provide strings with multiple spaces in them, for example:\13\n    echo \"a   b\"\13\n  will print the string `a   b` to the screen. It is also possible to use single quotes (echo 'a b').\13\n\13\n  Single quotes also suppress variable expansion. Per default, expressions like `$NAME` and `${NAME}` are expanded using environment variables (also accessible via the `os.getenv` method).\13\n\13\n  Basic globbing is supported, i.e. '*' and '?' are expanded approriately. For example:\13\n    ls b?n/\13\n  will list all files in `/bin/` (and, if it exists `/ban` and so on).\13\n    cp /bin/* /usr/bin/\13\n  will copy all files from `/bin` to `/usr/bin`.\13\n\13\n  The shell also supports aliases, which can be created using `alias` and removed using `unalias` (or using the `shell` API). For example, `dir` is a standard alias for `ls`.\13\n\13\nEXAMPLES\13\n  sh\13\n    Starts a new shell.",["/usr/man/cd"]="NAME\13\n  cd - change the current working directory\13\n\13\nSYNOPSIS\13\n  cd path\13\n\13\nDESCRIPTION\13\n  `cd` allows changing the current working directory, i.e the directory based on which relative paths are resloved.\13\n\13\nEXAMPLES\13\n  cd a\13\n    Changes to directory `a` in the current working directory.\13\n\13\n  cd /bin\13\n    Changes to directory `/bin`, using the specified absolute path."},conflicts={"binaries-0.1"}}