{version="0.1.1",contents={["/bin/clear.lua"]="local term = require(\"term\")\13\n\13\nterm.clear()",["/bin/which.lua"]="local shell = require(\"shell\")\13\n\13\nlocal args = shell.parse(...)\13\nif #args == 0 then\13\n  io.write(\"Usage: which <program>\")\13\n  return\13\nend\13\n\13\nfor i = 1, #args do\13\n  local result, reason = shell.getAlias(args[i])\13\n  if result then\13\n    result = args[i] .. \": aliased to \" .. result\13\n  else\13\n    result, reason = shell.resolve(args[i], \"lua\")\13\n  end\13\n  if result then\13\n    io.write(result .. \"\\n\")\13\n  else\13\n    io.stderr:write(args[i] .. \": \" .. reason .. \"\\n\")\13\n  end\13\nend",["/usr/man/pwd"]="NAME\13\n  pwd - print name of current/working directory\13\n\13\nSYNOPSIS\13\n  pwd\13\n\13\nDESCRIPTION\13\n  `pwd` writes the name of the current working directory to the standard output.\13\n\13\nEXAMPLES\13\n  pwd\13\n    Write the current directory to the terminal.",["/usr/man/uptime"]="NAME\13\n  uptime - how long has the computer been running\13\n\13\nSYNOPSIS\13\n  uptime\13\n\13\nDESCRIPTION\13\n  Writes the time in real time hours, minutes and seconds the computer has been running to the standard output.\13\n\13\nEXAMPLES\13\n  uptime\13\n    Displays the time the computer has been running.",["/usr/man/clear"]="NAME\13\n  clear - clears the terminal\13\n\13\nSYNOPSIS\13\n  clear\13\n\13\nDESCRIPTION\13\n  Clears any text from the screen, using the current background and foreground (text) colors and resets the cursor position to (1, 1).\13\n\13\nEXAMPLES\13\n  clear\13\n    Clears the screen/",["/usr/man/mv"]="NAME\13\n  mv - move (rename) files\13\n\13\nSYNOPSIS\13\n  mv SOURCE DEST\13\n\13\nDESCRIPTION\13\n  Renames files - and folders, as long they remain on the same file system. Files that are 'renamed' to another file system will actually be copied, then deleted.\13\n\13\nOPTIONS\13\n  -f\13\n    do not prompt before overwriting\13\n\13\nEXAMPLES\13\n  mv a b\13\n    Renames file `a` to `b`.\13\n\13\n  mv /home/a /var/b\13\n    Moves file from `/home/a` to `/var/b`.",["/bin/ln.lua"]="local component = require(\"component\")\13\nlocal fs = require(\"filesystem\")\13\nlocal shell = require(\"shell\")\13\n\13\nlocal dirs = shell.parse(...)\13\nif #dirs == 0 then\13\n  io.write(\"Usage: ln <target> [<name>]\")\13\n  return\13\nend\13\n\13\nlocal target = shell.resolve(dirs[1])\13\nlocal linkpath\13\nif #dirs > 1 then\13\n  linkpath = shell.resolve(dirs[2])\13\nelse\13\n  linkpath = fs.concat(shell.getWorkingDirectory(), fs.name(target))\13\nend\13\n\13\nlocal result, reason = fs.link(target, linkpath)\13\nif not result then\13\n  io.stderr:write(reason)\13\nend",["/bin/df.lua"]="local fs = require(\"filesystem\")\13\nlocal shell = require(\"shell\")\13\nlocal text = require(\"text\")\13\n\13\nlocal args, options = shell.parse(...)\13\n\13\nlocal function formatSize(size)\13\n  if not options.h then\13\n    return tostring(size)\13\n  end\13\n  local sizes = {\"\", \"K\", \"M\", \"G\"}\13\n  local unit = 1\13\n  local power = options.si and 1000 or 1024\13\n  while size > power and unit < #sizes do\13\n    unit = unit + 1\13\n    size = size / power\13\n  end\13\n  return math.floor(size * 10) / 10 .. sizes[unit]\13\nend\13\n\13\nlocal mounts = {}\13\nif #args == 0 then\13\n  for proxy, path in fs.mounts() do\13\n    mounts[path] = proxy\13\n  end\13\nelse\13\n  for i = 1, #args do\13\n    local proxy, path = fs.get(args[i])\13\n    if not proxy then\13\n      io.stderr:write(args[i], \": no such file or directory\\n\")\13\n    else\13\n      mounts[path] = proxy\13\n    end\13\n  end\13\nend\13\n\13\nlocal result = {{\"Filesystem\", \"Used\", \"Available\", \"Use%\", \"Mounted on\"}}\13\nfor path, proxy in pairs(mounts) do\13\n  local label = proxy.getLabel() or proxy.address\13\n  local used, total = proxy.spaceUsed(), proxy.spaceTotal()\13\n  local available, percent\13\n  if total == math.huge then\13\n    used = used or \"N/A\"\13\n    available = \"unlimited\"\13\n    percent = \"0%\"\13\n  else\13\n    available = total - used\13\n    percent = used / total\13\n    if percent ~= percent then -- NaN\13\n      available = \"N/A\"\13\n      percent = \"N/A\"\13\n    else\13\n      percent = math.ceil(percent * 100) .. \"%\"\13\n    end\13\n  end\13\n  table.insert(result, {label, formatSize(used), formatSize(available), tostring(percent), path})\13\nend\13\n\13\nlocal m = {}\13\nfor _, row in ipairs(result) do\13\n  for col, value in ipairs(row) do\13\n    m[col] = math.max(m[col] or 1, value:len())\13\n  end\13\nend\13\n\13\nfor _, row in ipairs(result) do\13\n  for col, value in ipairs(row) do\13\n    io.write(text.padRight(value, m[col] + 2))\13\n  end\13\n  io.write(\"\\n\")\13\nend\13\n",["/bin/mv.lua"]="local fs = require(\"filesystem\")\13\nlocal shell = require(\"shell\")\13\n\13\nlocal args, options = shell.parse(...)\13\nif #args < 2 then\13\n  io.write(\"Usage: mv [-f] <from> <to>\\n\")\13\n  io.write(\" -f: overwrite file if it already exists.\")\13\n  return\13\nend\13\n\13\nlocal from = shell.resolve(args[1])\13\nlocal to = shell.resolve(args[2])\13\nif fs.isDirectory(to) then\13\n  to = to .. \"/\" .. fs.name(from)\13\nend\13\nif fs.exists(to) then\13\n  if not options.f then\13\n    io.stderr:write(\"target file exists\")\13\n  end\13\n  fs.remove(to)\13\nend\13\nlocal result, reason = os.rename(from, to)\13\nif not result then\13\n  io.stderr:write(reason or \"unknown error\")\13\nend\13\n",["/usr/man/cat"]="NAME\13\n  cat - concatenate files and print on the standard output\13\n\13\nSYNOPSIS\13\n  cat [FILE]...\13\n\13\nDESCRIPTION\13\n  `cat` allows concatenating files or standard input to standard output.\13\n\13\nEXAMPLES\13\n  cat\13\n    Copy standard input to standard output.\13\n\13\n  cat test.txt\13\n    Output contents of file test.txt.",["/bin/rm.lua"]="local shell = require(\"shell\")\13\n\13\nlocal args, options = shell.parse(...)\13\nif #args == 0 then\13\n  io.write(\"Usage: rm [-v] <filename1> [<filename2> [...]]\\n\")\13\n  io.write(\" -v: verbose output.\")\13\n  return\13\nend\13\n\13\nfor i = 1, #args do\13\n  local path = shell.resolve(args[i])\13\n  if not os.remove(path) then\13\n    io.stderr:write(path .. \": no such file, or permission denied\\n\")\13\n  end\13\n  if options.v then\13\n    io.write(\"removed '\" .. path .. \"'\\n\")\13\n  end\13\nend\13\n",["/usr/man/rm"]="NAME\13\n  rm - remove files or directories\13\n\13\nSYNOPSIS\13\n  rm FILE...\13\n\13\nDESCRIPTION\13\n  Removes all of the specified files, one by one. Can also be used to remove directories, mounts and symlinks.\13\n\13\nEXAMPLES\13\n  rm a\13\n    Deletes the file `a`.",["/bin/cat.lua"]="local shell = require(\"shell\")\13\n\13\nlocal args = shell.parse(...)\13\nif #args == 0 then\13\n  repeat\13\n    local read = io.read(\"*L\")\13\n    if read then\13\n      io.write(read)\13\n    end\13\n  until not read\13\nelse\13\n  for i = 1, #args do\13\n    local file, reason = io.open(shell.resolve(args[i]))\13\n    if not file then\13\n      io.stderr:write(reason)\13\n      return\13\n    end\13\n    repeat\13\n      local line = file:read(\"*L\")\13\n      if line then\13\n        io.write(line)\13\n      end\13\n    until not line\13\n  end\13\nend",["/usr/man/more"]="NAME\13\n  more - primitive file viewer\13\n\13\nSYNOPSIS\13\n  more FILE\13\n\13\nDESCRIPTION\13\n  `more` allows viewing the contents of a file one screenful at a time.\13\n\13\nEXAMPLES\13\n  more /home/a.txt\13\n    Displays the contents of file `/home/a.txt`",["/bin/cp.lua"]="local fs = require(\"filesystem\")\13\nlocal shell = require(\"shell\")\13\n\13\nlocal args, options = shell.parse(...)\13\nif #args < 2 then\13\n  io.write(\"Usage: cp [-inrv] <from...> <to>\\n\")\13\n  io.write(\" -i: prompt before overwrite (overrides -n option).\\n\")\13\n  io.write(\" -n: do not overwrite an existing file.\\n\")\13\n  io.write(\" -r: copy directories recursively.\\n\")\13\n  io.write(\" -v: verbose output.\")\13\n  return\13\nend\13\n\13\nlocal from = {}\13\nfor i = 1, #args - 1 do\13\n  table.insert(from, shell.resolve(args[i]))\13\nend\13\nlocal to = shell.resolve(args[#args])\13\n\13\nlocal function status(from, to)\13\n  if options.v then\13\n    print(from .. \" -> \" .. to)\13\n  end\13\n  os.sleep(0) -- allow interrupting\13\nend\13\n\13\nlocal result, reason\13\n\13\nlocal function prompt(message)\13\n  io.write(message .. \" \")\13\n  local result = io.read()\13\n  return result and result:sub(1, 1):lower() == \"y\"\13\nend\13\n\13\nlocal function recurse(fromPath, toPath)\13\n  status(fromPath, toPath)\13\n  if fs.isDirectory(fromPath) then\13\n    if not options.r then\13\n      io.write(\"omitting directory `\" .. fromPath .. \"'\\n\")\13\n      return true\13\n    end\13\n    if fs.canonical(fromPath) == fs.canonical(fs.path(toPath)) then\13\n      return nil, \"cannot copy a directory, `\" .. fromPath .. \"', into itself, `\" .. toPath .. \"'\\n\"\13\n    end\13\n    if fs.exists(toPath) and not fs.isDirectory(toPath) then\13\n      -- my real cp always does this, even with -f, -n or -i.\13\n      return nil, \"cannot overwrite non-directory `\" .. toPath .. \"' with directory `\" .. fromPath .. \"'\"\13\n    end\13\n    fs.makeDirectory(toPath)\13\n    for file in fs.list(fromPath) do\13\n      local result, reason = recurse(fs.concat(fromPath, file), fs.concat(toPath, file))\13\n      if not result then\13\n        return nil, reason\13\n      end\13\n    end\13\n    return true\13\n  else\13\n    if fs.exists(toPath) then\13\n      if fs.canonical(fromPath) == fs.canonical(toPath) then\13\n        return nil, \"`\" .. fromPath .. \"' and `\" .. toPath .. \"' are the same file\"\13\n      end\13\n      if fs.isDirectory(toPath) then\13\n        if options.i then\13\n          if not prompt(\"overwrite `\" .. toPath .. \"'?\") then\13\n            return true\13\n          end\13\n        elseif options.n then\13\n          return true\13\n        else -- yes, even for -f\13\n          return nil, \"cannot overwrite directory `\" .. toPath .. \"' with non-directory\"\13\n        end\13\n      else\13\n        if options.i then\13\n          if not prompt(\"overwrite `\" .. toPath .. \"'?\") then\13\n            return true\13\n          end\13\n        elseif options.n then\13\n          return true\13\n        end\13\n        -- else: default to overwriting\13\n      end\13\n      fs.remove(toPath)\13\n    end\13\n    return fs.copy(fromPath, toPath)\13\n  end\13\nend\13\nfor _, fromPath in ipairs(from) do\13\n  local toPath = to\13\n  if fs.isDirectory(toPath) then\13\n    toPath = fs.concat(toPath, fs.name(fromPath))\13\n  end\13\n  result, reason = recurse(fromPath, toPath)\13\n  if not result then\13\n    error(reason, 0)\13\n  end\13\nend",["/usr/man/mkdir"]="NAME\13\n  mkdir - make directories\13\n\13\nSYNOPSIS\13\n  mkdir DIRECTORY...\13\n\13\nDESCRIPTION\13\n  Create the specified directories, if they don't already exist.\13\n\13\nEXAMPLES\13\n  mkdir a\13\n    Create directory `a` in the current directory.\13\n\13\n  mkdir /a/b c\13\n    Create directory `/a` if it doesn't already exists, then create directory `/a/b` and create directory `c` in the current directory.",["/usr/man/which"]="NAME\13\n  which - locate a command\13\n\13\nSYNOPSIS\13\n  which COMMAND\13\n\13\nDESCRIPTION\13\n  This program writes the full path to each of the specified programs to the standard output. If a program is an alias, this is indicated. If a program cannot be found and error message will be written.\13\n\13\nEXAMPLES\13\n  which ls\13\n    Displays `/bin/ls.lua`.\13\n\13\n  which doesntexist dir\13\n    Displays `doesntexist: file not found` and `dir: aliased to ls`.",["/usr/man/ls"]="NAME\13\n  ls - list directory contents\13\n\13\nSYNOPSIS\13\n  ls [OPTION]... [FILE]...\13\n\13\nDESCRIPTION\13\n  List information about the specified files, or the current working directory by default.\13\n\13\nOPTIONS\13\n  -a\13\n    do not ignore entries starting with .\13\n  -l\13\n    use a long listing format\13\n  -p\13\n    append / indicator to directories\13\n  -M\13\n    display Microsoft-style file and directory count after listing\13\n\13\nEXAMPLES\13\n  ls\13\n    Displays the contents of the current directory.\13\n\13\n  ls /bin /mnt\13\n    Displays the contents of the `/bin`/ and `/mnt` directories, one after the other.",["/usr/man/date"]="NAME\13\n  date - get the current time and date\13\n\13\nSYNOPSIS\13\n  date\13\n\13\nDESCRIPTION\13\n  Writes the current time and date to the standard output. Note that the time is measured in ingame time, with the date starting on the 1st of January 1970 as the time the world was created.\13\n\13\nEXAMPLES\13\n  date\13\n    Displays the current date and time.",["/bin/ls.lua"]="local component = require(\"component\")\13\nlocal fs = require(\"filesystem\")\13\nlocal shell = require(\"shell\")\13\nlocal text = require('text')\13\n\13\nlocal dirs, options = shell.parse(...)\13\nif #dirs == 0 then\13\n  table.insert(dirs, \".\")\13\nend\13\n\13\nio.output():setvbuf(\"line\")\13\nfor i = 1, #dirs do\13\n  local path = shell.resolve(dirs[i])\13\n  if #dirs > 1 then\13\n    if i > 1 then\13\n      io.write(\"\\n\")\13\n    end\13\n    io.write(path, \":\\n\")\13\n  end\13\n  local list, reason = fs.list(path)\13\n  if not list then\13\n    io.write(reason .. \"\\n\")\13\n  else\13\n    local function setColor(c)\13\n      if component.isAvailable(\"gpu\") and component.gpu.getForeground() ~= c then\13\n        io.stdout:flush()\13\n        component.gpu.setForeground(c)\13\n      end\13\n    end\13\n    local lsd = {}\13\n    local lsf = {}\13\n    local m = 1\13\n    for f in list do\13\n      m = math.max(m, f:len() + 2)\13\n      if f:sub(-1) == \"/\" then\13\n        if options.p then\13\n          table.insert(lsd, f)\13\n        else\13\n          table.insert(lsd, f:sub(1, -2))\13\n        end\13\n      else\13\n        table.insert(lsf, f)\13\n      end\13\n    end\13\n    table.sort(lsd)\13\n    table.sort(lsf)\13\n    setColor(0x66CCFF)\13\n\13\n    local col = 1\13\n    local columns = math.huge\13\n    if component.isAvailable(\"gpu\") and io.output() == io.stdout then\13\n      columns = math.max(1, math.floor((component.gpu.getResolution() - 1) / m))\13\n    end\13\n\13\n    for _, d in ipairs(lsd) do\13\n      if options.a or d:sub(1, 1) ~= \".\" then\13\n        io.write(text.padRight(d, m))\13\n        if options.l or io.output() ~= io.stdout or col % columns == 0 then\13\n          io.write(\"\\n\")\13\n        end\13\n        col = col + 1\13\n      end\13\n    end\13\n\13\n    for _, f in ipairs(lsf) do\13\n      if fs.isLink(fs.concat(path, f)) then\13\n        setColor(0xFFAA00)\13\n      elseif f:sub(-4) == \".lua\" then\13\n        setColor(0x00FF00)\13\n      else\13\n        setColor(0xFFFFFF)\13\n      end\13\n      if options.a or f:sub(1, 1) ~= \".\" then\13\n        io.write(text.padRight(f, m))\13\n        if options.l then\13\n          setColor(0xFFFFFF)\13\n          io.write(fs.size(fs.concat(path, f)), \"\\n\")\13\n        elseif io.output() ~= io.stdout or col % columns == 0 then\13\n          io.write(\"\\n\")\13\n        end\13\n        col = col + 1\13\n      end\13\n    end\13\n\13\n    setColor(0xFFFFFF)\13\n    if options.M then\13\n      io.write(\"\\n\" .. tostring(#lsf) .. \" File(s)\")\13\n      io.write(\"\\n\" .. tostring(#lsd) .. \" Dir(s)\")\13\n    end\13\n    if not options.l then\13\n      io.write(\"\\n\")\13\n    end\13\n  end\13\nend\13\nio.output():setvbuf(\"no\")\13\nio.output():flush()\13\n",["/bin/echo.lua"]="local args = table.pack(...)\13\nfor i = 1, #args do\13\n  if i > 1 then\13\n    io.write(\" \")\13\n  end\13\n  io.write(args[i])\13\nend",["/usr/man/cp"]="NAME\13\n  cp - copy files\13\n\13\nSYNOPSIS\13\n  cp SOURCE DEST\13\n  cp SOURCE DIRECTORY\13\n\13\nDESCRIPTION\13\n  `cp` allows copying single files on a filesystem and across filesystems.\13\n\13\nEXAMPLES\13\n  cp a b\13\n    Copy file `a` to new file `b` in the same directory.\13\n\13\n  cp /home/a.txt /home/d/\13\n    Copy file `/home/a.txt` to new file `/home/d/a.txt`.",["/bin/pwd.lua"]="local shell = require(\"shell\")\13\n\13\nio.write(shell.getWorkingDirectory())",["/bin/date.lua"]="io.write(os.date(\"%F %T\"))",["/bin/mkdir.lua"]="local fs = require(\"filesystem\")\13\nlocal shell = require(\"shell\")\13\n\13\nlocal args = shell.parse(...)\13\nif #args == 0 then\13\n  io.write(\"Usage: mkdir <dirname1> [<dirname2> [...]]\")\13\n  return\13\nend\13\n\13\nfor i = 1, #args do\13\n  local path = shell.resolve(args[i])\13\n  local result, reason = fs.makeDirectory(path)\13\n  if not result then\13\n    if not reason then\13\n      if fs.exists(path) then\13\n        reason = \"file or folder with that name already exists\"\13\n      else\13\n        reason = \"unknown reason\"\13\n      end\13\n    end\13\n    io.stderr:write(path .. \": \" .. reason .. \"\\n\")\13\n  end\13\nend\13\n",["/usr/man/echo"]="NAME\13\n  echo - display a line of test\13\n\13\nSYNOPSIS\13\n  echo [STRING]...\13\n\13\nDESCRIPTION\13\n  `echo` writes the provided string(s) to the standard output.\13\n\13\nEXAMPLES\13\n  echo test\13\n    Print `test` to the terminal.\13\n\13\n  echo \"a   b\" > test\13\n    Writes the string `a   b` to the standard output, which is redirected into file `test`.",["/bin/more.lua"]="local component = require(\"component\")\13\nlocal event = require(\"event\")\13\nlocal keyboard = require(\"keyboard\")\13\nlocal shell = require(\"shell\")\13\nlocal term = require(\"term\")\13\nlocal text = require(\"text\")\13\nlocal unicode = require(\"unicode\")\13\n\13\nlocal args = shell.parse(...)\13\nif #args == 0 then\13\n  io.write(\"Usage: more <filename1>\")\13\n  return\13\nend\13\n\13\nlocal file, reason = io.open(shell.resolve(args[1]))\13\nif not file then\13\n  io.stderr:write(reason)\13\n  return\13\nend\13\n\13\nlocal function readlines(file, line, num)\13\n  local w, h = component.gpu.getResolution()\13\n  num = num or (h - 1)\13\n  term.setCursorBlink(false)\13\n  for _ = 1, num do\13\n    if not line then\13\n      line = file:read(\"*l\")\13\n      if not line then -- eof\13\n        return nil\13\n      end\13\n    end\13\n    local wrapped\13\n    wrapped, line = text.wrap(text.detab(line), w, w)\13\n    io.write(wrapped .. \"\\n\")\13\n  end\13\n  term.setCursor(1, h)\13\n  term.write(\":\")\13\n  term.setCursorBlink(true)\13\n  return true\13\nend\13\n\13\nlocal line = nil\13\nwhile true do\13\n  term.clear()\13\n  if not readlines(file, line) then\13\n    return\13\n  end\13\n  while true do\13\n    local event, address, char, code = event.pull(\"key_down\")\13\n    if component.isPrimary(address) then\13\n      if code == keyboard.keys.q then\13\n        term.setCursorBlink(false)\13\n        term.clearLine()\13\n        return\13\n      elseif code == keyboard.keys.space or code == keyboard.keys.pageDown then\13\n        break\13\n      elseif code == keyboard.keys.enter or code == keyboard.keys.down then\13\n        term.clearLine()\13\n        if not readlines(file, line, 1) then\13\n          return\13\n        end\13\n      end\13\n    end\13\n  end\13\nend\13\n",["/bin/uptime.lua"]="local computer = require(\"computer\")\13\n\13\nlocal seconds = math.floor(computer.uptime())\13\nlocal minutes, hours = 0, 0\13\nif seconds >= 60 then\13\n  minutes = math.floor(seconds / 60)\13\n  seconds = seconds % 60\13\nend\13\nif minutes >= 60 then\13\n  hours = math.floor(minutes / 60)\13\n  minutes = minutes % 60\13\nend\13\nio.write(string.format(\"%02d:%02d:%02d\", hours, minutes, seconds))",["/usr/man/ln"]="NAME\13\n  ln - creates symbolic links\13\n\13\nSYNOPSIS\13\n  ln FILE [TARGET]\13\n\13\nDESCRIPTION\13\n  `ln` allows creating virtual symbolic links. A symbolic link is a reference in the file system that can be used to point to other nodes in the file system. For example, a symbolic link to a file will behave like that file: it can be opened and changed, where in reality the file the link references is changed. A symbolic link to a directory will behave as such.\13\n\13\n  Note that symbolic links can lead to cycles (recursion) in the file system structure.\13\n\13\n  Symbolic links in OpenOS are 'virtual'. They are not stored on any file system, and as such will not persist across a reboot of the computer. This also means that the can be created in virtual folders, and even on read-only file systems.\13\n\13\nEXAMPLES\13\n  ln /bin/ls.lua\13\n    Creates a symbolic link `ls.lua` to the file `/bin/ls.lua` in the current working directory.\13\n\13\n  ln /home/magic.lua /bin/magic.lua\13\n    Creates a symbolic link to file `/home/magic.lua` in the `/bin` directory.",["/usr/man/df"]="NAME\13\n  df - report file system disk space usage\13\n\13\nSYNOPSIS\13\n  df [FILE]...\13\n\13\nDESCRIPTION\13\n  `cp` allows copying single files on a filesystem and across filesystems.\13\n\13\nEXAMPLES\13\n  df\13\n    Show global file system disk usage.\13\n\13\n  df /home /var\13\n    Show disk usage of file systems mounted at `/home` and `/var`."},conflicts={"binaries-0.1"},name="coreutils",depends={"init"}}