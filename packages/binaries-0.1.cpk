{contents={["/bin/resolution.lua"]="local component = require(\"component\")\13\nlocal shell = require(\"shell\")\13\nlocal term = require(\"term\")\13\n\13\nlocal args = shell.parse(...)\13\nif #args == 0 then\13\n  local w, h = component.gpu.getResolution()\13\n  io.write(w .. \" \" .. h)\13\n  return\13\nend\13\n\13\nif #args < 2 then\13\n  io.write(\"Usage: resolution [<width> <height>]\")\13\n  return\13\nend\13\n\13\nlocal w = tonumber(args[1])\13\nlocal h = tonumber(args[2])\13\nif not w or not h then\13\n  io.stderr:write(\"invalid width or height\")\13\n  return\13\nend\13\n\13\nlocal result, reason = component.gpu.setResolution(w, h)\13\nif not result then\13\n  if reason then -- otherwise we didn't change anything\13\n    io.stderr:write(reason)\13\n  end\13\n  return\13\nend\13\nterm.clear()",["/usr/man/more"]="NAME\13\n  more - primitive file viewer\13\n\13\nSYNOPSIS\13\n  more FILE\13\n\13\nDESCRIPTION\13\n  `more` allows viewing the contents of a file one screenful at a time.\13\n\13\nEXAMPLES\13\n  more /home/a.txt\13\n    Displays the contents of file `/home/a.txt`",["/bin/components.lua"]="local component = require(\"component\")\13\nlocal shell = require(\"shell\")\13\nlocal text = require(\"text\")\13\n\13\nlocal args, options = shell.parse(...)\13\nlocal count = tonumber(options.limit) or math.huge\13\n\13\nlocal components = {}\13\nlocal padTo = 1\13\n\13\nif #args == 0 then -- get all components if no filters given.\13\n  args[1] = \"\"\13\nend\13\nfor _, filter in ipairs(args) do\13\n  for address, name in component.list(filter) do\13\n    if name:len() > padTo then\13\n      padTo = name:len() + 2\13\n    end\13\n    components[address] = name\13\n  end\13\nend\13\n\13\npadTo = padTo + 8 - padTo % 8\13\nfor address, name in pairs(components) do\13\n  io.write(text.padRight(name, padTo) .. address .. '\\n')\13\n\13\n  if options.l then\13\n    local proxy = component.proxy(address)\13\n    local padTo = 1\13\n    local methods = {}\13\n    for name, member in pairs(proxy) do\13\n      if type(member) == \"table\" or type(member) == \"function\" then\13\n        if name:len() > padTo then\13\n          padTo = name:len() + 2\13\n        end\13\n        table.insert(methods, name)\13\n      end\13\n    end\13\n    table.sort(methods)\13\n    padTo = padTo + 8 - padTo % 8\13\n\13\n    for _, name in ipairs(methods) do\13\n      local doc = tostring(proxy[name])\13\n      io.write(\"  \" .. text.padRight(name, padTo) .. doc .. '\\n')\13\n    end\13\n  end\13\n\13\n  count = count - 1\13\n  if count <= 0 then\13\n    break\13\n  end\13\nend\13\n",["/bin/lua.lua"]="local component = require(\"component\")\13\nlocal package = require(\"package\")\13\nlocal term = require(\"term\")\13\nlocal serialization = require(\"serialization\")\13\nlocal shell = require(\"shell\")\13\n\13\nlocal args, options = shell.parse(...)\13\nlocal env = setmetatable({}, {__index = _ENV})\13\n\13\nif #args > 0 then\13\n  local script, reason = loadfile(args[1], nil, env)\13\n  if not script then\13\n    io.stderr:write(tostring(reason) .. \"\\n\")\13\n    os.exit(false)\13\n  end\13\n  local result, reason = pcall(script, table.unpack(args, 2))\13\n  if not result then\13\n    io.stderr:write(reason)\13\n    os.exit(false)\13\n  end\13\nend\13\n\13\nif #args == 0 or options.i then\13\n  local function optrequire(...)\13\n    local success, module = pcall(require, ...)\13\n    if success then\13\n      return module\13\n    end\13\n  end\13\n  setmetatable(env, {__index = function(t, k)\13\n    return _ENV[k] or optrequire(k)\13\n  end})\13\n\13\n  local history = {}\13\n\13\n  component.gpu.setForeground(0xFFFFFF)\13\n  term.write(\"Lua 5.2.3 Copyright (C) 1994-2013 Lua.org, PUC-Rio\\n\")\13\n  component.gpu.setForeground(0xFFFF00)\13\n  term.write(\"Enter a statement and hit enter to evaluate it.\\n\")\13\n  term.write(\"Prefix an expression with '=' to show its value.\\n\")\13\n  term.write(\"Press Ctrl+C to exit the interpreter.\\n\")\13\n  component.gpu.setForeground(0xFFFFFF)\13\n\13\n  while term.isAvailable() do\13\n    local foreground = component.gpu.setForeground(0x00FF00)\13\n    term.write(tostring(env._PROMPT or \"lua> \"))\13\n    component.gpu.setForeground(foreground)\13\n    local command = term.read(history)\13\n    if command == nil then -- eof\13\n      return\13\n    end\13\n    while #history > 10 do\13\n      table.remove(history, 1)\13\n    end\13\n    local code, reason\13\n    if string.sub(command, 1, 1) == \"=\" then\13\n      code, reason = load(\"return \" .. string.sub(command, 2), \"=stdin\", \"t\", env)\13\n    else\13\n      code, reason = load(command, \"=stdin\", \"t\", env)\13\n    end\13\n    if code then\13\n      local result = table.pack(xpcall(code, debug.traceback))\13\n      if not result[1] then\13\n        if type(result[2]) == \"table\" and result[2].reason == \"terminated\" then\13\n          os.exit(result[2].code)\13\n        end\13\n        io.stderr:write(tostring(result[2]) .. \"\\n\")\13\n      else\13\n        for i = 2, result.n do\13\n          term.write(serialization.serialize(result[i], true) .. \"\\t\", true)\13\n        end\13\n        if term.getCursor() > 1 then\13\n          term.write(\"\\n\")\13\n        end\13\n      end\13\n    else\13\n      io.stderr:write(tostring(reason) .. \"\\n\")\13\n    end\13\n  end\13\nend",["/usr/man/uptime"]="NAME\13\n  uptime - how long has the computer been running\13\n\13\nSYNOPSIS\13\n  uptime\13\n\13\nDESCRIPTION\13\n  Writes the time in real time hours, minutes and seconds the computer has been running to the standard output.\13\n\13\nEXAMPLES\13\n  uptime\13\n    Displays the time the computer has been running.",["/usr/man/umount"]="NAME\13\n  umount - remove a file system mount\13\n\13\nSYNOPSIS\13\n  umount PATH\13\n  umount -a LABEL\13\n  umount -a ADDRESS\13\n\13\nDESCRIPTION\13\n  Removes either a single mount point if given the path into a mount, or all mount points for a specified file system if given the label or address of the file system.\13\n\13\nEXAMPLES\13\n  umount /mnt/82f\13\n    Unmounts the automatically generated mountpoint at `/mnt/82f`.\13\n\13\n  unmount -a 82f\13\n    Removes all mounts of the file system for which the address starts with `82f`.",["/bin/edit.lua"]="local component = require(\"component\")\13\nlocal event = require(\"event\")\13\nlocal fs = require(\"filesystem\")\13\nlocal keyboard = require(\"keyboard\")\13\nlocal shell = require(\"shell\")\13\nlocal term = require(\"term\")\13\nlocal text = require(\"text\")\13\nlocal unicode = require(\"unicode\")\13\n\13\nif not term.isAvailable() then\13\n  return\13\nend\13\n\13\nlocal args, options = shell.parse(...)\13\nif #args == 0 then\13\n  io.write(\"Usage: edit <filename>\")\13\n  return\13\nend\13\n\13\nlocal filename = shell.resolve(args[1])\13\n\13\nlocal readonly = options.r or fs.get(filename) == nil or fs.get(filename).isReadOnly()\13\n\13\nif not fs.exists(filename) then\13\n  if fs.isDirectory(filename) then\13\n    io.stderr:write(\"file is a directory\")\13\n    return\13\n  elseif readonly then\13\n    io.stderr:write(\"file system is read only\")\13\n    return\13\n  end\13\nend\13\n\13\nterm.clear()\13\nterm.setCursorBlink(true)\13\n\13\nlocal running = true\13\nlocal buffer = {}\13\nlocal scrollX, scrollY = 0, 0\13\n\13\n-------------------------------------------------------------------------------\13\n\13\nlocal function setStatus(value)\13\n  local w, h = component.gpu.getResolution()\13\n  component.gpu.set(1, h, text.padRight(unicode.sub(value, 1, w - 10), w - 10))\13\nend\13\n\13\nlocal function getSize()\13\n  local w, h = component.gpu.getResolution()\13\n  return w, h - 1\13\nend\13\n\13\nlocal function getCursor()\13\n  local cx, cy = term.getCursor()\13\n  return cx + scrollX, cy + scrollY\13\nend\13\n\13\nlocal function line()\13\n  local cbx, cby = getCursor()\13\n  return buffer[cby]\13\nend\13\n\13\nlocal function setCursor(nbx, nby)\13\n  local w, h = getSize()\13\n  nby = math.max(1, math.min(#buffer, nby))\13\n\13\n  local ncy = nby - scrollY\13\n  if ncy > h then\13\n    term.setCursorBlink(false)\13\n    local sy = nby - h\13\n    local dy = math.abs(scrollY - sy)\13\n    scrollY = sy\13\n    component.gpu.copy(1, 1 + dy, w, h - dy, 0, -dy)\13\n    for by = nby - (dy - 1), nby do\13\n      local str = text.padRight(unicode.sub(buffer[by], 1 + scrollX), w)\13\n      component.gpu.set(1, by - scrollY, str)\13\n    end\13\n  elseif ncy < 1 then\13\n    term.setCursorBlink(false)\13\n    local sy = nby - 1\13\n    local dy = math.abs(scrollY - sy)\13\n    scrollY = sy\13\n    component.gpu.copy(1, 1, w, h - dy, 0, dy)\13\n    for by = nby, nby + (dy - 1) do\13\n      local str = text.padRight(unicode.sub(buffer[by], 1 + scrollX), w)\13\n      component.gpu.set(1, by - scrollY, str)\13\n    end\13\n  end\13\n  term.setCursor(term.getCursor(), nby - scrollY)\13\n\13\n  nbx = math.max(1, math.min(unicode.len(line()) + 1, nbx))\13\n  local ncx = nbx - scrollX\13\n  if ncx > w then\13\n    term.setCursorBlink(false)\13\n    local sx = nbx - w\13\n    local dx = math.abs(scrollX - sx)\13\n    scrollX = sx\13\n    component.gpu.copy(1 + dx, 1, w - dx, h, -dx, 0)\13\n    for by = 1 + scrollY, math.min(h + scrollY, #buffer) do\13\n      local str = unicode.sub(buffer[by], nbx - (dx - 1), nbx)\13\n      str = text.padRight(str, dx)\13\n      component.gpu.set(1 + (w - dx), by - scrollY, str)\13\n    end\13\n  elseif ncx < 1 then\13\n    term.setCursorBlink(false)\13\n    local sx = nbx - 1\13\n    local dx = math.abs(scrollX - sx)\13\n    scrollX = sx\13\n    component.gpu.copy(1, 1, w - dx, h, dx, 0)\13\n    for by = 1 + scrollY, math.min(h + scrollY, #buffer) do\13\n      local str = unicode.sub(buffer[by], nbx, nbx + dx)\13\n      --str = text.padRight(str, dx)\13\n      component.gpu.set(1, by - scrollY, str)\13\n    end\13\n  end\13\n  term.setCursor(nbx - scrollX, nby - scrollY)\13\n\13\n  component.gpu.set(w - 9, h + 1, text.padLeft(string.format(\"%d,%d\", nby, nbx), 10))\13\nend\13\n\13\nlocal function home()\13\n  local cbx, cby = getCursor()\13\n  setCursor(1, cby)\13\nend\13\n\13\nlocal function ende()\13\n  local cbx, cby = getCursor()\13\n  setCursor(unicode.len(line()) + 1, cby)\13\nend\13\n\13\nlocal function left()\13\n  local cbx, cby = getCursor()\13\n  if cbx > 1 then\13\n    setCursor(cbx - 1, cby)\13\n    return true -- for backspace\13\n  elseif cby > 1 then\13\n    setCursor(cbx, cby - 1)\13\n    ende()\13\n    return true -- again, for backspace\13\n  end\13\nend\13\n\13\nlocal function right(n)\13\n  n = n or 1\13\n  local cbx, cby = getCursor()\13\n  local be = unicode.len(line()) + 1\13\n  if cbx < be then\13\n    setCursor(cbx + n, cby)\13\n  elseif cby < #buffer then\13\n    setCursor(1, cby + 1)\13\n  end\13\nend\13\n\13\nlocal function up(n)\13\n  n = n or 1\13\n  local cbx, cby = getCursor()\13\n  if cby > 1 then\13\n    setCursor(cbx, cby - n)\13\n    if getCursor() > unicode.len(line()) then\13\n      ende()\13\n    end\13\n  end\13\nend\13\n\13\nlocal function down(n)\13\n  n = n or 1\13\n  local cbx, cby = getCursor()\13\n  if cby < #buffer then\13\n    setCursor(cbx, cby + n)\13\n    if getCursor() > unicode.len(line()) then\13\n      ende()\13\n    end\13\n  end\13\nend\13\n\13\nlocal function delete()\13\n  local cx, cy = term.getCursor()\13\n  local cbx, cby = getCursor()\13\n  local w, h = getSize()\13\n  if cbx <= unicode.len(line()) then\13\n    term.setCursorBlink(false)\13\n    buffer[cby] = unicode.sub(line(), 1, cbx - 1) ..\13\n                  unicode.sub(line(), cbx + 1)\13\n    component.gpu.copy(cx + 1, cy, w - cx, 1, -1, 0)\13\n    local br = cbx + (w - cx)\13\n    local char = unicode.sub(line(), br, br)\13\n    if not char or unicode.len(char) == 0 then\13\n      char = \" \"\13\n    end\13\n    component.gpu.set(w, cy, char)\13\n  elseif cby < #buffer then\13\n    term.setCursorBlink(false)\13\n    local append = table.remove(buffer, cby + 1)\13\n    buffer[cby] = buffer[cby] .. append\13\n    component.gpu.set(cx, cy, append)\13\n    if cy < h then\13\n      component.gpu.copy(1, cy + 2, w, h - (cy + 1), 0, -1)\13\n      component.gpu.set(1, h, text.padRight(buffer[cby + (h - cy)], w))\13\n    end\13\n    setStatus(\"Save: [Ctrl+S] Close: [Ctrl+W]\")\13\n  end\13\nend\13\n\13\nlocal function insert(value)\13\n  if not value or unicode.len(value) < 1 then\13\n    return\13\n  end\13\n  term.setCursorBlink(false)\13\n  local cx, cy = term.getCursor()\13\n  local cbx, cby = getCursor()\13\n  local w, h = getSize()\13\n  buffer[cby] = unicode.sub(line(), 1, cbx - 1) ..\13\n                value ..\13\n                unicode.sub(line(), cbx)\13\n  local len = unicode.len(value)\13\n  local n = w - (cx - 1) - len\13\n  if n > 0 then\13\n    component.gpu.copy(cx, cy, n, 1, len, 0)\13\n  end\13\n  component.gpu.set(cx, cy, value)\13\n  right(len)\13\n  setStatus(\"Save: [Ctrl+S] Close: [Ctrl+W]\")\13\nend\13\n\13\nlocal function enter()\13\n  term.setCursorBlink(false)\13\n  local cx, cy = term.getCursor()\13\n  local cbx, cby = getCursor()\13\n  local w, h = getSize()\13\n  table.insert(buffer, cby + 1, unicode.sub(buffer[cby], cbx))\13\n  buffer[cby] = unicode.sub(buffer[cby], 1, cbx - 1)\13\n  component.gpu.fill(cx, cy, w - (cx - 1), 1, \" \")\13\n  if cy < h then\13\n    if cy < h - 1 then\13\n      component.gpu.copy(1, cy + 1, w, h - (cy + 1), 0, 1)\13\n    end\13\n    component.gpu.set(1, cy + 1, text.padRight(buffer[cby + 1], w))\13\n  end\13\n  setCursor(1, cby + 1)\13\n  setStatus(\"Save: [Ctrl+S] Close: [Ctrl+W]\")\13\nend\13\n\13\nlocal controlKeyCombos = {[keyboard.keys.s]=true,[keyboard.keys.w]=true,\13\n                          [keyboard.keys.c]=true,[keyboard.keys.x]=true}\13\nlocal function onKeyDown(char, code)\13\n  if code == keyboard.keys.back and not readonly then\13\n    if left() then\13\n      delete()\13\n    end\13\n  elseif code == keyboard.keys.delete and not readonly then\13\n    delete()\13\n  elseif code == keyboard.keys.left then\13\n    left()\13\n  elseif code == keyboard.keys.right then\13\n    right()\13\n  elseif code == keyboard.keys.home then\13\n    home()\13\n  elseif code == keyboard.keys[\"end\"] then\13\n    ende()\13\n  elseif code == keyboard.keys.up then\13\n    up()\13\n  elseif code == keyboard.keys.down then\13\n    down()\13\n  elseif code == keyboard.keys.pageUp then\13\n    local w, h = getSize()\13\n    up(h - 1)\13\n  elseif code == keyboard.keys.pageDown then\13\n    local w, h = getSize()\13\n    down(h - 1)\13\n  elseif code == keyboard.keys.enter and not readonly then\13\n    enter()\13\n  elseif keyboard.isControlDown() and controlKeyCombos[code] then\13\n    local cbx, cby = getCursor()\13\n    if code == keyboard.keys.s and not readonly then\13\n      local new = not fs.exists(filename)\13\n      local f, reason = io.open(filename, \"w\")\13\n      if f then\13\n        local chars, firstLine = 0, true\13\n        for _, line in ipairs(buffer) do\13\n          if not firstLine then\13\n            line = \"\\n\" .. line\13\n          end\13\n          firstLine = false\13\n          f:write(line)\13\n          chars = chars + unicode.len(line)\13\n        end\13\n        f:close()\13\n        local format\13\n        if new then\13\n          format = [[\"%s\" [New] %dL,%dC written]]\13\n        else\13\n          format = [[\"%s\" %dL,%dC written]]\13\n        end\13\n        setStatus(string.format(format, fs.name(filename), #buffer, chars))\13\n      else\13\n        setStatus(reason)\13\n      end\13\n    elseif code == keyboard.keys.w or\13\n           code == keyboard.keys.c or\13\n           code == keyboard.keys.x\13\n    then\13\n      -- TODO ask to save if changed\13\n      running = false\13\n    end\13\n  elseif readonly and code == keyboard.keys.q then\13\n    running = false\13\n  elseif not readonly then\13\n    if not keyboard.isControl(char) then\13\n      insert(unicode.char(char))\13\n    elseif unicode.char(char) == \"\\t\" then\13\n      insert(\"  \")\13\n    end\13\n  end\13\nend\13\n\13\nlocal function onClipboard(value)\13\n  local cbx, cby = getCursor()\13\n  local start = 1\13\n  local l = value:find(\"\\n\", 1, true)\13\n  if l then\13\n    repeat\13\n      insert(string.sub(value, start, l - 1))\13\n      enter()\13\n      start = l + 1\13\n      l = value:find(\"\\n\", start, true)\13\n    until not l\13\n  end\13\n  insert(string.sub(value, start))\13\nend\13\n\13\nlocal function onClick(x, y)\13\n  setCursor(x + scrollX, y + scrollY)\13\nend\13\n\13\nlocal function onScroll(direction)\13\n  local cbx, cby = getCursor()\13\n  setCursor(cbx, cby - direction * 12)\13\nend\13\n\13\n-------------------------------------------------------------------------------\13\n\13\ndo\13\n  local f = io.open(filename)\13\n  if f then\13\n    local w, h = getSize()\13\n    local chars = 0\13\n    for line in f:lines() do\13\n      if line:sub(-1) == \"\\r\" then\13\n        line = line:sub(1, -2)\13\n      end\13\n      table.insert(buffer, line)\13\n      chars = chars + unicode.len(line)\13\n      if #buffer <= h then\13\n        component.gpu.set(1, #buffer, line)\13\n      end\13\n    end\13\n    f:close()\13\n    if #buffer == 0 then\13\n      table.insert(buffer, \"\")\13\n    end\13\n    local format\13\n    if readonly then\13\n      format = [[\"%s\" [readonly] %dL,%dC]]\13\n    else\13\n      format = [[\"%s\" %dL,%dC]]\13\n    end\13\n    setStatus(string.format(format, fs.name(filename), #buffer, chars))\13\n  else\13\n    table.insert(buffer, \"\")\13\n    setStatus(string.format([[\"%s\" [New File] ]], fs.name(filename)))\13\n  end\13\n  setCursor(1, 1)\13\nend\13\n\13\nwhile running do\13\n  local event, address, arg1, arg2, arg3 = event.pull()\13\n  if type(address) == \"string\" and component.isPrimary(address) then\13\n    local blink = true\13\n    if event == \"key_down\" then\13\n      onKeyDown(arg1, arg2)\13\n    elseif event == \"clipboard\" and not readonly then\13\n      onClipboard(arg1)\13\n    elseif event == \"touch\" or event == \"drag\" then\13\n      onClick(arg1, arg2)\13\n    elseif event == \"scroll\" then\13\n      onScroll(arg3)\13\n    else\13\n      blink = false\13\n    end\13\n    if blink then\13\n      term.setCursorBlink(true)\13\n      term.setCursorBlink(true) -- force toggle to caret\13\n    end\13\n  end\13\nend\13\n\13\nterm.clear()\13\nterm.setCursorBlink(false)\13\n",["/usr/man/useradd"]="NAME\13\n  useradd - adds a player to the list of authorized users\13\n\13\nSYNOPSIS\13\n  useradd NAME\13\n\13\nDESCRIPTION\13\n  Adds a player to the list of users that can use the computer. To add a player, he has to be logged in when the command is run. Note that the names are case sensitive. Users can be removed again using `userdel`.\13\n\13\n  As long as the list of players registered on a computer is empty, the computer can be used by all players. Once there is at least one entry in the list of users, only the players in the list can use the computer. This includes modifying its inventory, performing keyboard and mouse input as well as breaking the computer block.\13\n\13\n  Computer ownership can be disabled in the configuration.\13\n\13\nEXAMPLES\13\n  useradd Steve\13\n    Adds the player named `Steve` to the list of users.",["/bin/reboot.lua"]="local computer = require(\"computer\")\13\n\13\nio.write(\"Rebooting...\")\13\ncomputer.shutdown(true)",["/usr/man/shutdown"]="NAME\13\n  shutdown - shut down the computer\13\n\13\nSYNOPSIS\13\n  shutdown\13\n\13\nDESCRIPTION\13\n  Immediately shuts down the computer.\13\n\13\nEXAMPLES\13\n  shutdown\13\n    Stops the computer.",["/usr/man/cd"]="NAME\13\n  cd - change the current working directory\13\n\13\nSYNOPSIS\13\n  cd path\13\n\13\nDESCRIPTION\13\n  `cd` allows changing the current working directory, i.e the directory based on which relative paths are resloved.\13\n\13\nEXAMPLES\13\n  cd a\13\n    Changes to directory `a` in the current working directory.\13\n\13\n  cd /bin\13\n    Changes to directory `/bin`, using the specified absolute path.",["/bin/mkdir.lua"]="local fs = require(\"filesystem\")\13\nlocal shell = require(\"shell\")\13\n\13\nlocal args = shell.parse(...)\13\nif #args == 0 then\13\n  io.write(\"Usage: mkdir <dirname1> [<dirname2> [...]]\")\13\n  return\13\nend\13\n\13\nfor i = 1, #args do\13\n  local path = shell.resolve(args[i])\13\n  local result, reason = fs.makeDirectory(path)\13\n  if not result then\13\n    if not reason then\13\n      if fs.exists(path) then\13\n        reason = \"file or folder with that name already exists\"\13\n      else\13\n        reason = \"unknown reason\"\13\n      end\13\n    end\13\n    io.stderr:write(path .. \": \" .. reason .. \"\\n\")\13\n  end\13\nend\13\n",["/bin/df.lua"]="local fs = require(\"filesystem\")\13\nlocal shell = require(\"shell\")\13\nlocal text = require(\"text\")\13\n\13\nlocal args, options = shell.parse(...)\13\n\13\nlocal function formatSize(size)\13\n  if not options.h then\13\n    return tostring(size)\13\n  end\13\n  local sizes = {\"\", \"K\", \"M\", \"G\"}\13\n  local unit = 1\13\n  local power = options.si and 1000 or 1024\13\n  while size > power and unit < #sizes do\13\n    unit = unit + 1\13\n    size = size / power\13\n  end\13\n  return math.floor(size * 10) / 10 .. sizes[unit]\13\nend\13\n\13\nlocal mounts = {}\13\nif #args == 0 then\13\n  for proxy, path in fs.mounts() do\13\n    mounts[path] = proxy\13\n  end\13\nelse\13\n  for i = 1, #args do\13\n    local proxy, path = fs.get(args[i])\13\n    if not proxy then\13\n      io.stderr:write(args[i], \": no such file or directory\\n\")\13\n    else\13\n      mounts[path] = proxy\13\n    end\13\n  end\13\nend\13\n\13\nlocal result = {{\"Filesystem\", \"Used\", \"Available\", \"Use%\", \"Mounted on\"}}\13\nfor path, proxy in pairs(mounts) do\13\n  local label = proxy.getLabel() or proxy.address\13\n  local used, total = proxy.spaceUsed(), proxy.spaceTotal()\13\n  local available, percent\13\n  if total == math.huge then\13\n    used = used or \"N/A\"\13\n    available = \"unlimited\"\13\n    percent = \"0%\"\13\n  else\13\n    available = total - used\13\n    percent = used / total\13\n    if percent ~= percent then -- NaN\13\n      available = \"N/A\"\13\n      percent = \"N/A\"\13\n    else\13\n      percent = math.ceil(percent * 100) .. \"%\"\13\n    end\13\n  end\13\n  table.insert(result, {label, formatSize(used), formatSize(available), tostring(percent), path})\13\nend\13\n\13\nlocal m = {}\13\nfor _, row in ipairs(result) do\13\n  for col, value in ipairs(row) do\13\n    m[col] = math.max(m[col] or 1, value:len())\13\n  end\13\nend\13\n\13\nfor _, row in ipairs(result) do\13\n  for col, value in ipairs(row) do\13\n    io.write(text.padRight(value, m[col] + 2))\13\n  end\13\n  io.write(\"\\n\")\13\nend\13\n",["/bin/clear.lua"]="local term = require(\"term\")\13\n\13\nterm.clear()",["/usr/man/reboot"]="NAME\13\n  reboot - restarts the computer\13\n\13\nSYNOPSIS\13\n  reboot\13\n\13\nDESCRIPTION\13\n  `reboot` will immediately issue a reboot of the computer, shutting it down then starting it back up.\13\n\13\nEXAMPLES\13\n  reboot\13\n    Reboots the computer.",["/bin/umount.lua"]="local fs = require(\"filesystem\")\13\nlocal shell = require(\"shell\")\13\n\13\nlocal args, options = shell.parse(...)\13\n\13\nif #args < 1 then\13\n  io.write(\"Usage: umount [-a] <mount>\\n\")\13\n  io.write(\" -a  Remove any mounts by file system label or address instead of by path. Note that the address may be abbreviated.\")\13\n  return\13\nend\13\n\13\nlocal proxy, reason\13\nif options.a then\13\n  proxy, reason = fs.proxy(args[1])\13\n  if proxy then\13\n    proxy = proxy.address\13\n  end\13\nelse\13\n  local path = shell.resolve(args[1])\13\n  proxy, reason = fs.get(path)\13\n  if proxy then\13\n    proxy = reason -- = path\13\n    if proxy ~= path then\13\n      io.stderr:write(\"not a mount point\")\13\n      return\13\n    end\13\n  end\13\nend\13\nif not proxy then\13\n  io.stderr:write(reason)\13\n  return\13\nend\13\n\13\nif not fs.umount(proxy) then\13\n  io.stderr:write(\"nothing to unmount here\")\13\nend",["/bin/sh.lua"]="local component = require(\"component\")\13\nlocal computer = require(\"computer\")\13\nlocal event = require(\"event\")\13\nlocal fs = require(\"filesystem\")\13\nlocal process = require(\"process\")\13\nlocal shell = require(\"shell\")\13\nlocal term = require(\"term\")\13\nlocal text = require(\"text\")\13\n\13\nlocal function expand(value)\13\n  local result = value:gsub(\"%$(%w+)\", os.getenv):gsub(\"%$%b{}\",\13\n    function(match) return os.getenv(expand(match:sub(3, -2))) or match end)\13\n  return result\13\nend\13\n\13\nlocal function glob(value)\13\n  if not value:find(\"*\", 1, true) and not value:find(\"?\", 1, true) then\13\n    -- Nothing to do here.\13\n    return {expand(value)}\13\n  end\13\n  local segments = fs.segments(value)\13\n  local paths = {value:sub(1, 1) == \"/\" and \"/\" or shell.getWorkingDirectory()}\13\n  for i, segment in ipairs(segments) do\13\n    local nextPaths = {}\13\n    local pattern = segment:gsub(\"*\", \".*\"):gsub(\"?\", \".\")\13\n    if pattern == segment then\13\n      -- Nothing to do, concatenate as-is.\13\n      for _, path in ipairs(paths) do\13\n        table.insert(nextPaths, fs.concat(path, segment))\13\n      end\13\n    else\13\n      pattern = \"^(\" .. pattern .. \")/?$\"\13\n      for _, path in ipairs(paths) do\13\n        for file in fs.list(path) do\13\n          if file:match(pattern) then\13\n            table.insert(nextPaths, fs.concat(path, file))\13\n          end\13\n        end\13\n      end\13\n      if #nextPaths == 0 then\13\n        error(\"no matches found: \" .. segment)\13\n      end\13\n    end\13\n    paths = nextPaths\13\n  end\13\n  for i, path in ipairs(paths) do\13\n    paths[i] = expand(path)\13\n  end\13\n  return paths\13\nend\13\n\13\nlocal function evaluate(value)\13\n  local init, results = 1, {\"\"}\13\n  repeat\13\n    local match = value:match(\"^%b''\", init)\13\n    if match then -- single quoted string. no variable expansion.\13\n      match = match:sub(2, -2)\13\n      init = init + 2\13\n      for i, result in ipairs(results) do\13\n        results[i] = result .. match\13\n      end\13\n    else\13\n      match = value:match('^%b\"\"', init)\13\n      if match then -- double quoted string.\13\n        match = match:sub(2, -2)\13\n        init = init + 2\13\n      else\13\n        -- plaintext?\13\n        match = value:match(\"^([^']+)%b''\", init)\13\n        if not match then -- unmatched single quote.\13\n          match = value:match('^([^\"]+)%b\"\"', init)\13\n          if not match then -- unmatched double quote.\13\n            match = value:sub(init)\13\n          end\13\n        end\13\n      end\13\n      local newResults = {}\13\n      for _, globbed in ipairs(glob(match)) do\13\n        for i, result in ipairs(results) do\13\n          table.insert(newResults, result .. globbed)\13\n        end\13\n      end\13\n      results = newResults\13\n    end\13\n    init = init + #match\13\n  until init > #value\13\n  return results\13\nend\13\n\13\nlocal function execute(env, command, ...)\13\n  local parts, reason = text.tokenize(command)\13\n  if not parts then\13\n    return false, reason\13\n  elseif #parts == 0 then\13\n    return true\13\n  end\13\n  local program, args = shell.resolveAlias(parts[1], table.pack(select(2, table.unpack(parts))))\13\n  local eargs = {}\13\n  program = evaluate(program)\13\n  for i = 2, #program do\13\n    table.insert(eargs, program[i])\13\n  end\13\n  local program, reason = shell.resolve(program[1], \"lua\")\13\n  if not program then\13\n    return false, reason\13\n  end\13\n  for i = 1, #args do\13\n    for _, arg in ipairs(evaluate(args[i])) do\13\n      table.insert(eargs, arg)\13\n    end\13\n  end\13\n  args = eargs\13\n  for _, arg in ipairs(table.pack(...)) do\13\n    table.insert(args, arg)\13\n  end\13\n  table.insert(args, 1, true)\13\n  args.n = #args\13\n  local thread, reason = process.load(program, env, nil, command)\13\n  if not thread then\13\n    return false, reason\13\n  end \13\n  os.setenv(\"_\", program)\13\n  local result = nil\13\n  -- Emulate CC behavior by making yields a filtered event.pull()\13\n  while args[1] and coroutine.status(thread) ~= \"dead\" do\13\n    result = table.pack(coroutine.resume(thread, table.unpack(args, 2, args.n)))\13\n    if coroutine.status(thread) ~= \"dead\" then\13\n      if type(result[2]) == \"string\" then\13\n        args = table.pack(pcall(event.pull, table.unpack(result, 2, result.n)))\13\n      else\13\n        args = {true, n=1}\13\n      end\13\n    end\13\n  end\13\n  if not args[1] then\13\n    return false, args[2]\13\n  end\13\n  if not result[1] and type(result[2]) == \"table\" and result[2].reason == \"terminated\" then\13\n    if result[2].code then\13\n      return true\13\n    else\13\n      return false, \"terminated\"\13\n    end\13\n  end\13\n  return table.unpack(result, 1, result.n)\13\nend\13\n\13\nlocal args, options = shell.parse(...)\13\nlocal history = {}\13\n\13\nif #args == 0 and (io.input() == io.stdin or options.i) and not options.c then\13\n  -- interactive shell.\13\n  while true do\13\n    if not term.isAvailable() then -- don't clear unless we lost the term\13\n      while not term.isAvailable() do\13\n        event.pull(\"term_available\")\13\n      end\13\n      term.clear()\13\n    end\13\n    while term.isAvailable() do\13\n      local foreground = component.gpu.setForeground(0xFF0000)\13\n      term.write(expand(os.getenv(\"PS1\") or \"$ \"))\13\n      component.gpu.setForeground(foreground)\13\n      local command = term.read(history)\13\n      if not command then\13\n        term.write(\"exit\\n\")\13\n        return -- eof\13\n      end\13\n      while #history > (tonumber(os.getenv(\"HISTSIZE\")) or 10) do\13\n        table.remove(history, 1)\13\n      end\13\n      command = text.trim(command)\13\n      if command == \"exit\" then\13\n        return\13\n      elseif command ~= \"\" then\13\n        local result, reason = os.execute(command)\13\n        if term.getCursor() > 1 then\13\n          term.write(\"\\n\")\13\n        end\13\n        if not result then\13\n          io.stderr:write((tostring(reason) or \"unknown error\").. \"\\n\")\13\n        end\13\n      end\13\n    end\13\n  end\13\nelse\13\n  -- execute command.\13\n  local result = table.pack(execute(...))\13\n  if not result[1] then\13\n    error(result[2], 0)\13\n  end\13\n  return table.unpack(result, 2)\13\nend\13\n",["/bin/address.lua"]="local computer = require(\"computer\")\13\n\13\nio.write(computer.address())",["/bin/install.lua"]="local component = require(\"component\")\13\nlocal computer = require(\"computer\")\13\nlocal event = require(\"event\")\13\nlocal unicode = require(\"unicode\")\13\nlocal shell = require(\"shell\")\13\n\13\nlocal candidates = {}\13\nfor address in component.list(\"filesystem\") do\13\n  local dev = component.proxy(address)\13\n  if not dev.isReadOnly() and dev.address ~= computer.tmpAddress() then\13\n    table.insert(candidates, dev)\13\n  end\13\nend\13\n\13\nif #candidates == 0 then\13\n  print(\"No writable disks found, aborting.\")\13\n  return\13\nend\13\n\13\nfor i = 1, #candidates do\13\n  local label = candidates[i].getLabel()\13\n  if label then\13\n    label = label .. \" (\" .. candidates[i].address:sub(1, 8) .. \"...)\"\13\n  else\13\n    label = candidates[i].address\13\n  end\13\n  print(i .. \") \" .. label)\13\nend\13\n\13\nprint(\"To select the device to install to, please enter a number between 1 and \" .. #candidates .. \".\")\13\nprint(\"Press 'q' to cancel the installation.\")\13\nlocal choice\13\nwhile not choice do\13\n  result = io.read()\13\n  if result:sub(1, 1):lower() == \"q\" then\13\n    return\13\n  end\13\n  local number = tonumber(result)\13\n  if number and number > 0 and number <= #candidates then\13\n    choice = candidates[number]\13\n  else\13\n    print(\"Invalid input, please try again.\")\13\n  end\13\nend\13\ncandidates = nil\13\n\13\nprint(\"Installing OpenOS to device \" .. (choice.getLabel() or choice.address))\13\nos.sleep(0.25)\13\nlocal boot = computer.getBootAddress():sub(1, 3)\13\nlocal mnt = choice.address:sub(1, 3)\13\nlocal result, reason = os.execute(\"/bin/cp -vr /mnt/\" .. boot .. \"/* /mnt/\" .. mnt .. \"/\")\13\nif not result then\13\n  error(reason, 0)\13\nend\13\ncomputer.setBootAddress(choice.address)\13\n\13\nprint(\"All done! Would you like to reboot now? [Y/n]\")\13\nlocal result = io.read()\13\nif not result or result == \"\" or result:sub(1, 1):lower() == \"y\" then\13\n  print(\"\\nRebooting now!\")\13\n  computer.shutdown(true)\13\nend\13\nprint(\"Returning to shell.\")",["/usr/man/sh"]="NAME\13\n  sh - command interpreter (shell)\13\n\13\nSYNOPSIS\13\n  sh\13\n\13\nDESCRIPTION\13\n  This is the basic, built-in standard shell of OpenOS. It provides very basic functionality compared to what real OS's shells can achieve, but does the job for getting started. To run a command, enter it and press enter. The first token in a command will usually be a program. Any additional parameters will be passed along to the program.\13\n\13\n  Arguments to programs can be quoted, to provide strings with multiple spaces in them, for example:\13\n    echo \"a   b\"\13\n  will print the string `a   b` to the screen. It is also possible to use single quotes (echo 'a b').\13\n\13\n  Single quotes also suppress variable expansion. Per default, expressions like `$NAME` and `${NAME}` are expanded using environment variables (also accessible via the `os.getenv` method).\13\n\13\n  Basic globbing is supported, i.e. '*' and '?' are expanded approriately. For example:\13\n    ls b?n/\13\n  will list all files in `/bin/` (and, if it exists `/ban` and so on).\13\n    cp /bin/* /usr/bin/\13\n  will copy all files from `/bin` to `/usr/bin`.\13\n\13\n  The shell also supports aliases, which can be created using `alias` and removed using `unalias` (or using the `shell` API). For example, `dir` is a standard alias for `ls`.\13\n\13\nEXAMPLES\13\n  sh\13\n    Starts a new shell.",["/bin/cd.lua"]="local shell = require(\"shell\")\13\n\13\nlocal args = shell.parse(...)\13\nif #args == 0 then\13\n  io.write(\"Usage: cd <dirname>\")\13\nelse\13\n  local result, reason = shell.setWorkingDirectory(shell.resolve(args[1]))\13\n  if not result then\13\n    io.stderr:write(reason)\13\n  end\13\nend\13\n",["/usr/man/ls"]="NAME\13\n  ls - list directory contents\13\n\13\nSYNOPSIS\13\n  ls [OPTION]... [FILE]...\13\n\13\nDESCRIPTION\13\n  List information about the specified files, or the current working directory by default.\13\n\13\nOPTIONS\13\n  -a\13\n    do not ignore entries starting with .\13\n  -l\13\n    use a long listing format\13\n  -p\13\n    append / indicator to directories\13\n  -M\13\n    display Microsoft-style file and directory count after listing\13\n\13\nEXAMPLES\13\n  ls\13\n    Displays the contents of the current directory.\13\n\13\n  ls /bin /mnt\13\n    Displays the contents of the `/bin`/ and `/mnt` directories, one after the other.",["/bin/alias.lua"]="local shell = require(\"shell\")\13\n\13\nlocal args = shell.parse(...)\13\n\13\nif #args == 0 then\13\n  for name, value in shell.aliases() do\13\n    io.write(name .. \" \" .. value .. \"\\n\")\13\n  end\13\nelseif #args == 1 then\13\n  local value = shell.getAlias(args[1])\13\n  if value then\13\n    io.write(value)\13\n  else\13\n    io.stderr:write(\"no such alias\")\13\n  end\13\nelse\13\n  shell.setAlias(args[1], args[2])\13\n  io.write(\"alias created: \" .. args[1] .. \" -> \" .. args[2])\13\nend",["/usr/man/cp"]="NAME\13\n  cp - copy files\13\n\13\nSYNOPSIS\13\n  cp SOURCE DEST\13\n  cp SOURCE DIRECTORY\13\n\13\nDESCRIPTION\13\n  `cp` allows copying single files on a filesystem and across filesystems.\13\n\13\nEXAMPLES\13\n  cp a b\13\n    Copy file `a` to new file `b` in the same directory.\13\n\13\n  cp /home/a.txt /home/d/\13\n    Copy file `/home/a.txt` to new file `/home/d/a.txt`.",["/bin/unset.lua"]="local args = {...}\13\n\13\nif #args < 1 then\13\n  print(\"Usage: unset <varname>[ <varname2> [...]]\")\13\nelse\13\n  for _, k in ipairs(args) do\13\n    os.setenv(k, nil)\13\n  end\13\nend",["/bin/mv.lua"]="local fs = require(\"filesystem\")\13\nlocal shell = require(\"shell\")\13\n\13\nlocal args, options = shell.parse(...)\13\nif #args < 2 then\13\n  io.write(\"Usage: mv [-f] <from> <to>\\n\")\13\n  io.write(\" -f: overwrite file if it already exists.\")\13\n  return\13\nend\13\n\13\nlocal from = shell.resolve(args[1])\13\nlocal to = shell.resolve(args[2])\13\nif fs.isDirectory(to) then\13\n  to = to .. \"/\" .. fs.name(from)\13\nend\13\nif fs.exists(to) then\13\n  if not options.f then\13\n    io.stderr:write(\"target file exists\")\13\n  end\13\n  fs.remove(to)\13\nend\13\nlocal result, reason = os.rename(from, to)\13\nif not result then\13\n  io.stderr:write(reason or \"unknown error\")\13\nend\13\n",["/bin/uptime.lua"]="local computer = require(\"computer\")\13\n\13\nlocal seconds = math.floor(computer.uptime())\13\nlocal minutes, hours = 0, 0\13\nif seconds >= 60 then\13\n  minutes = math.floor(seconds / 60)\13\n  seconds = seconds % 60\13\nend\13\nif minutes >= 60 then\13\n  hours = math.floor(minutes / 60)\13\n  minutes = minutes % 60\13\nend\13\nio.write(string.format(\"%02d:%02d:%02d\", hours, minutes, seconds))",["/bin/ls.lua"]="local component = require(\"component\")\13\nlocal fs = require(\"filesystem\")\13\nlocal shell = require(\"shell\")\13\nlocal text = require('text')\13\n\13\nlocal dirs, options = shell.parse(...)\13\nif #dirs == 0 then\13\n  table.insert(dirs, \".\")\13\nend\13\n\13\nio.output():setvbuf(\"line\")\13\nfor i = 1, #dirs do\13\n  local path = shell.resolve(dirs[i])\13\n  if #dirs > 1 then\13\n    if i > 1 then\13\n      io.write(\"\\n\")\13\n    end\13\n    io.write(path, \":\\n\")\13\n  end\13\n  local list, reason = fs.list(path)\13\n  if not list then\13\n    io.write(reason .. \"\\n\")\13\n  else\13\n    local function setColor(c)\13\n      if component.isAvailable(\"gpu\") and component.gpu.getForeground() ~= c then\13\n        io.stdout:flush()\13\n        component.gpu.setForeground(c)\13\n      end\13\n    end\13\n    local lsd = {}\13\n    local lsf = {}\13\n    local m = 1\13\n    for f in list do\13\n      m = math.max(m, f:len() + 2)\13\n      if f:sub(-1) == \"/\" then\13\n        if options.p then\13\n          table.insert(lsd, f)\13\n        else\13\n          table.insert(lsd, f:sub(1, -2))\13\n        end\13\n      else\13\n        table.insert(lsf, f)\13\n      end\13\n    end\13\n    table.sort(lsd)\13\n    table.sort(lsf)\13\n    setColor(0x66CCFF)\13\n\13\n    local col = 1\13\n    local columns = math.huge\13\n    if component.isAvailable(\"gpu\") and io.output() == io.stdout then\13\n      columns = math.max(1, math.floor((component.gpu.getResolution() - 1) / m))\13\n    end\13\n\13\n    for _, d in ipairs(lsd) do\13\n      if options.a or d:sub(1, 1) ~= \".\" then\13\n        io.write(text.padRight(d, m))\13\n        if options.l or io.output() ~= io.stdout or col % columns == 0 then\13\n          io.write(\"\\n\")\13\n        end\13\n        col = col + 1\13\n      end\13\n    end\13\n\13\n    for _, f in ipairs(lsf) do\13\n      if fs.isLink(fs.concat(path, f)) then\13\n        setColor(0xFFAA00)\13\n      elseif f:sub(-4) == \".lua\" then\13\n        setColor(0x00FF00)\13\n      else\13\n        setColor(0xFFFFFF)\13\n      end\13\n      if options.a or f:sub(1, 1) ~= \".\" then\13\n        io.write(text.padRight(f, m))\13\n        if options.l then\13\n          setColor(0xFFFFFF)\13\n          io.write(fs.size(fs.concat(path, f)), \"\\n\")\13\n        elseif io.output() ~= io.stdout or col % columns == 0 then\13\n          io.write(\"\\n\")\13\n        end\13\n        col = col + 1\13\n      end\13\n    end\13\n\13\n    setColor(0xFFFFFF)\13\n    if options.M then\13\n      io.write(\"\\n\" .. tostring(#lsf) .. \" File(s)\")\13\n      io.write(\"\\n\" .. tostring(#lsd) .. \" Dir(s)\")\13\n    end\13\n    if not options.l then\13\n      io.write(\"\\n\")\13\n    end\13\n  end\13\nend\13\nio.output():setvbuf(\"no\")\13\nio.output():flush()\13\n",["/bin/pwd.lua"]="local shell = require(\"shell\")\13\n\13\nio.write(shell.getWorkingDirectory())",["/bin/rm.lua"]="local shell = require(\"shell\")\13\n\13\nlocal args, options = shell.parse(...)\13\nif #args == 0 then\13\n  io.write(\"Usage: rm [-v] <filename1> [<filename2> [...]]\\n\")\13\n  io.write(\" -v: verbose output.\")\13\n  return\13\nend\13\n\13\nfor i = 1, #args do\13\n  local path = shell.resolve(args[i])\13\n  if not os.remove(path) then\13\n    io.stderr:write(path .. \": no such file, or permission denied\\n\")\13\n  end\13\n  if options.v then\13\n    io.write(\"removed '\" .. path .. \"'\\n\")\13\n  end\13\nend\13\n",["/bin/shutdown.lua"]="local computer = require(\"computer\")\13\nlocal term = require(\"term\")\13\n\13\nterm.clear()\13\ncomputer.shutdown()",["/usr/man/pwd"]="NAME\13\n  pwd - print name of current/working directory\13\n\13\nSYNOPSIS\13\n  pwd\13\n\13\nDESCRIPTION\13\n  `pwd` writes the name of the current working directory to the standard output.\13\n\13\nEXAMPLES\13\n  pwd\13\n    Write the current directory to the terminal.",["/usr/man/redstone"]="NAME\13\n  redstone - access to redstone input and output\13\n\13\nSYNOPSIS\13\n  redstone SIDE\13\n  redstone SIDE VALUE\13\n  redstone SIDE -b COLOR\13\n  redstone SIDE -b COLOR VALUE\13\n\13\nDESCRIPTION\13\n  This program allows manipulating redstone output of the computer via the shell, if it has a built-in redstone card or is connected to a redstone I/O block. It can also be used to just display the current in- and output. If another mod is installed that provides bundled redstone logic, such as RedLogic, MineFactory Reloaded (Rednet Cables) or Project: Red, it can also be used to interact with bundled signals by passing the `-b` flag.\13\n\13\nOPTIONS\13\n  -b\13\n    interact with bundled signals\13\n\13\nEXAMPLES\13\n  redstone front\13\n    Displays the simple in- and output on the front face of a computer with a redstone card.\13\n\13\n  redstone north -b lime 200\13\n    Sets the bundled `lime` output of a redstone I/O block's northern side to 200.",["/usr/man/mkdir"]="NAME\13\n  mkdir - make directories\13\n\13\nSYNOPSIS\13\n  mkdir DIRECTORY...\13\n\13\nDESCRIPTION\13\n  Create the specified directories, if they don't already exist.\13\n\13\nEXAMPLES\13\n  mkdir a\13\n    Create directory `a` in the current directory.\13\n\13\n  mkdir /a/b c\13\n    Create directory `/a` if it doesn't already exists, then create directory `/a/b` and create directory `c` in the current directory.",["/bin/unalias.lua"]="local shell = require(\"shell\")\13\n\13\nlocal args = shell.parse(...)\13\nif #args < 1 then\13\n  io.write(\"Usage: unalias <name>\")\13\n  return\13\nend\13\n\13\nlocal result = shell.getAlias(args[1])\13\nif not result then\13\n  io.stderr:write(\"no such alias\")\13\nelse\13\n  shell.setAlias(args[1], nil)\13\n  io.write(\"alias removed: \" .. args[1] .. \" -> \" .. result)\13\nend",["/usr/man/cat"]="NAME\13\n  cat - concatenate files and print on the standard output\13\n\13\nSYNOPSIS\13\n  cat [FILE]...\13\n\13\nDESCRIPTION\13\n  `cat` allows concatenating files or standard input to standard output.\13\n\13\nEXAMPLES\13\n  cat\13\n    Copy standard input to standard output.\13\n\13\n  cat test.txt\13\n    Output contents of file test.txt.",["/bin/label.lua"]="local fs = require(\"filesystem\")\13\nlocal shell = require(\"shell\")\13\n\13\nlocal args, options = shell.parse(...)\13\nif #args < 1 then\13\n  io.write(\"Usage: label [-a] <fs> [<label>]\\n\")\13\n  io.write(\" -a  File system is specified via label or address instead of by path.\")\13\n  return\13\nend\13\n\13\nlocal proxy, reason\13\nif options.a then\13\n  proxy, reason = fs.proxy(args[1])\13\nelse\13\n  proxy, reason = fs.get(args[1])\13\nend\13\nif not proxy then\13\n  io.stderr:write(reason)\13\n  return\13\nend\13\n\13\nif #args < 2 then\13\n  io.stderr:write(proxy.getLabel() or \"no label\")\13\nelse\13\n  local result, reason = proxy.setLabel(args[2])\13\n  if not result then\13\n    io.stderr:write(reason or \"could not set label\")\13\n  end\13\nend\13\n",["/usr/man/primary"]="NAME\13\n  primary - get or set primary components\13\n\13\nSYNOPSIS\13\n  primary TYPE\13\n  primary TYPE ADDRESS\13\n\13\nDESCRIPTION\13\n  This program allows reading the address of the current primary component of the specified type. It also allows chaning the current primary component for a specified type by providing the (abbreviated) address of the new primary component.\13\n\13\nEXAMPLES\13\n  primary gpu\13\n    Writes the address of the current primary GPU to the standard output.\13\n\13\n  primary gpu 24a\13\n    Makes the GPU of which the address starts with `24a` the new primary GPU.",["/bin/echo.lua"]="local args = table.pack(...)\13\nfor i = 1, #args do\13\n  if i > 1 then\13\n    io.write(\" \")\13\n  end\13\n  io.write(args[i])\13\nend",["/bin/primary.lua"]="local component = require(\"component\")\13\nlocal shell = require(\"shell\")\13\n\13\nlocal args = shell.parse(...)\13\nif #args == 0 then\13\n  io.write(\"Usage: primary <type> [<address>]\\n\")\13\n  io.write(\"Note that the address may be abbreviated.\")\13\n  return\13\nend\13\n\13\nlocal componentType = args[1]\13\n\13\nif #args > 1 then\13\n  local address = args[2]\13\n  if not component.get(address) then\13\n    io.stderr:write(\"no component with this address\")\13\n    return\13\n  else\13\n    component.setPrimary(componentType, address)\13\n    os.sleep(0.1) -- allow signals to be processed\13\n  end\13\nend\13\nif component.isAvailable(componentType) then\13\n  io.write(component.getPrimary(componentType).address)\13\nelse\13\n  io.stderr:write(\"no primary component for this type\")\13\nend\13\n",["/usr/man/alias"]="NAME\13\n  alias - displays and manipulates aliases for programs\13\n\13\nSYNOPSIS\13\n  alias\13\n  alias name\13\n  alias name value\13\n\13\nDESCRIPTION\13\n  `alias` allows listing and editing aliases for programs. An alias is an alternative name that can be used to start a program. A program can have multiple aliases. Aliases can also contain parameters and options to pass to the actual program. An alias can also, in turn, have aliases.\13\n\13\nEXAMPLES\13\n  alias\13\n    Displays the list of all current aliases.\13\n\13\n  alias name\13\n    Displays the value the specified alias, i.e. what the specified alias stands for.\13\n\13\n  alias name value\13\n    Sets the value of the alias with the specified name.",["/usr/man/edit"]="NAME\13\n  edit - primitive file editor\13\n\13\nSYNOPSIS\13\n  edit FILE\13\n\13\nDESCRIPTION\13\n  A very simple text file editor. To create new files with `edit`, open a file in a writable file system that doesn't exist and save.\13\n\13\nOPTIONS\13\n  -r\13\n    opens file as read only\13\n\13\nEXAMPLES\13\n  edit /tmp/test.txt\13\n    Opens the file `/tmp/test.txt` for editing. If it doesn't exists, it will be created upon saving.\13\n\13\n  edit /bin/ls.lua\13\n    Opens the file `/bin/ls.lua`, which will be opened in read-only mode, assuming `/bin` is the default as provided by the read-only-memory.",["/bin/set.lua"]="local args = {...}\13\n\13\nif #args < 1 then\13\n  for k,v in pairs(os.getenv()) do\13\n    io.write(k .. \"='\" .. string.gsub(v, \"'\", [['\"'\"']]) .. \"'\\n\")\13\n  end\13\nelse\13\n  local count = 0 \13\n  for _, expr in ipairs(args) do\13\n    local k, v = string.match(expr, \"(.-)=(.*)\")\13\n    if v then\13\n      os.setenv(k, v)\13\n    else\13\n      if count == 0 then\13\n        for i = 1, os.getenv('#') do\13\n          os.setenv(i, nil)\13\n        end\13\n      end\13\n      count = count + 1\13\n      os.setenv(count, expr)\13\n    end\13\n  end\13\nend\13\n",["/usr/man/clear"]="NAME\13\n  clear - clears the terminal\13\n\13\nSYNOPSIS\13\n  clear\13\n\13\nDESCRIPTION\13\n  Clears any text from the screen, using the current background and foreground (text) colors and resets the cursor position to (1, 1).\13\n\13\nEXAMPLES\13\n  clear\13\n    Clears the screen/",["/bin/cat.lua"]="local shell = require(\"shell\")\13\n\13\nlocal args = shell.parse(...)\13\nif #args == 0 then\13\n  repeat\13\n    local read = io.read(\"*L\")\13\n    if read then\13\n      io.write(read)\13\n    end\13\n  until not read\13\nelse\13\n  for i = 1, #args do\13\n    local file, reason = io.open(shell.resolve(args[i]))\13\n    if not file then\13\n      io.stderr:write(reason)\13\n      return\13\n    end\13\n    repeat\13\n      local line = file:read(\"*L\")\13\n      if line then\13\n        io.write(line)\13\n      end\13\n    until not line\13\n  end\13\nend",["/usr/man/df"]="NAME\13\n  df - report file system disk space usage\13\n\13\nSYNOPSIS\13\n  df [FILE]...\13\n\13\nDESCRIPTION\13\n  `cp` allows copying single files on a filesystem and across filesystems.\13\n\13\nEXAMPLES\13\n  df\13\n    Show global file system disk usage.\13\n\13\n  df /home /var\13\n    Show disk usage of file systems mounted at `/home` and `/var`.",["/usr/man/man"]="NAME\13\n  man - help program, providing help on various programs and topics\13\n\13\nSYNOPSIS\13\n  man topic\13\n\13\nDESCRIPTION\13\n  `man` is the system's help viewer. Each help topic is normally the name of a program or library. Topics are stored as individual text files in the `/usr/man` folder. Additional help topics can be provided by creating a symbolic link to a file. \13\n\13\nEXAMPLES\13\n  man man\13\n    Display the help for the `man` program.\13\n\13\n  man ls\13\n    Display the help for the `ls` program.",["/bin/date.lua"]="io.write(os.date(\"%F %T\"))",["/usr/man/which"]="NAME\13\n  which - locate a command\13\n\13\nSYNOPSIS\13\n  which COMMAND\13\n\13\nDESCRIPTION\13\n  This program writes the full path to each of the specified programs to the standard output. If a program is an alias, this is indicated. If a program cannot be found and error message will be written.\13\n\13\nEXAMPLES\13\n  which ls\13\n    Displays `/bin/ls.lua`.\13\n\13\n  which doesntexist dir\13\n    Displays `doesntexist: file not found` and `dir: aliased to ls`.",["/bin/which.lua"]="local shell = require(\"shell\")\13\n\13\nlocal args = shell.parse(...)\13\nif #args == 0 then\13\n  io.write(\"Usage: which <program>\")\13\n  return\13\nend\13\n\13\nfor i = 1, #args do\13\n  local result, reason = shell.getAlias(args[i])\13\n  if result then\13\n    result = args[i] .. \": aliased to \" .. result\13\n  else\13\n    result, reason = shell.resolve(args[i], \"lua\")\13\n  end\13\n  if result then\13\n    io.write(result .. \"\\n\")\13\n  else\13\n    io.stderr:write(args[i] .. \": \" .. reason .. \"\\n\")\13\n  end\13\nend",["/bin/mount.lua"]="local fs = require(\"filesystem\")\13\nlocal shell = require(\"shell\")\13\n\13\nlocal args = shell.parse(...)\13\nif #args == 0 then\13\n  for proxy, path in fs.mounts() do\13\n    local label = proxy.getLabel() or proxy.address\13\n    local mode = proxy.isReadOnly() and \"ro\" or \"rw\"\13\n    io.write(string.format(\"%s on %s (%s)\\n\", label, path, mode))\13\n  end\13\n  return\13\nend\13\nif #args < 2 then\13\n  io.write(\"Usage: mount [<label|address> <path>]\\n\")\13\n  io.write(\"Note that the address may be abbreviated.\")\13\n  return\13\nend\13\n\13\nlocal proxy, reason = fs.proxy(args[1])\13\nif not proxy then\13\n  io.stderr:write(reason)\13\n  return\13\nend\13\n\13\nlocal result, reason = fs.mount(proxy, shell.resolve(args[2]))\13\nif not result then\13\n  io.stderr:write(reason)\13\nend",["/usr/man/mv"]="NAME\13\n  mv - move (rename) files\13\n\13\nSYNOPSIS\13\n  mv SOURCE DEST\13\n\13\nDESCRIPTION\13\n  Renames files - and folders, as long they remain on the same file system. Files that are 'renamed' to another file system will actually be copied, then deleted.\13\n\13\nOPTIONS\13\n  -f\13\n    do not prompt before overwriting\13\n\13\nEXAMPLES\13\n  mv a b\13\n    Renames file `a` to `b`.\13\n\13\n  mv /home/a /var/b\13\n    Moves file from `/home/a` to `/var/b`.",["/usr/man/date"]="NAME\13\n  date - get the current time and date\13\n\13\nSYNOPSIS\13\n  date\13\n\13\nDESCRIPTION\13\n  Writes the current time and date to the standard output. Note that the time is measured in ingame time, with the date starting on the 1st of January 1970 as the time the world was created.\13\n\13\nEXAMPLES\13\n  date\13\n    Displays the current date and time.",["/usr/man/ln"]="NAME\13\n  ln - creates symbolic links\13\n\13\nSYNOPSIS\13\n  ln FILE [TARGET]\13\n\13\nDESCRIPTION\13\n  `ln` allows creating virtual symbolic links. A symbolic link is a reference in the file system that can be used to point to other nodes in the file system. For example, a symbolic link to a file will behave like that file: it can be opened and changed, where in reality the file the link references is changed. A symbolic link to a directory will behave as such.\13\n\13\n  Note that symbolic links can lead to cycles (recursion) in the file system structure.\13\n\13\n  Symbolic links in OpenOS are 'virtual'. They are not stored on any file system, and as such will not persist across a reboot of the computer. This also means that the can be created in virtual folders, and even on read-only file systems.\13\n\13\nEXAMPLES\13\n  ln /bin/ls.lua\13\n    Creates a symbolic link `ls.lua` to the file `/bin/ls.lua` in the current working directory.\13\n\13\n  ln /home/magic.lua /bin/magic.lua\13\n    Creates a symbolic link to file `/home/magic.lua` in the `/bin` directory.",["/usr/man/userdel"]="NAME\13\n  userdel - removes a player from the list of authorized users\13\n\13\nSYNOPSIS\13\n  userdel NAME\13\n\13\nDESCRIPTION\13\n  Removes a player from the list of users authorized to use this computer. See `useradd`.\13\n\13\nEXAMPLES\13\n  userdel Steve\13\n    Removes the player named `Steve` from the userlist.",["/bin/userdel.lua"]="local computer = require(\"computer\")\13\nlocal shell = require(\"shell\")\13\n\13\nlocal args = shell.parse(...)\13\nif #args < 1 then\13\n  io.write(\"Usage: userdel <name>\")\13\n  return\13\nend\13\n\13\nif not computer.removeUser(args[1]) then\13\n  io.stderr:write(\"no such user\")\13\nend",["/bin/ln.lua"]="local component = require(\"component\")\13\nlocal fs = require(\"filesystem\")\13\nlocal shell = require(\"shell\")\13\n\13\nlocal dirs = shell.parse(...)\13\nif #dirs == 0 then\13\n  io.write(\"Usage: ln <target> [<name>]\")\13\n  return\13\nend\13\n\13\nlocal target = shell.resolve(dirs[1])\13\nlocal linkpath\13\nif #dirs > 1 then\13\n  linkpath = shell.resolve(dirs[2])\13\nelse\13\n  linkpath = fs.concat(shell.getWorkingDirectory(), fs.name(target))\13\nend\13\n\13\nlocal result, reason = fs.link(target, linkpath)\13\nif not result then\13\n  io.stderr:write(reason)\13\nend",["/bin/man.lua"]="local fs = require(\"filesystem\")\13\nlocal shell = require(\"shell\")\13\n\13\nlocal args = shell.parse(...)\13\nif #args == 0 then\13\n  io.write(\"Usage: man <topic>\\n\")\13\n  io.write(\"Where `topic` will usually be the name of a program or library.\")\13\n  return\13\nend\13\n\13\nlocal topic = args[1]\13\nfor path in string.gmatch(os.getenv(\"MANPATH\"), \"[^:]+\") do\13\n  path = shell.resolve(fs.concat(path, topic), \"man\")\13\n  if path and fs.exists(path) and not fs.isDirectory(path) then\13\n    os.execute(os.getenv(\"PAGER\") .. \" \" .. path)\13\n    os.exit()\13\n  end\13\nend\13\nio.stderr:write(\"No manual entry for \" .. topic)",["/bin/useradd.lua"]="local computer = require(\"computer\")\13\nlocal shell = require(\"shell\")\13\n\13\nlocal args = shell.parse(...)\13\nif #args < 1 then\13\n  io.write(\"Usage: useradd <name>\")\13\n  return\13\nend\13\n\13\nlocal result, reason = computer.addUser(args[1])\13\nif not result then\13\n  io.stderr:write(reason)\13\nend",["/usr/man/label"]="NAME\13\n  label - show or change the label of file systems\13\n\13\nSYNOPSIS\13\n  label FILE [STRING]\13\n  label -a ADDRESS [STRING]\13\n\13\nDESCRIPTION\13\n  `label` allows reading and writing the label of file systems. The file system can either be specified by a path to or into a mount, or by its address.\13\n\13\nEXAMPLES\13\n  label /home\13\n    Write the label of the file system mounted at `/home` to the standard output.\13\n\13\n  label -a 93f test\13\n    Change the label of the file system of which the address starts with `93f` to `test`.",["/bin/redstone.lua"]="local colors = require(\"colors\")\13\nlocal component = require(\"component\")\13\nlocal shell = require(\"shell\")\13\nlocal sides = require(\"sides\")\13\n\13\nif not component.isAvailable(\"redstone\") then\13\n  io.stderr:write(\"This program requires a redstone card or redstone I/O block.\")\13\n  return\13\nend\13\nlocal rs = component.redstone\13\n\13\nlocal args, options = shell.parse(...)\13\nif #args == 0 and not options.w and not options.f then\13\n  io.write(\"Usage:\\n\")\13\n  io.write(\"  redstone <side> [<value>]\\n\")\13\n  if rs.setBundledOutput then\13\n    io.write(\"  redstone -b <side> <color> [<value>]\\n\")\13\n  end\13\n  if rs.setWirelessOutput then\13\n    io.write(\"  redstone -w [<value>]\\n\")\13\n    io.write(\"  redstone -f [<frequency>]\\n\")\13\n  end\13\n  return\13\nend\13\n\13\nif options.w then\13\n  if not rs.setWirelessOutput then\13\n    io.stderr:write(\"wireless redstone not available\")\13\n    return\13\n  end\13\n  if #args > 0 then\13\n    local value = args[1]\13\n    if tonumber(value) then\13\n      value = tonumber(value) > 0\13\n    else\13\n      value = ({[\"true\"]=true,[\"on\"]=true,[\"yes\"]=true})[value] ~= nil\13\n    end\13\n    rs.setWirelessOutput(value)\13\n  end\13\n  io.write(\"in: \" .. tostring(rs.getWirelessInput()) .. \"\\n\")\13\n  io.write(\"out: \" .. tostring(rs.getWirelessOutput()))\13\nelseif options.f then\13\n  if not rs.setWirelessOutput then\13\n    io.stderr:write(\"wireless redstone not available\")\13\n    return\13\n  end\13\n  if #args > 0 then\13\n    local value = args[1]\13\n    if not tonumber(value) then\13\n      io.stderr:write(\"invalid frequency\")\13\n      return\13\n    end\13\n    rs.setWirelessFrequency(tonumber(value))\13\n  end\13\n  io.write(\"freq: \" .. tostring(rs.getWirelessFrequency()) .. \"\\n\")\13\nelse\13\n  local side = sides[args[1]]\13\n  if not side then\13\n    io.stderr:write(\"invalid side\")\13\n    return\13\n  end\13\n  if type(side) == \"string\" then\13\n    side = sides[side]\13\n  end\13\n\13\n  if options.b then\13\n    if not rs.setBundledOutput then\13\n      io.stderr:write(\"bundled redstone not available\")\13\n      return\13\n    end\13\n    local color = colors[args[2]]\13\n    if not color then\13\n      io.stderr:write(\"invalid color\")\13\n      return\13\n    end\13\n    if type(color) == \"string\" then\13\n      color = colors[color]\13\n    end\13\n    if #args > 2 then\13\n      local value = args[3]\13\n      if tonumber(value) then\13\n        value = tonumber(value)\13\n      else\13\n        value = ({[\"true\"]=true,[\"on\"]=true,[\"yes\"]=true})[value] and 255 or 0\13\n      end\13\n      rs.setBundledOutput(side, color, value)\13\n    end\13\n    io.write(\"in: \" .. rs.getBundledInput(side, color) .. \"\\n\")\13\n    io.write(\"out: \" .. rs.getBundledOutput(side, color))\13\n  else\13\n    if #args > 1 then\13\n      local value = args[2]\13\n      if tonumber(value) then\13\n        value = tonumber(value)\13\n      else\13\n        value = ({[\"true\"]=true,[\"on\"]=true,[\"yes\"]=true})[value] and 15 or 0\13\n      end\13\n      rs.setOutput(side, value)\13\n    end\13\n    io.write(\"in: \" .. rs.getInput(side) .. \"\\n\")\13\n    io.write(\"out: \" .. rs.getOutput(side))\13\n  end\13\nend",["/bin/more.lua"]="local component = require(\"component\")\13\nlocal event = require(\"event\")\13\nlocal keyboard = require(\"keyboard\")\13\nlocal shell = require(\"shell\")\13\nlocal term = require(\"term\")\13\nlocal text = require(\"text\")\13\nlocal unicode = require(\"unicode\")\13\n\13\nlocal args = shell.parse(...)\13\nif #args == 0 then\13\n  io.write(\"Usage: more <filename1>\")\13\n  return\13\nend\13\n\13\nlocal file, reason = io.open(shell.resolve(args[1]))\13\nif not file then\13\n  io.stderr:write(reason)\13\n  return\13\nend\13\n\13\nlocal function readlines(file, line, num)\13\n  local w, h = component.gpu.getResolution()\13\n  num = num or (h - 1)\13\n  term.setCursorBlink(false)\13\n  for _ = 1, num do\13\n    if not line then\13\n      line = file:read(\"*l\")\13\n      if not line then -- eof\13\n        return nil\13\n      end\13\n    end\13\n    local wrapped\13\n    wrapped, line = text.wrap(text.detab(line), w, w)\13\n    io.write(wrapped .. \"\\n\")\13\n  end\13\n  term.setCursor(1, h)\13\n  term.write(\":\")\13\n  term.setCursorBlink(true)\13\n  return true\13\nend\13\n\13\nlocal line = nil\13\nwhile true do\13\n  term.clear()\13\n  if not readlines(file, line) then\13\n    return\13\n  end\13\n  while true do\13\n    local event, address, char, code = event.pull(\"key_down\")\13\n    if component.isPrimary(address) then\13\n      if code == keyboard.keys.q then\13\n        term.setCursorBlink(false)\13\n        term.clearLine()\13\n        return\13\n      elseif code == keyboard.keys.space or code == keyboard.keys.pageDown then\13\n        break\13\n      elseif code == keyboard.keys.enter or code == keyboard.keys.down then\13\n        term.clearLine()\13\n        if not readlines(file, line, 1) then\13\n          return\13\n        end\13\n      end\13\n    end\13\n  end\13\nend\13\n",["/usr/man/address"]="NAME\13\n  address - display the computer's address\13\n\13\nSYNOPSIS\13\n  address\13\n\13\nDESCRIPTION\13\n  `address` allows printing the computer's component address. This can be useful to quickly look up a computer's address without an Analyzer. Knowing a computer's address can be useful if you wish to directly send network messages between two computers.\13\n\13\nEXAMPLES\13\n  address\13\n    Displays the address of the computer the program is run on.",["/bin/cp.lua"]="local fs = require(\"filesystem\")\13\nlocal shell = require(\"shell\")\13\n\13\nlocal args, options = shell.parse(...)\13\nif #args < 2 then\13\n  io.write(\"Usage: cp [-inrv] <from...> <to>\\n\")\13\n  io.write(\" -i: prompt before overwrite (overrides -n option).\\n\")\13\n  io.write(\" -n: do not overwrite an existing file.\\n\")\13\n  io.write(\" -r: copy directories recursively.\\n\")\13\n  io.write(\" -v: verbose output.\")\13\n  return\13\nend\13\n\13\nlocal from = {}\13\nfor i = 1, #args - 1 do\13\n  table.insert(from, shell.resolve(args[i]))\13\nend\13\nlocal to = shell.resolve(args[#args])\13\n\13\nlocal function status(from, to)\13\n  if options.v then\13\n    print(from .. \" -> \" .. to)\13\n  end\13\n  os.sleep(0) -- allow interrupting\13\nend\13\n\13\nlocal result, reason\13\n\13\nlocal function prompt(message)\13\n  io.write(message .. \" \")\13\n  local result = io.read()\13\n  return result and result:sub(1, 1):lower() == \"y\"\13\nend\13\n\13\nlocal function recurse(fromPath, toPath)\13\n  status(fromPath, toPath)\13\n  if fs.isDirectory(fromPath) then\13\n    if not options.r then\13\n      io.write(\"omitting directory `\" .. fromPath .. \"'\\n\")\13\n      return true\13\n    end\13\n    if fs.canonical(fromPath) == fs.canonical(fs.path(toPath)) then\13\n      return nil, \"cannot copy a directory, `\" .. fromPath .. \"', into itself, `\" .. toPath .. \"'\\n\"\13\n    end\13\n    if fs.exists(toPath) and not fs.isDirectory(toPath) then\13\n      -- my real cp always does this, even with -f, -n or -i.\13\n      return nil, \"cannot overwrite non-directory `\" .. toPath .. \"' with directory `\" .. fromPath .. \"'\"\13\n    end\13\n    fs.makeDirectory(toPath)\13\n    for file in fs.list(fromPath) do\13\n      local result, reason = recurse(fs.concat(fromPath, file), fs.concat(toPath, file))\13\n      if not result then\13\n        return nil, reason\13\n      end\13\n    end\13\n    return true\13\n  else\13\n    if fs.exists(toPath) then\13\n      if fs.canonical(fromPath) == fs.canonical(toPath) then\13\n        return nil, \"`\" .. fromPath .. \"' and `\" .. toPath .. \"' are the same file\"\13\n      end\13\n      if fs.isDirectory(toPath) then\13\n        if options.i then\13\n          if not prompt(\"overwrite `\" .. toPath .. \"'?\") then\13\n            return true\13\n          end\13\n        elseif options.n then\13\n          return true\13\n        else -- yes, even for -f\13\n          return nil, \"cannot overwrite directory `\" .. toPath .. \"' with non-directory\"\13\n        end\13\n      else\13\n        if options.i then\13\n          if not prompt(\"overwrite `\" .. toPath .. \"'?\") then\13\n            return true\13\n          end\13\n        elseif options.n then\13\n          return true\13\n        end\13\n        -- else: default to overwriting\13\n      end\13\n      fs.remove(toPath)\13\n    end\13\n    return fs.copy(fromPath, toPath)\13\n  end\13\nend\13\nfor _, fromPath in ipairs(from) do\13\n  local toPath = to\13\n  if fs.isDirectory(toPath) then\13\n    toPath = fs.concat(toPath, fs.name(fromPath))\13\n  end\13\n  result, reason = recurse(fromPath, toPath)\13\n  if not result then\13\n    error(reason, 0)\13\n  end\13\nend",["/usr/man/mount"]="NAME\13\n  mount - mount a file system\13\n\13\nSYNOPSIS\13\n  mount\13\n  mount LABEL PATH\13\n  mount ADDRESS PATH\13\n\13\nDESCRIPTION\13\n  All files accessible in OpenOS are arranged in one big tree, starting with the root node, '/'. The files are the leaves of the tree, directories are inner nodes of the tree. Files can be distributed across several devices (file system components, such as hard drives and floppies). The `mount` command is used to attach a file system to this tree. The `umount` command can be used to remove a mounted file system from the tree (note that `rm` works for this, too).\13\n\13\nEXAMPLES\13\n  mount\13\n    Display a list of all currently mounted file systems.\13\n\13\n  mount test /home\13\n    Mounts the file system labeled `test` at `/home`.\13\n\13\n  mount 56f /var\13\n    Mounts the file system of which the address starts with `56f` at `/var`.",["/usr/man/resolution"]="NAME\13\n  resolution - get or set screen resolution\13\n\13\nSYNOPSIS\13\n  resolution\13\n  resolution WIDTH HEIGHT\13\n\13\nDESCRIPTION\13\n  The `resolution` program is used to write the resolution of the current primary screen to the standard output, or to change the resolution to a new value.\13\n\13\nEXAMPLES\13\n  resolution\13\n    Displays the current screen resolution.\13\n\13\n  resoltution 30 10\13\n    Sets the screen's resolution to 30 by 10 characters.",["/usr/man/rm"]="NAME\13\n  rm - remove files or directories\13\n\13\nSYNOPSIS\13\n  rm FILE...\13\n\13\nDESCRIPTION\13\n  Removes all of the specified files, one by one. Can also be used to remove directories, mounts and symlinks.\13\n\13\nEXAMPLES\13\n  rm a\13\n    Deletes the file `a`.",["/usr/man/echo"]="NAME\13\n  echo - display a line of test\13\n\13\nSYNOPSIS\13\n  echo [STRING]...\13\n\13\nDESCRIPTION\13\n  `echo` writes the provided string(s) to the standard output.\13\n\13\nEXAMPLES\13\n  echo test\13\n    Print `test` to the terminal.\13\n\13\n  echo \"a   b\" > test\13\n    Writes the string `a   b` to the standard output, which is redirected into file `test`.",["/usr/man/lua"]="NAME\13\n  lua - a simple Lua interpreter\13\n\13\nSYNOPSIS\13\n  lua\13\n\13\nDESCRIPTION\13\n  Launches a command line that can be used to evaluate Lua statements and expressions. This can be very useful for testing out commands. Note that the interpreter will automatically try to resolve undefined globals using `require`, i.e. it will try to load a package with the specified name.\13\n\13\nEXAMPLES\13\n  lua\13\n    Launches the Lua interpreter.",["/usr/man/unalias"]="NAME\13\n  unalias - removes aliases for programs\13\n\13\nSYNOPSIS\13\n  unalias name\13\n\13\nDESCRIPTION\13\n  Allows removal of aliases created with the `alias` command.\13\n\13\nEXAMPLES\13\n  unalias dir\13\n    Removes the `dir` alias (usually an alias for `ls`)."},name="binaries",conflicts={},depends={"init","libprocess"},version="0.1"}