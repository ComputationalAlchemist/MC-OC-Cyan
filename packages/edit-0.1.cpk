{version="0.1",name="edit",depends={"init"},contents={["/usr/man/edit"]="NAME\13\n  edit - primitive file editor\13\n\13\nSYNOPSIS\13\n  edit FILE\13\n\13\nDESCRIPTION\13\n  A very simple text file editor. To create new files with `edit`, open a file in a writable file system that doesn't exist and save.\13\n\13\nOPTIONS\13\n  -r\13\n    opens file as read only\13\n\13\nEXAMPLES\13\n  edit /tmp/test.txt\13\n    Opens the file `/tmp/test.txt` for editing. If it doesn't exists, it will be created upon saving.\13\n\13\n  edit /bin/ls.lua\13\n    Opens the file `/bin/ls.lua`, which will be opened in read-only mode, assuming `/bin` is the default as provided by the read-only-memory.",["/bin/edit.lua"]="local component = require(\"component\")\13\nlocal event = require(\"event\")\13\nlocal fs = require(\"filesystem\")\13\nlocal keyboard = require(\"keyboard\")\13\nlocal shell = require(\"shell\")\13\nlocal term = require(\"term\")\13\nlocal text = require(\"text\")\13\nlocal unicode = require(\"unicode\")\13\n\13\nif not term.isAvailable() then\13\n  return\13\nend\13\n\13\nlocal args, options = shell.parse(...)\13\nif #args == 0 then\13\n  io.write(\"Usage: edit <filename>\")\13\n  return\13\nend\13\n\13\nlocal filename = shell.resolve(args[1])\13\n\13\nlocal readonly = options.r or fs.get(filename) == nil or fs.get(filename).isReadOnly()\13\n\13\nif not fs.exists(filename) then\13\n  if fs.isDirectory(filename) then\13\n    io.stderr:write(\"file is a directory\")\13\n    return\13\n  elseif readonly then\13\n    io.stderr:write(\"file system is read only\")\13\n    return\13\n  end\13\nend\13\n\13\nterm.clear()\13\nterm.setCursorBlink(true)\13\n\13\nlocal running = true\13\nlocal buffer = {}\13\nlocal scrollX, scrollY = 0, 0\13\n\13\n-------------------------------------------------------------------------------\13\n\13\nlocal function setStatus(value)\13\n  local w, h = component.gpu.getResolution()\13\n  component.gpu.set(1, h, text.padRight(unicode.sub(value, 1, w - 10), w - 10))\13\nend\13\n\13\nlocal function getSize()\13\n  local w, h = component.gpu.getResolution()\13\n  return w, h - 1\13\nend\13\n\13\nlocal function getCursor()\13\n  local cx, cy = term.getCursor()\13\n  return cx + scrollX, cy + scrollY\13\nend\13\n\13\nlocal function line()\13\n  local cbx, cby = getCursor()\13\n  return buffer[cby]\13\nend\13\n\13\nlocal function setCursor(nbx, nby)\13\n  local w, h = getSize()\13\n  nby = math.max(1, math.min(#buffer, nby))\13\n\13\n  local ncy = nby - scrollY\13\n  if ncy > h then\13\n    term.setCursorBlink(false)\13\n    local sy = nby - h\13\n    local dy = math.abs(scrollY - sy)\13\n    scrollY = sy\13\n    component.gpu.copy(1, 1 + dy, w, h - dy, 0, -dy)\13\n    for by = nby - (dy - 1), nby do\13\n      local str = text.padRight(unicode.sub(buffer[by], 1 + scrollX), w)\13\n      component.gpu.set(1, by - scrollY, str)\13\n    end\13\n  elseif ncy < 1 then\13\n    term.setCursorBlink(false)\13\n    local sy = nby - 1\13\n    local dy = math.abs(scrollY - sy)\13\n    scrollY = sy\13\n    component.gpu.copy(1, 1, w, h - dy, 0, dy)\13\n    for by = nby, nby + (dy - 1) do\13\n      local str = text.padRight(unicode.sub(buffer[by], 1 + scrollX), w)\13\n      component.gpu.set(1, by - scrollY, str)\13\n    end\13\n  end\13\n  term.setCursor(term.getCursor(), nby - scrollY)\13\n\13\n  nbx = math.max(1, math.min(unicode.len(line()) + 1, nbx))\13\n  local ncx = nbx - scrollX\13\n  if ncx > w then\13\n    term.setCursorBlink(false)\13\n    local sx = nbx - w\13\n    local dx = math.abs(scrollX - sx)\13\n    scrollX = sx\13\n    component.gpu.copy(1 + dx, 1, w - dx, h, -dx, 0)\13\n    for by = 1 + scrollY, math.min(h + scrollY, #buffer) do\13\n      local str = unicode.sub(buffer[by], nbx - (dx - 1), nbx)\13\n      str = text.padRight(str, dx)\13\n      component.gpu.set(1 + (w - dx), by - scrollY, str)\13\n    end\13\n  elseif ncx < 1 then\13\n    term.setCursorBlink(false)\13\n    local sx = nbx - 1\13\n    local dx = math.abs(scrollX - sx)\13\n    scrollX = sx\13\n    component.gpu.copy(1, 1, w - dx, h, dx, 0)\13\n    for by = 1 + scrollY, math.min(h + scrollY, #buffer) do\13\n      local str = unicode.sub(buffer[by], nbx, nbx + dx)\13\n      --str = text.padRight(str, dx)\13\n      component.gpu.set(1, by - scrollY, str)\13\n    end\13\n  end\13\n  term.setCursor(nbx - scrollX, nby - scrollY)\13\n\13\n  component.gpu.set(w - 9, h + 1, text.padLeft(string.format(\"%d,%d\", nby, nbx), 10))\13\nend\13\n\13\nlocal function home()\13\n  local cbx, cby = getCursor()\13\n  setCursor(1, cby)\13\nend\13\n\13\nlocal function ende()\13\n  local cbx, cby = getCursor()\13\n  setCursor(unicode.len(line()) + 1, cby)\13\nend\13\n\13\nlocal function left()\13\n  local cbx, cby = getCursor()\13\n  if cbx > 1 then\13\n    setCursor(cbx - 1, cby)\13\n    return true -- for backspace\13\n  elseif cby > 1 then\13\n    setCursor(cbx, cby - 1)\13\n    ende()\13\n    return true -- again, for backspace\13\n  end\13\nend\13\n\13\nlocal function right(n)\13\n  n = n or 1\13\n  local cbx, cby = getCursor()\13\n  local be = unicode.len(line()) + 1\13\n  if cbx < be then\13\n    setCursor(cbx + n, cby)\13\n  elseif cby < #buffer then\13\n    setCursor(1, cby + 1)\13\n  end\13\nend\13\n\13\nlocal function up(n)\13\n  n = n or 1\13\n  local cbx, cby = getCursor()\13\n  if cby > 1 then\13\n    setCursor(cbx, cby - n)\13\n    if getCursor() > unicode.len(line()) then\13\n      ende()\13\n    end\13\n  end\13\nend\13\n\13\nlocal function down(n)\13\n  n = n or 1\13\n  local cbx, cby = getCursor()\13\n  if cby < #buffer then\13\n    setCursor(cbx, cby + n)\13\n    if getCursor() > unicode.len(line()) then\13\n      ende()\13\n    end\13\n  end\13\nend\13\n\13\nlocal function delete()\13\n  local cx, cy = term.getCursor()\13\n  local cbx, cby = getCursor()\13\n  local w, h = getSize()\13\n  if cbx <= unicode.len(line()) then\13\n    term.setCursorBlink(false)\13\n    buffer[cby] = unicode.sub(line(), 1, cbx - 1) ..\13\n                  unicode.sub(line(), cbx + 1)\13\n    component.gpu.copy(cx + 1, cy, w - cx, 1, -1, 0)\13\n    local br = cbx + (w - cx)\13\n    local char = unicode.sub(line(), br, br)\13\n    if not char or unicode.len(char) == 0 then\13\n      char = \" \"\13\n    end\13\n    component.gpu.set(w, cy, char)\13\n  elseif cby < #buffer then\13\n    term.setCursorBlink(false)\13\n    local append = table.remove(buffer, cby + 1)\13\n    buffer[cby] = buffer[cby] .. append\13\n    component.gpu.set(cx, cy, append)\13\n    if cy < h then\13\n      component.gpu.copy(1, cy + 2, w, h - (cy + 1), 0, -1)\13\n      component.gpu.set(1, h, text.padRight(buffer[cby + (h - cy)], w))\13\n    end\13\n    setStatus(\"Save: [Ctrl+S] Close: [Ctrl+W]\")\13\n  end\13\nend\13\n\13\nlocal function insert(value)\13\n  if not value or unicode.len(value) < 1 then\13\n    return\13\n  end\13\n  term.setCursorBlink(false)\13\n  local cx, cy = term.getCursor()\13\n  local cbx, cby = getCursor()\13\n  local w, h = getSize()\13\n  buffer[cby] = unicode.sub(line(), 1, cbx - 1) ..\13\n                value ..\13\n                unicode.sub(line(), cbx)\13\n  local len = unicode.len(value)\13\n  local n = w - (cx - 1) - len\13\n  if n > 0 then\13\n    component.gpu.copy(cx, cy, n, 1, len, 0)\13\n  end\13\n  component.gpu.set(cx, cy, value)\13\n  right(len)\13\n  setStatus(\"Save: [Ctrl+S] Close: [Ctrl+W]\")\13\nend\13\n\13\nlocal function enter()\13\n  term.setCursorBlink(false)\13\n  local cx, cy = term.getCursor()\13\n  local cbx, cby = getCursor()\13\n  local w, h = getSize()\13\n  table.insert(buffer, cby + 1, unicode.sub(buffer[cby], cbx))\13\n  buffer[cby] = unicode.sub(buffer[cby], 1, cbx - 1)\13\n  component.gpu.fill(cx, cy, w - (cx - 1), 1, \" \")\13\n  if cy < h then\13\n    if cy < h - 1 then\13\n      component.gpu.copy(1, cy + 1, w, h - (cy + 1), 0, 1)\13\n    end\13\n    component.gpu.set(1, cy + 1, text.padRight(buffer[cby + 1], w))\13\n  end\13\n  setCursor(1, cby + 1)\13\n  setStatus(\"Save: [Ctrl+S] Close: [Ctrl+W]\")\13\nend\13\n\13\nlocal controlKeyCombos = {[keyboard.keys.s]=true,[keyboard.keys.w]=true,\13\n                          [keyboard.keys.c]=true,[keyboard.keys.x]=true}\13\nlocal function onKeyDown(char, code)\13\n  if code == keyboard.keys.back and not readonly then\13\n    if left() then\13\n      delete()\13\n    end\13\n  elseif code == keyboard.keys.delete and not readonly then\13\n    delete()\13\n  elseif code == keyboard.keys.left then\13\n    left()\13\n  elseif code == keyboard.keys.right then\13\n    right()\13\n  elseif code == keyboard.keys.home then\13\n    home()\13\n  elseif code == keyboard.keys[\"end\"] then\13\n    ende()\13\n  elseif code == keyboard.keys.up then\13\n    up()\13\n  elseif code == keyboard.keys.down then\13\n    down()\13\n  elseif code == keyboard.keys.pageUp then\13\n    local w, h = getSize()\13\n    up(h - 1)\13\n  elseif code == keyboard.keys.pageDown then\13\n    local w, h = getSize()\13\n    down(h - 1)\13\n  elseif code == keyboard.keys.enter and not readonly then\13\n    enter()\13\n  elseif keyboard.isControlDown() and controlKeyCombos[code] then\13\n    local cbx, cby = getCursor()\13\n    if code == keyboard.keys.s and not readonly then\13\n      local new = not fs.exists(filename)\13\n      local f, reason = io.open(filename, \"w\")\13\n      if f then\13\n        local chars, firstLine = 0, true\13\n        for _, line in ipairs(buffer) do\13\n          if not firstLine then\13\n            line = \"\\n\" .. line\13\n          end\13\n          firstLine = false\13\n          f:write(line)\13\n          chars = chars + unicode.len(line)\13\n        end\13\n        f:close()\13\n        local format\13\n        if new then\13\n          format = [[\"%s\" [New] %dL,%dC written]]\13\n        else\13\n          format = [[\"%s\" %dL,%dC written]]\13\n        end\13\n        setStatus(string.format(format, fs.name(filename), #buffer, chars))\13\n      else\13\n        setStatus(reason)\13\n      end\13\n    elseif code == keyboard.keys.w or\13\n           code == keyboard.keys.c or\13\n           code == keyboard.keys.x\13\n    then\13\n      -- TODO ask to save if changed\13\n      running = false\13\n    end\13\n  elseif readonly and code == keyboard.keys.q then\13\n    running = false\13\n  elseif not readonly then\13\n    if not keyboard.isControl(char) then\13\n      insert(unicode.char(char))\13\n    elseif unicode.char(char) == \"\\t\" then\13\n      insert(\"  \")\13\n    end\13\n  end\13\nend\13\n\13\nlocal function onClipboard(value)\13\n  local cbx, cby = getCursor()\13\n  local start = 1\13\n  local l = value:find(\"\\n\", 1, true)\13\n  if l then\13\n    repeat\13\n      insert(string.sub(value, start, l - 1))\13\n      enter()\13\n      start = l + 1\13\n      l = value:find(\"\\n\", start, true)\13\n    until not l\13\n  end\13\n  insert(string.sub(value, start))\13\nend\13\n\13\nlocal function onClick(x, y)\13\n  setCursor(x + scrollX, y + scrollY)\13\nend\13\n\13\nlocal function onScroll(direction)\13\n  local cbx, cby = getCursor()\13\n  setCursor(cbx, cby - direction * 12)\13\nend\13\n\13\n-------------------------------------------------------------------------------\13\n\13\ndo\13\n  local f = io.open(filename)\13\n  if f then\13\n    local w, h = getSize()\13\n    local chars = 0\13\n    for line in f:lines() do\13\n      if line:sub(-1) == \"\\r\" then\13\n        line = line:sub(1, -2)\13\n      end\13\n      table.insert(buffer, line)\13\n      chars = chars + unicode.len(line)\13\n      if #buffer <= h then\13\n        component.gpu.set(1, #buffer, line)\13\n      end\13\n    end\13\n    f:close()\13\n    if #buffer == 0 then\13\n      table.insert(buffer, \"\")\13\n    end\13\n    local format\13\n    if readonly then\13\n      format = [[\"%s\" [readonly] %dL,%dC]]\13\n    else\13\n      format = [[\"%s\" %dL,%dC]]\13\n    end\13\n    setStatus(string.format(format, fs.name(filename), #buffer, chars))\13\n  else\13\n    table.insert(buffer, \"\")\13\n    setStatus(string.format([[\"%s\" [New File] ]], fs.name(filename)))\13\n  end\13\n  setCursor(1, 1)\13\nend\13\n\13\nwhile running do\13\n  local event, address, arg1, arg2, arg3 = event.pull()\13\n  if type(address) == \"string\" and component.isPrimary(address) then\13\n    local blink = true\13\n    if event == \"key_down\" then\13\n      onKeyDown(arg1, arg2)\13\n    elseif event == \"clipboard\" and not readonly then\13\n      onClipboard(arg1)\13\n    elseif event == \"touch\" or event == \"drag\" then\13\n      onClick(arg1, arg2)\13\n    elseif event == \"scroll\" then\13\n      onScroll(arg3)\13\n    else\13\n      blink = false\13\n    end\13\n    if blink then\13\n      term.setCursorBlink(true)\13\n      term.setCursorBlink(true) -- force toggle to caret\13\n    end\13\n  end\13\nend\13\n\13\nterm.clear()\13\nterm.setCursorBlink(false)\13\n"},conflicts={}}