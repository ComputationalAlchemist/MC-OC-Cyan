{version="0.1",name="redstone",depends={"init","libcolors","libsides"},contents={["/usr/man/redstone"]="NAME\13\n  redstone - access to redstone input and output\13\n\13\nSYNOPSIS\13\n  redstone SIDE\13\n  redstone SIDE VALUE\13\n  redstone SIDE -b COLOR\13\n  redstone SIDE -b COLOR VALUE\13\n\13\nDESCRIPTION\13\n  This program allows manipulating redstone output of the computer via the shell, if it has a built-in redstone card or is connected to a redstone I/O block. It can also be used to just display the current in- and output. If another mod is installed that provides bundled redstone logic, such as RedLogic, MineFactory Reloaded (Rednet Cables) or Project: Red, it can also be used to interact with bundled signals by passing the `-b` flag.\13\n\13\nOPTIONS\13\n  -b\13\n    interact with bundled signals\13\n\13\nEXAMPLES\13\n  redstone front\13\n    Displays the simple in- and output on the front face of a computer with a redstone card.\13\n\13\n  redstone north -b lime 200\13\n    Sets the bundled `lime` output of a redstone I/O block's northern side to 200.",["/bin/redstone.lua"]="local colors = require(\"colors\")\13\nlocal component = require(\"component\")\13\nlocal shell = require(\"shell\")\13\nlocal sides = require(\"sides\")\13\n\13\nif not component.isAvailable(\"redstone\") then\13\n  io.stderr:write(\"This program requires a redstone card or redstone I/O block.\")\13\n  return\13\nend\13\nlocal rs = component.redstone\13\n\13\nlocal args, options = shell.parse(...)\13\nif #args == 0 and not options.w and not options.f then\13\n  io.write(\"Usage:\\n\")\13\n  io.write(\"  redstone <side> [<value>]\\n\")\13\n  if rs.setBundledOutput then\13\n    io.write(\"  redstone -b <side> <color> [<value>]\\n\")\13\n  end\13\n  if rs.setWirelessOutput then\13\n    io.write(\"  redstone -w [<value>]\\n\")\13\n    io.write(\"  redstone -f [<frequency>]\\n\")\13\n  end\13\n  return\13\nend\13\n\13\nif options.w then\13\n  if not rs.setWirelessOutput then\13\n    io.stderr:write(\"wireless redstone not available\")\13\n    return\13\n  end\13\n  if #args > 0 then\13\n    local value = args[1]\13\n    if tonumber(value) then\13\n      value = tonumber(value) > 0\13\n    else\13\n      value = ({[\"true\"]=true,[\"on\"]=true,[\"yes\"]=true})[value] ~= nil\13\n    end\13\n    rs.setWirelessOutput(value)\13\n  end\13\n  io.write(\"in: \" .. tostring(rs.getWirelessInput()) .. \"\\n\")\13\n  io.write(\"out: \" .. tostring(rs.getWirelessOutput()))\13\nelseif options.f then\13\n  if not rs.setWirelessOutput then\13\n    io.stderr:write(\"wireless redstone not available\")\13\n    return\13\n  end\13\n  if #args > 0 then\13\n    local value = args[1]\13\n    if not tonumber(value) then\13\n      io.stderr:write(\"invalid frequency\")\13\n      return\13\n    end\13\n    rs.setWirelessFrequency(tonumber(value))\13\n  end\13\n  io.write(\"freq: \" .. tostring(rs.getWirelessFrequency()) .. \"\\n\")\13\nelse\13\n  local side = sides[args[1]]\13\n  if not side then\13\n    io.stderr:write(\"invalid side\")\13\n    return\13\n  end\13\n  if type(side) == \"string\" then\13\n    side = sides[side]\13\n  end\13\n\13\n  if options.b then\13\n    if not rs.setBundledOutput then\13\n      io.stderr:write(\"bundled redstone not available\")\13\n      return\13\n    end\13\n    local color = colors[args[2]]\13\n    if not color then\13\n      io.stderr:write(\"invalid color\")\13\n      return\13\n    end\13\n    if type(color) == \"string\" then\13\n      color = colors[color]\13\n    end\13\n    if #args > 2 then\13\n      local value = args[3]\13\n      if tonumber(value) then\13\n        value = tonumber(value)\13\n      else\13\n        value = ({[\"true\"]=true,[\"on\"]=true,[\"yes\"]=true})[value] and 255 or 0\13\n      end\13\n      rs.setBundledOutput(side, color, value)\13\n    end\13\n    io.write(\"in: \" .. rs.getBundledInput(side, color) .. \"\\n\")\13\n    io.write(\"out: \" .. rs.getBundledOutput(side, color))\13\n  else\13\n    if #args > 1 then\13\n      local value = args[2]\13\n      if tonumber(value) then\13\n        value = tonumber(value)\13\n      else\13\n        value = ({[\"true\"]=true,[\"on\"]=true,[\"yes\"]=true})[value] and 15 or 0\13\n      end\13\n      rs.setOutput(side, value)\13\n    end\13\n    io.write(\"in: \" .. rs.getInput(side) .. \"\\n\")\13\n    io.write(\"out: \" .. rs.getOutput(side))\13\n  end\13\nend"},conflicts={}}