{name="libinternet",contents={["/lib/internet.lua"]="local buffer = require(\"buffer\")\13\nlocal component = require(\"component\")\13\nlocal event = require(\"event\")\13\n\13\nlocal internet = {}\13\n\13\n-------------------------------------------------------------------------------\13\n\13\nfunction internet.request(url, data)\13\n  checkArg(1, url, \"string\")\13\n  checkArg(2, data, \"string\", \"table\", \"nil\")\13\n\13\n  local inet = component.internet\13\n  if not inet then\13\n    error(\"no primary internet card found\", 2)\13\n  end\13\n\13\n  local post\13\n  if type(data) == \"string\" then\13\n    post = data\13\n  elseif type(data) == \"table\" then\13\n    for k, v in pairs(data) do\13\n      post = post and (post .. \"&\") or \"\"\13\n      post = post .. tostring(k) .. \"=\" .. tostring(v)\13\n    end\13\n  end\13\n\13\n  local result, reason = inet.request(url, post)\13\n  if not result then\13\n    error(reason, 2)\13\n  end\13\n\13\n  local handle = setmetatable({value=result}, {__gc=function(self)\13\n    pcall(inet.close, self.value)\13\n  end})\13\n\13\n  return function()\13\n    while true do\13\n      local data, reason = inet.read(handle.value)\13\n      if not data then\13\n        inet.close(handle.value)\13\n        if reason then\13\n          error(reason, 2)\13\n        else\13\n          return nil -- eof\13\n        end\13\n      elseif #data > 0 then\13\n        return data\13\n      end\13\n      -- else: no data, block\13\n    end\13\n  end\13\nend\13\n\13\n-------------------------------------------------------------------------------\13\n\13\nlocal socketStream = {}\13\n\13\nfunction socketStream:close()\13\n  if self.handle then\13\n    self.inet.close(self.handle)\13\n    self.handle = nil\13\n  end\13\nend\13\n\13\nfunction socketStream:seek()\13\n  return nil, \"bad file descriptor\"\13\nend\13\n\13\nfunction socketStream:read(n)\13\n  if not self.handle then\13\n    return nil, \"connection is closed\"\13\n  end\13\n  return self.inet.read(self.handle, n)\13\nend\13\n\13\nfunction socketStream:write(value)\13\n  if not self.handle then\13\n    return nil, \"connection is closed\"\13\n  end\13\n  while #value > 0 do\13\n    local written, reason = self.inet.write(self.handle, value)\13\n    if not written then\13\n      return nil, reason\13\n    end\13\n    value = string.sub(value, written + 1)\13\n  end\13\n  return true\13\nend\13\n\13\nfunction internet.socket(address, port)\13\n  checkArg(1, address, \"string\")\13\n  checkArg(2, port, \"number\", \"nil\")\13\n  if port then\13\n    address = address .. \":\" .. port\13\n  end\13\n\13\n  local inet = component.internet\13\n  local handle, reason = inet.connect(address)\13\n  if not handle then\13\n    return nil, reason\13\n  end\13\n\13\n  local stream = {inet = inet, handle = handle}\13\n\13\n  -- stream:close does a syscall, which yields, and that's not possible in\13\n  -- the __gc metamethod. So we start a timer to do the yield/cleanup.\13\n  local function cleanup(self)\13\n    if not self.handle then return end\13\n    pcall(self.inet.close, self.handle)\13\n  end\13\n  local metatable = {__index = socketStream,\13\n                     __gc = cleanup,\13\n                     __metatable = \"socketstream\"}\13\n  return setmetatable(stream, metatable)\13\nend\13\n\13\nfunction internet.open(address, port)\13\n  local stream, reason = internet.socket(address, port)\13\n  if not stream then\13\n    return nil, reason\13\n  end\13\n  return buffer.new(\"rwb\", stream)\13\nend\13\n\13\n-------------------------------------------------------------------------------\13\n\13\nreturn internet"},depends={"init"},version="0.1",conflicts={}}