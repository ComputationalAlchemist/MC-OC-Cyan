{contents={["/usr/lib/cptpack.lua"]="local cptpack = {}\13\nlocal filesystem = require(\"filesystem\")\13\nlocal cyan = require(\"cyan\")\13\nlocal shell = require(\"shell\")\13\n\13\ncptpack.root = \"/\"\13\nfunction cptpack.toroot(file)\13\n\9if file:sub(1, 1) == \"/\" then\13\n\9\9return filesystem.concat(cptpack.root, file:sub(2))\13\n\9else\13\n\9\9return file\13\n\9end\13\nend\13\n\13\nfunction cptpack.loadindex(path)\13\n\9local data = cyan.readserialized(path)\13\n\9data.listing = cyan.keylist(data.contents)\13\n\9data.contents = nil\13\n\9return data\13\nend\13\n\13\nlocal function tryremoveparents(file)\13\n\9local parent = filesystem.path(file)\13\n\9if cyan.isDirectoryEmpty(parent) then\13\n\9\9print(\"Parent directory is no longer in use:\", parent)\13\n\9\9filesystem.remove(parent)\13\n\9\9tryremoveparents(parent)\13\n\9end\13\nend\13\n\13\nfunction cptpack.uninstall(name, index)\13\n\9assert(name == index.name .. \"-\" .. index.version)\13\n\9print(\"Uninstalling\", name)\13\n\9for i, file in ipairs(index.listing) do\13\n\9\9if not filesystem.exists(cptpack.toroot(file)) then\13\n\9\9\9print(\"Would remove\", cptpack.toroot(file), \"but it didn't exist.\")\13\n\9\9else\13\n\9\9\9print(\"Removing\", cptpack.toroot(file))\13\n\9\9\9if file:sub(1, 1) ~= \"/\" then\13\n\9\9\9\9error(\"Invalid path - no leading slash!\")\13\n\9\9\9end\13\n\9\9\9cyan.removeSingleFile(cptpack.toroot(file))\13\n\9\9\9tryremoveparents(cptpack.toroot(file))\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction cptpack.install(pname, path)\13\n\9local data = cyan.readserialized(path)\13\n\9assert(pname == data.name .. \"-\" .. data.version)\13\n\9print(\"Installing\", pname)\13\n\9for name, data in pairs(data.contents) do\13\n\9\9if name:sub(1, 1) ~= \"/\" then\13\n\9\9\9error(\"Invalid path - no leading slash!\")\13\n\9\9end\13\n\9\9print(\"Adding\", cptpack.toroot(name))\13\n\9\9if filesystem.exists(cptpack.toroot(name)) then\13\n\9\9\9error(\"File already exists!\")\13\n\9\9end\13\n\9\9cyan.makeParentDirectory(cptpack.toroot(name))\13\n\9\9cyan.writeall(cptpack.toroot(name), data)\13\n\9end\13\nend\13\n\13\nfunction cptpack.makepkg(dir) -- Ignores root\13\n\9dir = filesystem.concat(shell.getWorkingDirectory(), dir)\13\n\9local loaded, err = loadfile(filesystem.concat(dir, \"PACKBUILD\"))\13\n\9if not loaded then\13\n\9\9error(\"Cannot load PACKBUILD: \" .. err)\13\n\9end\13\n\9local config = loaded(dir, fileout)\13\n\9local pack = config.package or {}\13\n\9if not pack.contents then pack.contents = {} end\13\n\9for target, source in pairs(config.include or {}) do\13\n\9\9if source:sub(1, 1) == \"/\" then\13\n\9\9\9pack.contents[target] = cyan.readall(source)\13\n\9\9else\13\n\9\9\9pack.contents[target] = cyan.readall(filesystem.concat(dir, source))\13\n\9\9end\13\n\9end\13\n\9for _, field in ipairs({\"name\", \"version\", \"depends\", \"conflicts\"}) do\13\n\9\9if config[field] then\13\n\9\9\9assert(pack[field] == nil)\13\n\9\9\9pack[field] = config[field]\13\n\9\9end\13\n\9\9assert(pack[field], \"No package \" .. field .. \"!\")\13\n\9end\13\n\9return pack\13\nend\13\n\13\nfunction cptpack.buildpkg(dir, fileout) -- Ignores root\13\n\9cyan.writeserialized(fileout, cptpack.makepkg(dir))\13\nend\13\n\13\nreturn cptpack",["/usr/lib/cptinstall.lua"]="local filesystem = require(\"filesystem\")\13\nlocal cyan = require(\"cyan\")\13\nlocal cptcache = require(\"cptcache\")\13\nlocal cptpack = require(\"cptpack\")\13\n\13\nlocal cptinstall = {}\13\nlocal context = {}\13\n\13\ncptinstall.datadir = \"/var/lib/cpt/\"\13\n\13\nfunction cptinstall.loadstatus()\13\n\9return cyan.readserialized(cptpack.toroot(filesystem.concat(cptinstall.datadir, \"index\")))\13\nend\13\n\13\nfunction cptinstall.resume()\13\n\9return cptinstall.begin(nil, true)\13\nend\13\n\13\nfunction cptinstall.strap()\13\n\9return cptinstall.begin({installed={}, index={}})\13\nend\13\n\13\nfunction cptinstall.begin(base, resume)\13\n\9local out = cyan.instance(context, base or cptinstall.loadstatus())\13\n\9out.resolved = false\13\n\9if resume then\13\n\9\9if not out.intermediate then\13\n\9\9\9error(\"Installation set is not in an intermediate state! Cannot continue transaction.\")\13\n\9\9end\13\n\9else\13\n\9\9if out.intermediate then\13\n\9\9\9error(\"Installation set is in an intermediate state! Cannot begin transaction.\")\13\n\9\9end\13\n\9\9out.deltaadd = {}\13\n\9\9out.deltadel = {}\13\n\9end\13\n\9return out\13\nend\13\n\13\nfunction context:save(intermediate)\13\n\9assert(self.resolved)\13\n\9if not filesystem.isDirectory(cptpack.toroot(cptinstall.datadir)) then\13\n\9\9local success, err = filesystem.makeDirectory(cptpack.toroot(cptinstall.datadir))\13\n\9\9if not success then\13\n\9\9\9error(\"Cannot create directory \" .. cptpack.toroot(cptinstall.datadir) .. \": \" .. err)\13\n\9\9end\13\n\9end\13\n\9self.intermediate = intermediate\13\n\9cyan.writeinstance(cptpack.toroot(filesystem.concat(cptinstall.datadir, \"index\")), self)\13\nend\13\n\13\nfunction context:apply()\13\n\9assert(self.resolved)\13\n\9print(\"About to apply\", #self.deltadel, \"deletions and\", #self.deltaadd, \"additions.\")\13\n\9for i, name in ipairs(self.deltadel) do\13\n\9\9cptpack.uninstall(name, self.index[name])\13\n\9end\13\n\9for i, name in ipairs(self.deltaadd) do\13\n\9\9local rname, rver = cyan.cut(name, \"-\", \"Bad name&version: \" .. name)\13\n\9\9cptpack.install(name, cptcache.getpath(rname))\13\n\9end\13\n\9print(\"Applied\", #self.deltadel + #self.deltaadd, \"changes.\")\13\nend\13\n\13\nfunction context:resolve()\13\n\9if self.resolved then return end\13\n\9local includedfull = cyan.valueset(self.installed)\13\n\9local included = {}\13\n\9for i, namever in ipairs(self.installed) do\13\n\9\9local name, version = cyan.cut(namever, \"-\", \"Bad name&version string: \" .. namever)\13\n\9\9if included[name] then\13\n\9\9\9error(\"Multiple versions of \" .. name .. \" are selected: \" .. version .. \" and \" .. included[name])\13\n\9\9end\13\n\9\9included[name] = version\13\n\9end\13\n\9for i, name in ipairs(self.installed) do\13\n\9\9local data = self.index[name]\13\n\9\9for i, needed in ipairs(data.depends) do\13\n\9\9\9if not included[needed] and not includedfull[needed] then\13\n\9\9\9\9error(\"Dependency failed: \" .. name .. \" requires \" .. needed .. \" but it is not selected.\")\13\n\9\9\9end\13\n\9\9end\13\n\9\9for i, conflicted in ipairs(data.conflicts) do\13\n\9\9\9if included[needed] or includedfull[needed] then\13\n\9\9\9\9error(\"Conflict detected: \" .. name .. \" conflicts with \" .. needed .. \" and both are selected.\")\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\9self.resolved = true\13\nend\13\n\13\nfunction context:update(dir)\13\n\9local cache = cptcache.loadcache()\13\n\9self.resolved = false\13\n\9for k, v in pairs(cache) do\13\n\9\9assert(k == v.name)\13\n\9\9local index = cptpack.loadindex(cptcache.getpath(k))\13\n\9\9assert(k == index.name)\13\n\9\9assert(index.version == v.version)\13\n\9\9self.index[index.name .. \"-\" .. index.version] = index\13\n\9end\13\nend\13\n\13\nfunction context:add(namever)\13\n\9local name, ver = cyan.cut(namever, \"-\")\13\n\9if not ver then\13\n\9\9for k, v in pairs(self.index) do\13\n\9\9\9local fname, fver = cyan.cut(k, \"-\", \"Bad name&version: \" .. k)\13\n\9\9\9if fname == name and ((not ver) or tonumber(ver) < tonumber(fver)) then\13\n\9\9\9\9ver = fver\13\n\9\9\9end\13\n\9\9end\13\n\9\9if not ver then\13\n\9\9\9error(\"Cannot find any package for: \" .. name)\13\n\9\9end\13\n\9\9namever = name .. \"-\" .. ver\13\n\9end\13\n\9for i, found in ipairs(self.installed) do\13\n\9\9if found == namever then\13\n\9\9\9error(\"Already selected: \" .. namever)\13\n\9\9end\13\n\9end\13\n\9if not self.index[namever] then\13\n\9\9error(\"Package not in index: \" .. namever)\13\n\9end\13\n\9self.resolved = false\13\n\9table.insert(self.installed, namever)\13\n\9table.insert(self.deltaadd, namever)\13\nend\13\n\13\nfunction context:remove(name)\13\n\9for i, namever in ipairs(self.installed) do\13\n\9\9local lname, lver = cyan.cut(namever, \"-\")\13\n\9\9if name == lname or name == namever then\13\n\9\9\9self.resolved = false\13\n\9\9\9table.remove(self.installed, i)\13\n\9\9\9table.insert(self.deltadel, namever)\13\n\9\9\9return\13\n\9\9end\13\n\9end\13\n\9error(\"Package not installed: \" .. name)\13\nend\13\n\13\nfunction context:dump()\13\n\9print(\"Packages installed:\", #self.installed)\13\n\9for i, name in ipairs(self.installed) do\13\n\9\9print(name)\13\n\9\9local index = self.index[name]\13\n\9\9assert(name == index.name .. \"-\" .. index.version)\13\n\9\9print(\"\\tContains\", #index.listing, \"files.\")\13\n\9\9print(\"\\tDepends on\", #index.depends, \"packages:\")\13\n\9\9for i, v in ipairs(index.depends) do\13\n\9\9\9print(\"\\t\", v)\13\n\9\9end\13\n\9\9print(\"\\tConflicts with\", #index.conflicts, \"packages:\")\13\n\9\9for i, v in ipairs(index.conflicts) do\13\n\9\9\9print(\"\\t\", v)\13\n\9\9end\13\n\9end\13\n\9print(\"Packages in index:\", #self.index)\13\n\9print(\"Deltas:\", #self.deltadel + #self.deltaadd)\13\n\9for i, v in ipairs(self.deltadel) do\13\n\9\9print(\"Remove package\", v)\13\n\9end\13\n\9for i, v in ipairs(self.deltaadd) do\13\n\9\9print(\"Add package\", v)\13\n\9end\13\nend\13\n\13\nreturn cptinstall\13\n",["/usr/bin/cpt.lua"]="local args = {...}\13\n\13\nif #args == 0 or args[1] == \"help\" then\13\n\9if #args > 1 then\13\n\9\9error(\"Too many parameters to help.\")\13\n\9end\13\n\9print(\"Usage: cpt (install|remove|update|dump) PACKAGES...\")\13\n\9print(\"Usage: cpt (sync|flush|upgrade|init|init-installation|dump|force-lock|force-unlock|attempt-resume)\")\13\n\9print(\"Usage: cpt build DIR FILEOUT\")\13\n\9print(\"Usage: cpt no-preresolve (line from above)\")\13\n\9print(\"Usage: cpt reroot ROOT (line from above)\")\13\n\9return\13\nend\13\n\13\nlocal cptlock = require(\"cptlock\")\13\nlocal cptpack = require(\"cptpack\")\13\n\13\nlocal cmd = table.remove(args, 1)\13\n\13\nlocal root = \"/\"\13\n\13\nlocal preresolve = true\13\n\13\nif cmd == \"reroot\" then\13\n\9rootmod = table.remove(args, 1)\13\n\9cmd = table.remove(args, 1)\13\n\9if not cmd then\13\n\9\9print(\"Path and command expected after reroot.\")\13\n\9\9return\13\n\9end\13\nend\13\nif cmd == \"no-preresolve\" then\13\n\9cmd = table.remove(args, 1)\13\n\9if not cmd then\13\n\9\9print(\"Path and command expected after no-preresolve.\")\13\n\9\9return\13\n\9end\13\n\9preresolve = false\13\nend\13\n\13\nif cmd == \"force-lock\" then\13\n\9if #args > 0 then\13\n\9\9error(\"Too many parameters to force-lock.\")\13\n\9end\13\n\9cptlock.lock()\13\nelseif cmd == \"force-unlock\" then\13\n\9if #args > 0 then\13\n\9\9error(\"Too many parameters to force-unlock.\")\13\n\9end\13\n\9cptlock.unlock()\13\nelseif cmd == \"build\" then\13\n\9if #args ~= 2 then\13\n\9\9error(\"Wrong number of parameters to build.\")\13\n\9end\13\n\9require(\"cptpack\").buildpkg(args[1], args[2])\13\nelse\13\n\9function main()\13\n\9\9if cmd == \"sync\" then\13\n\9\9\9if #args > 0 then\13\n\9\9\9\9error(\"Too many parameters to sync.\")\13\n\9\9\9end\13\n\9\9\9require(\"cptcache\").synchronizerepos()\13\n\9\9elseif cmd == \"init\" then\13\n\9\9\9if #args > 0 then\13\n\9\9\9\9error(\"Too many parameters to init.\")\13\n\9\9\9end\13\n\9\9\9require(\"cptcache\").synchronizerepos(nil, nil, true)\13\n\9\9elseif cmd == \"init-installation\" then\13\n\9\9\9if #args > 0 then\13\n\9\9\9\9error(\"Too many parameters to init-installation.\")\13\n\9\9\9end\13\n\9\9\9local context = require(\"cptinstall\").strap()\13\n\9\9\9if preresolve then\13\n\9\9\9\9context:resolve()\13\n\9\9\9\9context:update()\13\n\9\9\9\9context:resolve()\13\n\9\9\9else\13\n\9\9\9\9context:update()\13\n\9\9\9end\13\n\9\9\9context:dump()\13\n\9\9\9context:save(true)\13\n\9\9\9context:apply()\13\n\9\9\9context:save()\13\n\9\9elseif cmd == \"flush\" then\13\n\9\9\9if #args > 0 then\13\n\9\9\9\9error(\"Too many parameters to flush.\")\13\n\9\9\9end\13\n\9\9\9require(\"cptcache\").flushcache()\13\n\9\9elseif cmd == \"upgrade\" then\13\n\9\9\9if #args > 0 then\13\n\9\9\9\9error(\"Too many parameters to upgrade.\")\13\n\9\9\9end\13\n\9\9\9error(\"unimplemented\") -- TODO: Implement!\13\n\9\9elseif cmd == \"dump\" then\13\n\9\9\9require(\"cptcache\").dumpcache(args)\13\n\9\9\9local context = require(\"cptinstall\").begin()\13\n\9\9\9context:resolve()\13\n\9\9\9context:dump()\13\n\9\9elseif cmd == \"install\" then\13\n\9\9\9if #args <= 0 then\13\n\9\9\9\9error(\"Too few parameters to install.\")\13\n\9\9\9end\13\n\9\9\9local cptinstall = require(\"cptinstall\")\13\n\9\9\9local context = cptinstall.begin()\13\n\9\9\9if preresolve then\13\n\9\9\9\9context:resolve()\13\n\9\9\9\9context:update()\13\n\9\9\9\9context:resolve()\13\n\9\9\9else\13\n\9\9\9\9context:update()\13\n\9\9\9end\13\n\9\9\9for i, packname in ipairs(args) do\13\n\9\9\9\9context:add(packname)\13\n\9\9\9end\13\n\9\9\9context:resolve()\13\n\9\9\9context:dump()\13\n\9\9\9context:save(true)\13\n\9\9\9context:apply()\13\n\9\9\9context:save()\13\n\9\9elseif cmd == \"resume\" then\13\n\9\9\9if #args > 0 then\13\n\9\9\9\9error(\"Too many parameters to resume.\")\13\n\9\9\9end\13\n\9\9\9local cptinstall = require(\"cptinstall\")\13\n\9\9\9local context = cptinstall.resume()\13\n\9\9\9context:resolve()\13\n\9\9\9context:dump()\13\n\9\9\9context:apply()\13\n\9\9\9context:save()\13\n\9\9elseif cmd == \"remove\" then\13\n\9\9\9if #args <= 0 then\13\n\9\9\9\9error(\"Too few parameters to remove.\")\13\n\9\9\9end\13\n\9\9\9local cptinstall = require(\"cptinstall\")\13\n\9\9\9local context = cptinstall.begin()\13\n\9\9\9if preresolve then\13\n\9\9\9\9context:resolve()\13\n\9\9\9\9context:update()\13\n\9\9\9\9context:resolve()\13\n\9\9\9else\13\n\9\9\9\9context:update()\13\n\9\9\9end\13\n\9\9\9for i, packname in ipairs(args) do\13\n\9\9\9\9context:remove(packname)\13\n\9\9\9end\13\n\9\9\9context:resolve()\13\n\9\9\9context:dump()\13\n\9\9\9context:save(true)\13\n\9\9\9context:apply()\13\n\9\9\9context:save()\13\n\9\9elseif cmd == \"update\" then\13\n\9\9\9if #args <= 0 then\13\n\9\9\9\9error(\"Too few parameters to update.\")\13\n\9\9\9end\13\n\9\9\9local cptinstall = require(\"cptinstall\")\13\n\9\9\9local context = cptinstall.begin()\13\n\9\9\9if preresolve then\13\n\9\9\9\9context:resolve()\13\n\9\9\9\9context:update()\13\n\9\9\9\9context:resolve()\13\n\9\9\9else\13\n\9\9\9\9context:update()\13\n\9\9\9end\13\n\9\9\9for i, packname in ipairs(args) do\13\n\9\9\9\9context:remove(packname)\13\n\9\9\9\9context:add(packname)\13\n\9\9\9end\13\n\9\9\9context:resolve()\13\n\9\9\9context:dump()\13\n\9\9\9context:save(true)\13\n\9\9\9context:apply()\13\n\9\9\9context:save()\13\n\9\9else\13\n\9\9\9error(\"Unsupported command: \" .. cmd)\13\n\9\9end\13\n\9end\13\n\13\n\9cptlock.lock()\13\n\9local opr = cptpack.root\13\n\9if rootmod then\13\n\9\9cptpack.root = rootmod\13\n\9end\13\n\9local success, err = pcall(main)\13\n\9if rootmod then\13\n\9\9cptpack.root = opr\13\n\9end\13\n\9cptlock.unlock()\13\n\9\13\n\9if not success then error(err) end\13\nend",["/usr/lib/cptcache.lua"]="local cptcache = {}\n\n-- TODO: include versioning in cache!\n\nlocal cyan = require(\"cyan\")\nlocal cptpack = require(\"cptpack\")\n\nlocal internet = require(\"internet\")\nlocal filesystem = require(\"filesystem\")\nlocal serialization = require(\"serialization\")\n\n-- General utilities\n\nlocal function processconfig(iterator)\n\9return function()\n\9\9repeat\n\9\9\9realline = iterator()\n\9\9\9if not realline then return nil end\n\9\9\9line = cyan.trim(realline)\n\9\9until line and line:sub(1, 1) ~= \"#\" -- not empty line nor comment.\n\9\9return cyan.cut(line, \" \", \"Unprocessable line: \" .. realline)\n\9end\nend\n\n-- Generic package utilities\n\nfunction cptcache.displaypkg(pkg)\n\9print(\"\\tName\", pkg.name)\n\9print(\"\\tVersion\", pkg.version)\n\9print(\"\\tSource\", pkg.source)\n\9print(\"\\tPath\", pkg.path)\nend\n\n-- Remote packages and cache synchronization\n\nlocal function loadrepo(discovered, lineiter, source)\n\9local root = \"\"\n\9for cmd, arg in processconfig(lineiter) do\n\9\9if cmd == \"root\" then\n\9\9\9root = arg\n\9\9elseif cmd == \"package\" then\n\9\9\9ref, path = cyan.cut(arg, \" \", \"Bad package declaration: \" .. arg)\n\9\9\9path = root .. path\n\9\9\9name, version = cyan.cut(ref, \"-\", \"Bad package name declaration: \" .. ref)\n\9\9\9pkg = {name=name, version=version, source=source, path=path}\n\9\9\9prev = discovered[name]\n\9\9\9if prev then\n\9\9\9\9print(\"Duplicate package declaration.\")\n\9\9\9\9print(\"Previous entry:\")\n\9\9\9\9cptcache.displaypkg(prev)\n\9\9\9\9print(\"Next entry:\")\n\9\9\9\9cptcache.displaypkg(pkg)\n\9\9\9\9error(\"Error: aborted due to package duplication.\")\n\9\9\9else\n\9\9\9\9discovered[name] = pkg\n\9\9\9end\n\9\9else\n\9\9\9error(\"Bad repository declaration: \" .. cmd)\n\9\9end\n\9end\nend\n\nlocal function loadrepos(path)\n\9local discovered = {}\n\9for cmd, source in processconfig(io.lines(path)) do\n\9\9if cmd == \"remote\" then\n\9\9\9print(\"Fetching \" .. source .. \"...\")\n\9\9\9loadrepo(discovered, internet.request(source), \"remote:\" .. source)\n\9\9elseif cmd == \"local\" then\n\9\9\9print(\"Loading \" .. source .. \"...\")\n\9\9\9loadrepo(discovered, io.lines(source), \"local:\" .. source)\n\9\9else\n\9\9\9error(\"Bad configuration command: \" .. cmd)\n\9\9end\n\9end\n\9return discovered\nend\n\nlocal function downloadpkg(path, source, target)\n\9if source:sub(1, 6) == \"local:\" and path:sub(1, 8) == \"local://\" then\n\9\9cyan.writeall(target, cyan.readall(path:sub(9))) -- TODO: Copy directly?\n\9else\n\9\9cyan.writeall(target, cyan.readremote(path))\n\9end\nend\n\nfunction cptcache.loadcache(dir, init)\n\9local listing = cptpack.toroot(filesystem.concat(dir or cptcache.cachedir, \"listing\"))\n\9if filesystem.exists(listing) and init then\n\9\9error(\"Cannot initialize when cache already exists!\")\n\9elseif not filesystem.exists(listing) and not init then\n\9\9error(\"Cache does not yet exist!\")\n\9end\n\9if init then\n\9\9return {}\n\9else\n\9\9return cyan.readserialized(listing)\n\9end\nend\n\nfunction cptcache.flushcache(dir)\n\9print(\"Flushing repository cache...\")\n\9local realdir = dir or cptcache.cachedir\n\9local cached = cptcache.loadcache(realdir, initialize)\n\9local todelete = cyan.keylist(cached)\n\9print(\"Saving changes...\")\n\9cyan.writeserialized(cptpack.toroot(filesystem.concat(realdir, \"listing\")), {})\n\9print(\"Removing\", #todelete, \"packages.\")\n\9for i, name in ipairs(todelete) do\n\9\9print(\"Deleting cached version of\", name)\n\9\9local path = cptpack.toroot(filesystem.concat(realdir, name .. \".cpk\"))\n\9\9if filesystem.exists(path) then\n\9\9\9cyan.removeSingleFile(path)\n\9\9else\n\9\9\9print(\"(File did not exist, anyway.)\")\n\9\9end\n\9end\n\9print(\"Completed cache flush.\")\nend\n\ncptcache.configpath = \"./cpt.list\"\ncptcache.cachedir = \"/var/cache/cpt/\"\nfunction cptcache.synchronizerepos(path, dir, initialize)\n\9print(\"Synchronizing repository cache\")\n\9local realdir = dir or cptcache.cachedir\n\9print(\"Loading remote repositories...\")\n\9local remotes = loadrepos(path or cptcache.configpath)\n\9print(\"Loading cache...\")\n\9local cached = cptcache.loadcache(realdir, initialize)\n\9print(\"Calculating deltas...\")\n\9local todownload = {}\n\9local todelete = {}\n\9for k, v in pairs(cached) do\n\9\9assert(k == v.name)\n\9\9local matching = remotes[k]\n\9\9if matching == nil then\n\9\9\9print(\"Removing\", k, \"from cache.\")\n\9\9\9table.insert(todelete, k)\n\9\9\9cached[k] = nil\n\9\9else\n\9\9\9assert(v.name == matching.name)\n\9\9\9local needsdownload = false\n\9\9\9if v.version ~= matching.version then\n\9\9\9\9print(\"Updating version of\", k, \"from\", v.version, \"to\", matching.version)\n\9\9\9\9v.version = matching.version\n\9\9\9\9needsdownload = true\n\9\9\9end\n\9\9\9if v.path ~= matching.path then\n\9\9\9\9print(\"Updating path of\", k, \"from\", v.path, \"to\", matching.path)\n\9\9\9\9v.path = matching.path\n\9\9\9\9needsdownload = true\n\9\9\9end\n\9\9\9if v.source ~= matching.source then\n\9\9\9\9print(\"Updating source of\", k, \"from\", v.source, \"to\", matching.source)\n\9\9\9end\n\9\9\9if not filesystem.exists(cptpack.toroot(filesystem.concat(realdir, k .. \".cpk\"))) then\n\9\9\9\9needsdownload = true\n\9\9\9end\n\9\9\9if needsdownload then\n\9\9\9\9table.insert(todownload, k)\n\9\9\9end\n\9\9end\n\9end\n\9for k, v in pairs(remotes) do\n\9\9assert(k == v.name)\n\9\9if cached[k] == nil then\n\9\9\9cached[k] = v\n\9\9\9table.insert(todownload, k)\n\9\9end\n\9end\n\9print(\"Saving changes...\")\n\9cyan.writeserialized(cptpack.toroot(filesystem.concat(realdir, \"listing\")), cached)\n\9print(\"Removing\", #todelete, \"packages and downloading\", #todownload, \"new or updated packages.\")\n\9for i, name in ipairs(todelete) do\n\9\9print(\"Deleting cached version of\", name)\n\9\9local path = cptpack.toroot(filesystem.concat(realdir, name .. \".cpk\"))\n\9\9if filesystem.exists(path) then\n\9\9\9cyan.removeSingleFile(path)\n\9\9else\n\9\9\9print(\"(File did not exist, anyway.)\")\n\9\9end\n\9end\n\9for i, name in ipairs(todownload) do\n\9\9local pkg = cached[name]\n\9\9print(\"Downloading\", name)\n\9\9downloadpkg(pkg.path, pkg.source, cptpack.toroot(filesystem.concat(realdir, name .. \".cpk\")))\n\9end\n\9print(\"Completed database synchronization.\")\nend\n\n-- Local packages\n\nfunction cptcache.getpath(name, dir)\n\9return cptpack.toroot(filesystem.concat(dir or cptcache.cachedir, name .. \".cpk\"))\nend\n\nfunction cptcache.dumpcache(packages, dir)\n\9local cache = cptcache.loadcache(dir or cptcache.cachedir)\n\9if packages and #packages > 0 then\n\9\9print(\"Listing of selected packages:\")\n\9\9for i, name in ipairs(packages) do\n\9\9\9local pkg = cache[name]\n\9\9\9if pkg then\n\9\9\9\9cptcache.displaypkg(pkg)\n\9\9\9else\n\9\9\9\9error(\"No such package: \" .. name)\n\9\9\9end\n\9\9end\n\9else\n\9\9print(\"Cache listing:\")\n\9\9for k, v in pairs(cache) do\n\9\9\9assert(k == v.name)\n\9\9\9cptcache.displaypkg(v)\n\9\9end\n\9\9print(\"End of listing\")\n\9end\nend\n\nreturn cptcache",["/usr/lib/cptlock.lua"]="local cptlock = {}\13\n\13\nlocal locktaken = false\13\n\13\nfunction cptlock.lock() -- Todo: more robust locking?\13\n\9if locktaken then\13\n\9\9error(\"CPT caches already locked!\")\13\n\9end\13\n\9locktaken = true\13\nend\13\n\13\nfunction cptlock.unlock()\13\n\9if not locktaken then\13\n\9\9error(\"CPT caches not locked!\")\13\n\9end\13\n\9locktaken = false\13\nend\13\n\13\nreturn cptlock"},name="cpt",depends={"libcyan","init","libserialization","libinternet"},version="0.2",conflicts={}}