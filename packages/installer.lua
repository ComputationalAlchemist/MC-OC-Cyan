-- Cyan OS Installer
local filesystem = require("filesystem")
local shell = require("shell")
io.write("Enter absolute directory to install to: ")
local dirout = io.read()
assert(not dirout:match(" "), "Spaces are not allowed in this path.")
assert(filesystem.isDirectory(dirout), "That's not a directory that exists!")
shell.setWorkingDirectory(dirout)
function handle(file, data)
	file = filesystem.concat(dirout, file)
	if not filesystem.exists(filesystem.path(file)) then
		assert(filesystem.makeDirectory(filesystem.path(file)), 'Could not create parent directory: ' .. file)
	end
	local out, err = io.open(file, 'w')
	assert(out, "Cannot open " .. file .. " for writing: " .. tostring(err))
	local out, err = out:write(data)
	assert(out, "Cannot write " .. file .. ": " .. tostring(err))
	out:close()
end
handle("cpt.list", "{\"https://raw.githubusercontent.com/ComputationalAlchemist/MC-OC-Cyan/master/packages/core.cpt\"}")
handle("cpt.lua", "local args = {...}\13\n\13\nif #args == 0 or args[1] == \"help\" then\13\n\9if #args > 1 then\13\n\9\9error(\"Too many parameters to help.\")\13\n\9end\13\n\9print(\"Usage: cpt (install|remove|update) PACKAGES...\")\13\n\9print(\"Usage: cpt (sync|flush|upgrade|init|init-installation|dump|force-lock|force-unlock|attempt-resume)\")\13\n\9print(\"Usage: cpt build DIR FILEOUT\")\13\n\9print(\"Usage: cpt no-preresolve (line from above)\")\13\n\9print(\"Usage: cpt reroot ROOT (line from above)\")\13\n\9return\13\nend\13\n\13\nlocal cptlock = require(\"cptlock\")\13\nlocal cptpack = require(\"cptpack\")\13\n\13\nlocal cmd = table.remove(args, 1)\13\n\13\nlocal root = \"/\"\13\n\13\nlocal preresolve = true\13\n\13\nif cmd == \"reroot\" then\13\n\9rootmod = table.remove(args, 1)\13\n\9cmd = table.remove(args, 1)\13\n\9if not cmd then\13\n\9\9print(\"Path and command expected after reroot.\")\13\n\9\9return\13\n\9end\13\nend\13\nif cmd == \"no-preresolve\" then\13\n\9cmd = table.remove(args, 1)\13\n\9if not cmd then\13\n\9\9print(\"Path and command expected after no-preresolve.\")\13\n\9\9return\13\n\9end\13\n\9preresolve = false\13\nend\13\n\13\nif cmd == \"force-lock\" then\13\n\9if #args > 0 then\13\n\9\9error(\"Too many parameters to force-lock.\")\13\n\9end\13\n\9cptlock.lock()\13\nelseif cmd == \"force-unlock\" then\13\n\9if #args > 0 then\13\n\9\9error(\"Too many parameters to force-unlock.\")\13\n\9end\13\n\9cptlock.unlock()\13\nelseif cmd == \"build\" then\13\n\9if #args ~= 2 then\13\n\9\9error(\"Wrong number of parameters to build.\")\13\n\9end\13\n\9require(\"cptpack\").buildpkg(args[1], args[2])\13\nelse\13\n\9function main()\13\n\9\9if cmd == \"sync\" then\13\n\9\9\9if #args > 0 then\13\n\9\9\9\9error(\"Too many parameters to sync.\")\13\n\9\9\9end\13\n\9\9\9require(\"cptcache\").synchronizerepos()\13\n\9\9elseif cmd == \"strap\" then\13\n\9\9\9local cptcache = require(\"cptcache\")\13\n\9\9\9cptcache.initcache()\13\n\9\9\9cptcache.synchronizerepos(true)\13\n\9\9\9local context = require(\"cptinstall\").strap()\13\n\9\9\9context:resolve()\13\n\9\9\9if #args == 0 then\13\n\9\9\9\9context:add(\"group_base\")\13\n\9\9\9else\13\n\9\9\9\9for i, packname in ipairs(args) do\13\n\9\9\9\9\9context:add(packname)\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9\9context:resolve(true)\13\n\9\9\9context:getpackages()\13\n\9\9\9context:dump()\13\n\9\9\9context:prompt()\13\n\9\9\9context:save(true)\13\n\9\9\9context:apply()\13\n\9\9\9context:save()\13\n\9\9elseif cmd == \"init\" then\13\n\9\9\9if #args > 0 then\13\n\9\9\9\9error(\"Too many parameters to init.\")\13\n\9\9\9end\13\n\9\9\9require(\"cptcache\").initcache()\13\n\9\9elseif cmd == \"init-installation\" then\13\n\9\9\9if #args > 0 then\13\n\9\9\9\9error(\"Too many parameters to init-installation.\")\13\n\9\9\9end\13\n\9\9\9local context = require(\"cptinstall\").strap()\13\n\9\9\9if preresolve then\13\n\9\9\9\9context:resolve()\13\n\9\9\9end\13\n\9\9\9context:resolve()\13\n\9\9\9context:getpackages()\13\n\9\9\9context:dump()\13\n\9\9\9context:prompt()\13\n\9\9\9context:save(true)\13\n\9\9\9context:apply()\13\n\9\9\9context:save()\13\n\9\9elseif cmd == \"flush\" then\13\n\9\9\9if #args > 0 then\13\n\9\9\9\9error(\"Too many parameters to flush.\")\13\n\9\9\9end\13\n\9\9\9require(\"cptcache\").flushcache()\13\n\9\9elseif cmd == \"upgrade\" then\13\n\9\9\9if #args > 0 then\13\n\9\9\9\9error(\"Too many parameters to upgrade.\")\13\n\9\9\9end\13\n\9\9\9local cptinstall = require(\"cptinstall\")\13\n\9\9\9local context = cptinstall.begin()\13\n\9\9\9if preresolve then\13\n\9\9\9\9context:resolve()\13\n\9\9\9end\13\n\9\9\9context:upgrade()\13\n\9\9\9context:resolve()\13\n\9\9\9context:getpackages()\13\n\9\9\9context:dump()\13\n\9\9\9if context:anyactions() then\13\n\9\9\9\9context:prompt()\13\n\9\9\9\9context:save(true)\13\n\9\9\9\9context:apply()\13\n\9\9\9\9context:save()\13\n\9\9\9else\13\n\9\9\9\9print(\"Nothing to do.\")\13\n\9\9\9end\13\n\9\9elseif cmd == \"dump\" then\13\n\9\9\9if #args > 0 then\13\n\9\9\9\9error(\"Too many parameters to dump.\")\13\n\9\9\9end\13\n\9\9\9require(\"cptcache\").dumpcache()\13\n\9\9\9local context = require(\"cptinstall\").begin()\13\n\9\9\9context:resolve()\13\n\9\9\9context:dump()\13\n\9\9elseif cmd == \"install\" then\13\n\9\9\9if #args <= 0 then\13\n\9\9\9\9error(\"Too few parameters to install.\")\13\n\9\9\9end\13\n\9\9\9local cptinstall = require(\"cptinstall\")\13\n\9\9\9local context = cptinstall.begin()\13\n\9\9\9if preresolve then\13\n\9\9\9\9context:resolve()\13\n\9\9\9end\13\n\9\9\9for i, packname in ipairs(args) do\13\n\9\9\9\9context:add(packname)\13\n\9\9\9end\13\n\9\9\9context:resolve(true)\13\n\9\9\9context:getpackages()\13\n\9\9\9context:dump()\13\n\9\9\9if context:anyactions() then\13\n\9\9\9\9context:prompt()\13\n\9\9\9\9context:save(true)\13\n\9\9\9\9context:apply()\13\n\9\9\9\9context:save()\13\n\9\9\9else\13\n\9\9\9\9print(\"Nothing to do.\")\13\n\9\9\9end\13\n\9\9elseif cmd == \"resume\" then\13\n\9\9\9if #args > 0 then\13\n\9\9\9\9error(\"Too many parameters to resume.\")\13\n\9\9\9end\13\n\9\9\9local cptinstall = require(\"cptinstall\")\13\n\9\9\9local context = cptinstall.resume()\13\n\9\9\9context:resolve()\13\n\9\9\9context:getpackages()\13\n\9\9\9context:dump()\13\n\9\9\9context:prompt()\13\n\9\9\9context:apply()\13\n\9\9\9context:save()\13\n\9\9elseif cmd == \"remove\" then\13\n\9\9\9if #args <= 0 then\13\n\9\9\9\9error(\"Too few parameters to remove.\")\13\n\9\9\9end\13\n\9\9\9local cptinstall = require(\"cptinstall\")\13\n\9\9\9local context = cptinstall.begin()\13\n\9\9\9if preresolve then\13\n\9\9\9\9context:resolve()\13\n\9\9\9end\13\n\9\9\9for i, packname in ipairs(args) do\13\n\9\9\9\9context:remove(packname)\13\n\9\9\9end\13\n\9\9\9context:resolve()\13\n\9\9\9context:getpackages()\13\n\9\9\9context:dump()\13\n\9\9\9if context:anyactions() then\13\n\9\9\9\9context:prompt()\13\n\9\9\9\9context:save(true)\13\n\9\9\9\9context:apply()\13\n\9\9\9\9context:save()\13\n\9\9\9else\13\n\9\9\9\9print(\"Nothing to do.\")\13\n\9\9\9end\13\n\9\9elseif cmd == \"update\" then\13\n\9\9\9if #args <= 0 then\13\n\9\9\9\9error(\"Too few parameters to update.\")\13\n\9\9\9end\13\n\9\9\9local cptinstall = require(\"cptinstall\")\13\n\9\9\9local context = cptinstall.begin()\13\n\9\9\9if preresolve then\13\n\9\9\9\9context:resolve()\13\n\9\9\9end\13\n\9\9\9for i, packname in ipairs(args) do\13\n\9\9\9\9context:remove(packname)\13\n\9\9\9\9context:add(packname)\13\n\9\9\9end\13\n\9\9\9context:resolve()\13\n\9\9\9context:getpackages()\13\n\9\9\9context:dump()\13\n\9\9\9if context:anyactions() then\13\n\9\9\9\9context:prompt()\13\n\9\9\9\9context:save(true)\13\n\9\9\9\9context:apply()\13\n\9\9\9\9context:save()\13\n\9\9\9else\13\n\9\9\9\9print(\"Nothing to do.\")\13\n\9\9\9end\13\n\9\9else\13\n\9\9\9error(\"Unsupported command: \" .. cmd)\13\n\9\9end\13\n\9end\13\n\13\n\9cptlock.lock()\13\n\9local opr = cptpack.root\13\n\9if rootmod then\13\n\9\9cptpack.root = rootmod\13\n\9end\13\n\9local success, err = pcall(main)\13\n\9if rootmod then\13\n\9\9cptpack.root = opr\13\n\9end\13\n\9cptlock.unlock()\13\n\9\13\n\9if not success then error(err) end\13\nend")
handle("cptcache.lua", "local cptcache = {}\n\n-- TODO: include versioning in cache!\n\nlocal cyan = require(\"cyan\")\nlocal cptpack = require(\"cptpack\")\nlocal filesystem = require(\"filesystem\")\nlocal serialization = require(\"serialization\")\n\n-- Remote packages and cache synchronization\n\nfunction cptcache.remoteindexpath()\n\9return cptpack.toroot(filesystem.concat(cptcache.cachedir, \"remoteindex\"))\nend\n\nfunction cptcache.localindexpath()\n\9return cptpack.toroot(filesystem.concat(cptcache.cachedir, \"localindex\"))\nend\n\nlocal function mergeremote(index, source)\n\9local rindex\n\9if source:sub(1, 8) == \"local://\" then\n\9\9rindex = cptpack.readindex(source:sub(9))\n\9else\n\9\9rindex = cptpack.readremoteindex(source)\n\9end\n\9cptpack.setsources(rindex, source)\n\9cptpack.mergeindex(index, rindex)\nend\n\ncptcache.configpath = \"/etc/cpt.list\"\ncptcache.cachedir = \"/var/cache/cpt/\"\nfunction cptcache.synchronizerepos(unrootconfig)\n\9print(\"Synchronizing repository cache...\")\n\9print(\"Building remote index...\")\n\9local rindex = cptpack.makeindex()\n\9print(\"Loading remote repositories...\")\n\9local path = cptpack.toroot(cptcache.configpath)\n\9if unrootconfig then\n\9\9path = cptcache.configpath\n\9end\n\9for _, v in ipairs(cyan.readserialized(path)) do\n\9\9mergeremote(rindex, v)\n\9end\n\9print(\"Saving remote index...\")\n\9cyan.makeParentDirectory(cptcache.remoteindexpath())\n\9cptpack.writeindex(cptcache.remoteindexpath(), rindex)\n\9print(\"Completed index synchronization.\")\nend\n\nfunction cptcache.loadlocalindex()\n\9return cptpack.readindex(cptcache.localindexpath())\nend\n\nfunction cptcache.loadremoteindex()\n\9return cptpack.readindex(cptcache.remoteindexpath())\nend\n\nlocal function downloadpkg(name, source, target)\n\9local data\n\9if source:sub(1, 8) == \"local://\" then\n\9\9print(\"Fetching\", name, \"locally...\")\n\9\9data = cyan.readall(filesystem.concat(filesystem.path(source:sub(9)), name .. \".cpk\"))\n\9elseif source:sub(1, 8) == \"https://\" then\n\9\9print(\"Fetching\", name, \"remotely...\")\n\9\9data = cyan.readremote(\"https://\" .. filesystem.concat(filesystem.path(source:sub(9)), name .. \".cpk\"))\n\9elseif source:sub(1, 7) == \"http://\" then\n\9\9print(\"Fetching\", name, \"remotely...\")\n\9\9data = cyan.readremote(\"http://\" .. filesystem.concat(filesystem.path(source:sub(8)), name .. \".cpk\"))\n\9else\n\9\9error(\"Unknown source: \" .. source)\n\9end\n\9local hash = cptpack.packhash(data)\n\9cyan.writeall(target, data)\n\9return hash\nend\n\n-- Local packages\n\nfunction cptcache.verifyindex(index)\n\9local toremove = {}\n\9for name in cptpack.listindex(index) do\n\9\9if not filesystem.exists(cptcache.getpath(name)) then\n\9\9\9print(\"WARNING: Cannot find indexed package in cache: \" .. name)\n\9\9\9table.insert(toremove, name)\n\9\9end\n\9end\n\9for _, v in ipairs(toremove) do\n\9\9cptpack.removeindex(index, v)\n\9end\n\9if #toremove ~= 0 then\n\9\9print(\"Removed\", #toremove, \"missing packages from local index.\")\n\9end\nend\n\nfunction cptcache.getpackages(names)\n\9print(\"Getting\", #names, \"packages...\")\n\9print(\"Loading and verifying index...\")\n\9local lindex = cptcache.loadlocalindex()\n\9local rindex = cptcache.loadremoteindex()\n\9cptcache.verifyindex(lindex)\n\9print(\"Calculating deltas...\")\n\9local needed = {}\n\9for _, v in ipairs(names) do\n\9\9if not cptpack.hasindex(lindex, v) then\n\9\9\9table.insert(needed, v)\n\9\9end\n\9end\n\9if #needed == 0 then\n\9\9print(\"No packages need fetching.\")\n\9else\n\9\9print(\"Fetching\", #needed, \"packages and modifying local index...\")\n\9\9for _, name in ipairs(needed) do\n\9\9\9local hash = downloadpkg(name, cptpack.getsource(rindex, name), cptcache.getpath(name))\n\9\9\9if hash ~= cptpack.gethash(rindex, name) then\n\9\9\9\9error(\"Bad hash on package: \" .. name .. \": got \" .. hash .. \" instead of \" .. cptpack.gethash(rindex, name))\n\9\9\9end\n\9\9\9cptpack.mergesingleindex(lindex, rindex, name)\n\9\9end\n\9end\n\9print(\"Writing out local index...\")\n\9cyan.makeParentDirectory(cptcache.localindexpath())\n\9cptpack.writeindex(cptcache.localindexpath(), lindex)\n\9print(\"Completed get of\", #names, \"packages.\")\nend\n\nfunction cptcache.getpath(name)\n\9return cptpack.toroot(filesystem.concat(cptcache.cachedir, name .. \".cpk\"))\nend\n\nfunction cptcache.dumpcache()\n\9print(\"Remote index:\")\n\9cptpack.dumpindex(cptcache.loadremoteindex())\n\9print(\"Local index:\")\n\9cptpack.dumpindex(cptcache.loadlocalindex())\nend\n\nfunction cptcache.initcache()\n\9print(\"Building empty local index...\")\n\9if filesystem.exists(cptcache.localindexpath()) then\n\9\9error(\"Error: not overwriting existing local index.\")\n\9end\n\9cyan.makeParentDirectory(cptcache.localindexpath())\n\9cptpack.writeindex(cptcache.localindexpath(), cptpack.makeindex())\n\9print(\"Built empty local index!\")\nend\n\nfunction cptcache.flushcache()\n\9error(\"Cache flushing not currently implemented.\") -- Remember that cptinstall.lua requires that the local cache contains all of the currently-installed packages.\n\9--[[print(\"Flushing repository cache...\")\n\9local count = 0\n\9for name in filesystem.list(cptcache.cachedir) do\n\9\9if name:sub(#name - 3) == \".cpk\" then\n\9\9\9count = count + 1\n\9\9\9cyan.removesinglefile(name)\n\9\9end\n\9end\n\9print(\"Removed\", count, \"packages from cache.\")\n\9local cptcache.cachedir = dir or cptcache.cachedir\n\9local cached = cptcache.loadcache(cptcache.cachedir, initialize)\n\9local todelete = cyan.keylist(cached)\n\9print(\"Saving changes...\")\n\9cyan.writeserialized(cptpack.toroot(filesystem.concat(cptcache.cachedir, \"listing\")), {})\n\9print(\"Removing\", #todelete, \"packages.\")\n\9for i, name in ipairs(todelete) do\n\9\9print(\"Deleting cached version of\", name)\n\9\9local path = cptpack.toroot(filesystem.concat(cptcache.cachedir, name .. \".cpk\"))\n\9\9if filesystem.exists(path) then\n\9\9\9cyan.removeSingleFile(path)\n\9\9else\n\9\9\9print(\"(File did not exist, anyway.)\")\n\9\9end\n\9end\n\9print(\"Completed cache flush.\")]]\nend\n\nreturn cptcache")
handle("cptinstall.lua", "local filesystem = require(\"filesystem\")\13\nlocal cyan = require(\"cyan\")\13\nlocal cptcache = require(\"cptcache\")\13\nlocal cptpack = require(\"cptpack\")\13\nlocal term = require(\"term\")\13\n\13\nlocal cptinstall = {}\13\nlocal context = {}\13\n\13\ncptinstall.datadir = \"/var/lib/cpt/\"\13\n\13\nfunction cptinstall.loadstatus()\13\n\9return cyan.readserialized(cptpack.toroot(filesystem.concat(cptinstall.datadir, \"status\")))\13\nend\13\n\13\nfunction cptinstall.resume()\13\n\9return cptinstall.begin(nil, true)\13\nend\13\n\13\nfunction cptinstall.strap()\13\n\9return cptinstall.begin({installed={}})\13\nend\13\n\13\nfunction cptinstall.begin(base, resume)\13\n\9local out = cyan.instance(context, base or cptinstall.loadstatus())\13\n\9out.resolved = false\13\n\9out.haspackages = false\13\n\9out.localindex = cptcache.loadlocalindex()\13\n\9out.remoteindex = cptcache.loadremoteindex()\13\n\9if resume then\13\n\9\9if not out.intermediate then\13\n\9\9\9error(\"Installation set is not in an intermediate state! Cannot continue transaction.\")\13\n\9\9end\13\n\9else\13\n\9\9if out.intermediate then\13\n\9\9\9error(\"Installation set is in an intermediate state! Cannot begin transaction.\")\13\n\9\9end\13\n\9\9out.deltaadd = {}\13\n\9\9out.deltadel = {}\13\n\9end\13\n\9return out\13\nend\13\n\13\nfunction context:save(intermediate)\13\n\9assert(self.resolved)\13\n\9if not filesystem.isDirectory(cptpack.toroot(cptinstall.datadir)) then\13\n\9\9local success, err = filesystem.makeDirectory(cptpack.toroot(cptinstall.datadir))\13\n\9\9if not success then\13\n\9\9\9error(\"Cannot create directory \" .. cptpack.toroot(cptinstall.datadir) .. \": \" .. err)\13\n\9\9end\13\n\9end\13\n\9self.intermediate = intermediate\13\n\9local lindex = self.localindex\13\n\9local rindex = self.remoteindex\13\n\9self.localindex = nil\13\n\9self.remoteindex = nil\13\n\9cyan.writeinstance(cptpack.toroot(filesystem.concat(cptinstall.datadir, \"status\")), self)\13\n\9self.localindex = lindex\13\n\9self.remoteindex = rindex\13\nend\13\n\13\nfunction context:getpackages()\13\n\9if #self.deltaadd ~= 0 then\13\n\9\9cptcache.getpackages(self.deltaadd)\13\n\9end\13\n\9self.haspackages = true\13\nend\13\n\13\nfunction context:apply()\13\n\9assert(self.resolved and self.haspackages)\13\n\9print(\"About to apply\", #self.deltadel, \"deletions and\", #self.deltaadd, \"additions.\")\13\n\9for i, name in ipairs(self.deltadel) do\13\n\9\9cptpack.uninstall(self.localindex, name)\13\n\9end\13\n\9for i, name in ipairs(self.deltaadd) do\13\n\9\9cptpack.install(name, cptcache.getpath(name))\13\n\9end\13\n\9print(\"Applied\", #self.deltadel + #self.deltaadd, \"changes.\")\13\nend\13\n\13\nfunction context:resolve(rectify)\13\n\9if self.resolved then return end\13\n\9local includedfull = cyan.valueset(self.installed)\13\n\9local included = {}\13\n\9for i, namever in ipairs(self.installed) do\13\n\9\9local name, version = cyan.cut(namever, \"-\", \"Bad name&version string: \" .. namever)\13\n\9\9if included[name] then\13\n\9\9\9error(\"Multiple versions of \" .. name .. \" are selected: \" .. version .. \" and \" .. included[name])\13\n\9\9end\13\n\9\9included[name] = version\13\n\9end\13\n\9local rectification = {}\13\n\9local anyrectification = false\13\n\9for i, name in ipairs(self.installed) do\13\n\9\9local depends, conflicts\13\n\9\9if cptpack.hasindex(self.localindex, name) then\13\n\9\9\9depends = cptpack.dependsfromindex(self.localindex, name)\13\n\9\9\9conflicts = cptpack.conflictsfromindex(self.localindex, name)\13\n\9\9elseif cptpack.hasindex(self.remoteindex, name) then\13\n\9\9\9depends = cptpack.dependsfromindex(self.remoteindex, name)\13\n\9\9\9conflicts = cptpack.conflictsfromindex(self.remoteindex, name)\13\n\9\9else\13\n\9\9\9error(\"Cannot find package \" .. name .. \" in any index!\")\13\n\9\9end\13\n\9\9for i, needed in ipairs(depends) do\13\n\9\9\9if not included[needed] and not includedfull[needed] then\13\n\9\9\9\9if rectify then\13\n\9\9\9\9\9rectification[needed] = true\13\n\9\9\9\9\9anyrectification = true\13\n\9\9\9\9else\13\n\9\9\9\9\9error(\"Dependency failed: \" .. name .. \" requires \" .. needed .. \" but it is not selected.\")\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9end\13\n\9\9for i, conflicted in ipairs(conflicts) do\13\n\9\9\9if included[needed] or includedfull[needed] then\13\n\9\9\9\9error(\"Conflict detected: \" .. name .. \" conflicts with \" .. needed .. \" and both are selected.\")\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\9if anyrectification then\13\n\9\9for name, _ in pairs(rectification) do\13\n\9\9\9print(\"Rectifier: adding\", name)\13\n\9\9\9self:add(name)\13\n\9\9end\13\n\9\9self:resolve(true)\13\n\9\9return\13\n\9end\13\n\9self.resolved = true\13\nend\13\n\13\nfunction context:upgrade()\13\n\9assert(self.resolved)\13\n\9local toremove = {}\13\n\9for i, namever in ipairs(self.installed) do\13\n\9\9local name, ver = cyan.cut(namever, \"-\", \"Bad name&version string: \" .. namever)\13\n\9\9local over = ver\13\n\9\9for k, v in cptpack.listindex(self.remoteindex) do\13\n\9\9\9local fname, fver = cyan.cut(k, \"-\", \"Bad name&version: \" .. k)\13\n\9\9\9if fname == name and ((not ver) or cptpack.compareversion(fver, ver) > 0) then\13\n\9\9\9\9ver = fver\13\n\9\9\9end\13\n\9\9end\13\n\9\9for k, v in cptpack.listindex(self.localindex) do\13\n\9\9\9local fname, fver = cyan.cut(k, \"-\", \"Bad name&version: \" .. k)\13\n\9\9\9if fname == name and ((not ver) or cptpack.compareversion(fver, ver) > 0) then\13\n\9\9\9\9ver = fver\13\n\9\9\9end\13\n\9\9end\13\n\9\9namever = name .. \"-\" .. ver\13\n\9\9if over ~= ver then\13\n\9\9\9self.resolved = false\13\n\9\9\9self.haspackages = false\13\n\9\9\9table.insert(toremove, i)\13\n\9\9\9table.insert(self.deltaadd, namever)\13\n\9\9\9table.insert(self.installed, namever)\13\n\9\9\9print(\"Found upgrade for \" .. name .. \" from \" .. over .. \" to \" .. ver)\13\n\9\9end\13\n\9end\13\n\9for _, i in ipairs(toremove) do\13\n\9\9table.insert(self.deltadel, self.installed[i])\13\n\9\9table.remove(self.installed, i)\13\n\9end\13\n\9print(\"Found\", #toremove, \"upgrades.\")\13\nend\13\n\13\nfunction context:add(namever)\13\n\9local name, ver = cyan.cut(namever, \"-\")\13\n\9if not ver then\13\n\9\9for k, v in cptpack.listindex(self.remoteindex) do\13\n\9\9\9local fname, fver = cyan.cut(k, \"-\", \"Bad name&version: \" .. k)\13\n\9\9\9if fname == name and ((not ver) or cptpack.compareversion(fver, ver) > 0) then\13\n\9\9\9\9ver = fver\13\n\9\9\9end\13\n\9\9end\13\n\9\9for k, v in cptpack.listindex(self.localindex) do\13\n\9\9\9local fname, fver = cyan.cut(k, \"-\", \"Bad name&version: \" .. k)\13\n\9\9\9if fname == name and ((not ver) or cptpack.compareversion(fver, ver) > 0) then\13\n\9\9\9\9ver = fver\13\n\9\9\9end\13\n\9\9end\13\n\9\9if not ver then\13\n\9\9\9error(\"Cannot find any package for: \" .. name)\13\n\9\9end\13\n\9\9namever = name .. \"-\" .. ver\13\n\9end\13\n\9for i, found in ipairs(self.installed) do\13\n\9\9if found == namever then\13\n\9\9\9error(\"Already selected: \" .. namever)\13\n\9\9end\13\n\9end\13\n\9if not cptpack.hasindex(self.remoteindex, namever) and not cptpack.hasindex(self.localindex, namever) then\13\n\9\9error(\"Package not in index: \" .. namever)\13\n\9end\13\n\9self.resolved = false\13\n\9self.haspackages = false\13\n\9table.insert(self.installed, namever)\13\n\9table.insert(self.deltaadd, namever)\13\nend\13\n\13\nfunction context:remove(name)\13\n\9for i, namever in ipairs(self.installed) do\13\n\9\9local lname, lver = cyan.cut(namever, \"-\")\13\n\9\9if name == lname or name == namever then\13\n\9\9\9self.resolved = false\13\n\9\9\9table.remove(self.installed, i)\13\n\9\9\9table.insert(self.deltadel, namever)\13\n\9\9\9return\13\n\9\9end\13\n\9end\13\n\9error(\"Package not installed: \" .. name)\13\nend\13\n\13\nfunction context:dump()\13\n\9print(\"Packages installed:\", #self.installed)\13\n\9print(table.unpack(self.installed))\13\n\9print(\"Packages in index:\", cptpack.countindex(self.localindex))\13\n\9cptpack.dumpindex(self.localindex) -- TODO: Some way to dump complete info about a package.\13\n\9print(\"Deltas:\", #self.deltadel + #self.deltaadd)\13\n\9for i, v in ipairs(self.deltadel) do\13\n\9\9print(\"Remove package\", v)\13\n\9end\13\n\9for i, v in ipairs(self.deltaadd) do\13\n\9\9print(\"Add package\", v)\13\n\9end\13\nend\13\n\13\nfunction context:prompt()\13\n\9term.write(\"Continue? (y/n) \")\13\n\9local line = term.read()\13\n\9if #line == 0 or (line:sub(1, 1) ~= \"y\" and line:sub(1, 1) ~= \"Y\") then\13\n\9\9error(\"Aborting.\")\13\n\9end\13\nend\13\n\13\nreturn cptinstall\13\n")
handle("cptlock.lua", "local cptlock = {}\13\n\13\nlocal locktaken = false\13\n\13\nfunction cptlock.lock() -- TODO: more robust locking?\13\n\9if locktaken then\13\n\9\9error(\"CPT caches already locked!\")\13\n\9end\13\n\9locktaken = true\13\nend\13\n\13\nfunction cptlock.unlock()\13\n\9if not locktaken then\13\n\9\9error(\"CPT caches not locked!\")\13\n\9end\13\n\9locktaken = false\13\nend\13\n\13\nreturn cptlock")
handle("cptpack.lua", "local cptpack = {}\13\nlocal filesystem = require(\"filesystem\")\13\nlocal cyan = require(\"cyan\")\13\nlocal shell = require(\"shell\")\13\nlocal crypto = require(\"crypto\")\13\n\13\ncptpack.root = \"/\"\13\n\13\nfunction cptpack.compareversion(a, b)\13\n\9if a == nil and b == nil then\13\n\9\9return 0\13\n\9elseif a == nil then\13\n\9\9return -1\13\n\9elseif b == nil then\13\n\9\9return 1\13\n\9end\13\n\9local ab, ar = cyan.cut(a, \"[.]\")\13\n\9local bb, br = cyan.cut(b, \"[.]\")\13\n\9local abn = tonumber(ab)\13\n\9if abn == nil then\13\n\9\9error(\"Bad version: not a number: \" .. ab .. \" in \" .. a)\13\n\9end\13\n\9local bbn = tonumber(bb)\13\n\9if bbn == nil then\13\n\9\9error(\"Bad version: not a number: \" .. bb .. \" in \" .. b)\13\n\9end\13\n\9if abn > bbn then\13\n\9\9return 1\13\n\9elseif abn < bbn then\13\n\9\9return -1\13\n\9else\13\n\9\9return cptpack.compareversion(ar, br)\13\n\9end\13\nend\13\n\13\nfunction cptpack.toroot(file)\13\n\9if file:sub(1, 1) == \"/\" then\13\n\9\9return filesystem.concat(cptpack.root, file:sub(2))\13\n\9else\13\n\9\9return file\13\n\9end\13\nend\13\n\13\nfunction cptpack.loadindex(path)\13\n\9local data = cyan.readserialized(path)\13\n\9data.listing = cyan.keylist(data.contents)\13\n\9data.contents = nil\13\n\9return data\13\nend\13\n\13\nlocal function tryremoveparents(file)\13\n\9local parent = filesystem.path(file)\13\n\9if cyan.isDirectoryEmpty(parent) then\13\n\9\9print(\"Parent directory is no longer in use:\", parent)\13\n\9\9filesystem.remove(parent)\13\n\9\9tryremoveparents(parent)\13\n\9end\13\nend\13\n\13\nfunction cptpack.uninstall(index, name)\13\n\9assert(cptpack.hasindex(index, name))\13\n\9print(\"Uninstalling\", name)\13\n\9for i, file in ipairs(cptpack.listingfromindex(index, name)) do\13\n\9\9if not filesystem.exists(cptpack.toroot(file)) then\13\n\9\9\9print(\"Would remove\", cptpack.toroot(file), \"but it didn't exist.\")\13\n\9\9else\13\n\9\9\9print(\"Removing\", cptpack.toroot(file))\13\n\9\9\9if file:sub(1, 1) ~= \"/\" then\13\n\9\9\9\9error(\"Invalid path - no leading slash!\")\13\n\9\9\9end\13\n\9\9\9cyan.removeSingleFile(cptpack.toroot(file))\13\n\9\9\9tryremoveparents(cptpack.toroot(file))\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction cptpack.install(pname, path)\13\n\9local data = cyan.readserialized(path)\13\n\9assert(pname == data.name .. \"-\" .. data.version)\13\n\9print(\"Installing\", pname)\13\n\9for name, data in pairs(data.contents) do\13\n\9\9if name:sub(1, 1) ~= \"/\" then\13\n\9\9\9error(\"Invalid path - no leading slash!\")\13\n\9\9end\13\n\9\9print(\"Adding\", cptpack.toroot(name))\13\n\9\9if filesystem.exists(cptpack.toroot(name)) then\13\n\9\9\9error(\"File already exists!\")\13\n\9\9end\13\n\9\9cyan.makeParentDirectory(cptpack.toroot(name))\13\n\9\9cyan.writeall(cptpack.toroot(name), data)\13\n\9end\13\nend\13\n\13\nfunction cptpack.makepkg(dir, verifier) -- Ignores root\13\n\9dir = filesystem.concat(shell.getWorkingDirectory(), dir)\13\n\9local loaded, err = loadfile(filesystem.concat(dir, \"PACKBUILD\"))\13\n\9if not loaded then\13\n\9\9error(\"Cannot load PACKBUILD: \" .. err)\13\n\9end\13\n\9local config = loaded(dir, fileout)\13\n\9if verifier and verifier(config) then -- Skip build.\13\n\9\9return nil\13\n\9end\13\n\9local pack = config.package or {}\13\n\9if not pack.contents then pack.contents = {} end\13\n\9for target, source in pairs(config.include or {}) do\13\n\9\9if source:sub(1, 1) == \"/\" then\13\n\9\9\9pack.contents[target] = cyan.readall(source)\13\n\9\9else\13\n\9\9\9pack.contents[target] = cyan.readall(filesystem.concat(dir, source))\13\n\9\9end\13\n\9end\13\n\9for _, field in ipairs({\"name\", \"version\", \"depends\", \"conflicts\"}) do\13\n\9\9if config[field] then\13\n\9\9\9assert(pack[field] == nil)\13\n\9\9\9pack[field] = config[field]\13\n\9\9end\13\n\9\9assert(pack[field], \"No package \" .. field .. \"!\")\13\n\9end\13\n\9return pack\13\nend\13\n\13\nfunction cptpack.buildpkg(dir, fileout) -- Ignores root\13\n\9cyan.writeserialized(fileout, cptpack.makepkg(dir))\13\nend\13\n\13\nfunction cptpack.makeindex()\13\n\9return {}\13\nend\13\n\13\nfunction cptpack.packhash(textual)\13\n\9return crypto.sha256(textual)\13\nend\13\n\13\nfunction cptpack.hasindex(index, name)\13\n\9return index[name] ~= nil\13\nend\13\n\13\nfunction cptpack.removeindex(index, name)\13\n\9index[name] = nil\13\nend\13\n\13\nfunction cptpack.listindex(index)\13\n\9return pairs(index)\13\nend\13\n\13\nfunction cptpack.addindex(index, pkg, hash, source)\13\n\9local ref = pkg.name .. \"-\" .. pkg.version\13\n\9if index[ref] then\13\n\9\9error(\"Ref already found in index: \" .. ref)\13\n\9end\13\n\9assert(hash ~= nil)\13\n\9index[ref] = {source=source, name=pkg.name, version=pkg.version, depends=pkg.depends, conflicts=pkg.conflicts, listing=cyan.keylist(pkg.contents), hash=hash}\13\nend\13\n\13\nfunction cptpack.gethash(index, name)\13\n\9return index[name].hash\13\nend\13\n\13\nfunction cptpack.listingfromindex(index, name)\13\n\9local pkg = index[name]\13\n\9assert(pkg, \"Package not found in index: \" .. name)\13\n\9return pkg.listing\13\nend\13\n\13\nfunction cptpack.dependsfromindex(index, name)\13\n\9return index[name].depends\13\nend\13\n\13\nfunction cptpack.conflictsfromindex(index, name)\13\n\9return index[name].conflicts\13\nend\13\n\13\nfunction cptpack.setsources(index, sourcename)\13\n\9for k, v in pairs(index) do\13\n\9\9v.source = sourcename\13\n\9end\13\nend\13\n\13\nfunction cptpack.getsource(index, name)\13\n\9local pkg = index[name]\13\n\9assert(pkg, \"Package not found in index: \" .. name)\13\n\9return pkg.source\13\nend\13\n\13\nfunction cptpack.mergeindex(target, source)\13\n\9for k, v in pairs(source) do\13\n\9\9if target[k] then\13\n\9\9\9error(\"Cannot merge indexes: duplicate on \" .. k)\13\n\9\9end\13\n\9\9target[k] = v\13\n\9end\13\nend\13\n\13\nfunction cptpack.mergesingleindex(target, source, name)\13\n\9if target[name] then\13\n\9\9error(\"Cannot merge indexes: duplicate on \" .. name)\13\n\9elseif not source[name] then\13\n\9\9error(\"Cannot merge indexes: not found: \" .. name)\13\n\9end\13\n\9target[name] = source[name]\13\nend\13\n\13\nfunction cptpack.writeindex(target, index)\13\n\9cyan.writeserialized(target, index)\13\nend\13\n\13\nfunction cptpack.readindex(source)\13\n\9return cyan.readserialized(source)\13\nend\13\n\13\nfunction cptpack.readremoteindex(url)\13\n\9return cyan.readremoteserialized(url)\13\nend\13\n\13\nfunction cptpack.countindex(index)\13\n\9local count = 0\13\n\9for k, v in pairs(index) do\13\n\9\9count = count + 1\13\n\9end\13\n\9return count\13\nend\13\n\13\nfunction cptpack.dumpindex(index)\13\n\9print(table.unpack(cyan.keylist(index)))\13\nend\13\n\13\nreturn cptpack")
handle("crypto.lua", "local sha2 = require(\"sha2\")\13\nlocal crypto = {}\13\n\13\ncrypto.sha256 = sha2.hash256\13\ncrypto.sha224 = sha2.hash224\13\ncrypto.sha256obj = sha2.new256\13\n\13\nreturn crypto")
handle("sha2.lua", "-- Taken from http://lua-users.org/wiki/SecureHashAlgorithm\13\n\13\n-- SHA-256 code in Lua 5.2; based on the pseudo-code from\13\n-- Wikipedia (http://en.wikipedia.org/wiki/SHA-2)\13\n\13\n\13\nlocal band, rrotate, bxor, rshift, bnot =\13\n  bit32.band, bit32.rrotate, bit32.bxor, bit32.rshift, bit32.bnot\13\n\13\nlocal string, setmetatable, assert = string, setmetatable, assert\13\n\13\n_ENV = nil\13\n\13\n-- Initialize table of round constants\13\n-- (first 32 bits of the fractional parts of the cube roots of the first\13\n-- 64 primes 2..311):\13\nlocal k = {\13\n   0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\13\n   0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\13\n   0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\13\n   0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\13\n   0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\13\n   0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\13\n   0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\13\n   0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\13\n   0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\13\n   0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\13\n   0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\13\n   0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\13\n   0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\13\n   0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\13\n   0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\13\n   0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,\13\n}\13\n\13\n\13\n-- transform a string of bytes in a string of hexadecimal digits\13\nlocal function str2hexa (s)\13\n  local h = string.gsub(s, \".\", function(c)\13\n              return string.format(\"%02x\", string.byte(c))\13\n            end)\13\n  return h\13\nend\13\n\13\n\13\n-- transform number 'l' in a big-endian sequence of 'n' bytes\13\n-- (coded as a string)\13\nlocal function num2s (l, n)\13\n  local s = \"\"\13\n  for i = 1, n do\13\n    local rem = l % 256\13\n    s = string.char(rem) .. s\13\n    l = (l - rem) / 256\13\n  end\13\n  return s\13\nend\13\n\13\n-- transform the big-endian sequence of four bytes starting at\13\n-- index 'i' in 's' into a number\13\nlocal function s232num (s, i)\13\n  local n = 0\13\n  for i = i, i + 3 do\13\n    n = n*256 + string.byte(s, i)\13\n  end\13\n  return n\13\nend\13\n\13\n\13\n-- append the bit '1' to the message\13\n-- append k bits '0', where k is the minimum number >= 0 such that the\13\n-- resulting message length (in bits) is congruent to 448 (mod 512)\13\n-- append length of message (before pre-processing), in bits, as 64-bit\13\n-- big-endian integer\13\nlocal function preproc (msg, len)\13\n  local extra = 64 - ((len + 1 + 8) % 64)\13\n  len = num2s(8 * len, 8)    -- original len in bits, coded\13\n  msg = msg .. \"\\128\" .. string.rep(\"\\0\", extra) .. len\13\n  assert(#msg % 64 == 0)\13\n  return msg\13\nend\13\n\13\n\13\nlocal function initH224 (H)\13\n  -- (second 32 bits of the fractional parts of the square roots of the\13\n  -- 9th through 16th primes 23..53)\13\n  H[1] = 0xc1059ed8\13\n  H[2] = 0x367cd507\13\n  H[3] = 0x3070dd17\13\n  H[4] = 0xf70e5939\13\n  H[5] = 0xffc00b31\13\n  H[6] = 0x68581511\13\n  H[7] = 0x64f98fa7\13\n  H[8] = 0xbefa4fa4\13\n  return H\13\nend\13\n\13\n\13\nlocal function initH256 (H)\13\n  -- (first 32 bits of the fractional parts of the square roots of the\13\n  -- first 8 primes 2..19):\13\n  H[1] = 0x6a09e667\13\n  H[2] = 0xbb67ae85\13\n  H[3] = 0x3c6ef372\13\n  H[4] = 0xa54ff53a\13\n  H[5] = 0x510e527f\13\n  H[6] = 0x9b05688c\13\n  H[7] = 0x1f83d9ab\13\n  H[8] = 0x5be0cd19\13\n  return H\13\nend\13\n\13\n\13\nlocal function digestblock (msg, i, H)\13\n\13\n    -- break chunk into sixteen 32-bit big-endian words w[1..16]\13\n    local w = {}\13\n    for j = 1, 16 do\13\n      w[j] = s232num(msg, i + (j - 1)*4)\13\n    end\13\n\13\n    -- Extend the sixteen 32-bit words into sixty-four 32-bit words:\13\n    for j = 17, 64 do\13\n      local v = w[j - 15]\13\n      local s0 = bxor(rrotate(v, 7), rrotate(v, 18), rshift(v, 3))\13\n      v = w[j - 2]\13\n      local s1 = bxor(rrotate(v, 17), rrotate(v, 19), rshift(v, 10))\13\n      w[j] = w[j - 16] + s0 + w[j - 7] + s1\13\n    end\13\n\13\n    -- Initialize hash value for this chunk:\13\n    local a, b, c, d, e, f, g, h =\13\n        H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]\13\n\13\n    -- Main loop:\13\n    for i = 1, 64 do\13\n      local s0 = bxor(rrotate(a, 2), rrotate(a, 13), rrotate(a, 22))\13\n      local maj = bxor(band(a, b), band(a, c), band(b, c))\13\n      local t2 = s0 + maj\13\n      local s1 = bxor(rrotate(e, 6), rrotate(e, 11), rrotate(e, 25))\13\n      local ch = bxor (band(e, f), band(bnot(e), g))\13\n      local t1 = h + s1 + ch + k[i] + w[i]\13\n\13\n      h = g\13\n      g = f\13\n      f = e\13\n      e = d + t1\13\n      d = c\13\n      c = b\13\n      b = a\13\n      a = t1 + t2\13\n    end\13\n\13\n    -- Add (mod 2^32) this chunk's hash to result so far:\13\n    H[1] = band(H[1] + a)\13\n    H[2] = band(H[2] + b)\13\n    H[3] = band(H[3] + c)\13\n    H[4] = band(H[4] + d)\13\n    H[5] = band(H[5] + e)\13\n    H[6] = band(H[6] + f)\13\n    H[7] = band(H[7] + g)\13\n    H[8] = band(H[8] + h)\13\n\13\nend\13\n\13\n\13\nlocal function finalresult224 (H)\13\n  -- Produce the final hash value (big-endian):\13\n  return\13\n    str2hexa(num2s(H[1], 4)..num2s(H[2], 4)..num2s(H[3], 4)..num2s(H[4], 4)..\13\n             num2s(H[5], 4)..num2s(H[6], 4)..num2s(H[7], 4))\13\nend\13\n\13\n\13\nlocal function finalresult256 (H)\13\n  -- Produce the final hash value (big-endian):\13\n  return\13\n    str2hexa(num2s(H[1], 4)..num2s(H[2], 4)..num2s(H[3], 4)..num2s(H[4], 4)..\13\n             num2s(H[5], 4)..num2s(H[6], 4)..num2s(H[7], 4)..num2s(H[8], 4))\13\nend\13\n\13\n\13\n----------------------------------------------------------------------\13\nlocal HH = {}    -- to reuse\13\n\13\nlocal function hash224 (msg)\13\n  msg = preproc(msg, #msg)\13\n  local H = initH224(HH)\13\n\13\n  -- Process the message in successive 512-bit (64 bytes) chunks:\13\n  for i = 1, #msg, 64 do\13\n    digestblock(msg, i, H)\13\n  end\13\n\13\n  return finalresult224(H)\13\nend\13\n\13\n\13\nlocal function hash256 (msg)\13\n  msg = preproc(msg, #msg)\13\n  local H = initH256(HH)\13\n\13\n  -- Process the message in successive 512-bit (64 bytes) chunks:\13\n  for i = 1, #msg, 64 do\13\n    digestblock(msg, i, H)\13\n  end\13\n\13\n  return finalresult256(H)\13\nend\13\n----------------------------------------------------------------------\13\nlocal mt = {}\13\n\13\nlocal function new256 ()\13\n  local o = {H = initH256({}), msg = \"\", len = 0}\13\n  setmetatable(o, mt)\13\n  return o\13\nend\13\n\13\nmt.__index = mt\13\n\13\nfunction mt:add (m)\13\n  self.msg = self.msg .. m\13\n  self.len = self.len + #m\13\n  local t = 0\13\n  while #self.msg - t >= 64 do\13\n    digestblock(self.msg, t + 1, self.H)\13\n    t = t + 64 \13\n  end\13\n  self.msg = self.msg:sub(t + 1, -1)\13\nend\13\n\13\n\13\nfunction mt:close ()\13\n  self.msg = preproc(self.msg, self.len)\13\n  self:add(\"\")\13\n  return finalresult256(self.H)\13\nend\13\n----------------------------------------------------------------------\13\n\13\nreturn {\13\n  hash224 = hash224,\13\n  hash256 = hash256,\13\n  new256 = new256,\13\n}")
handle("cyan.lua", "local cyan = {}\13\n\13\nlocal serialization = require(\"serialization\")\13\nlocal filesystem = require(\"filesystem\")\13\nlocal internet = require(\"internet\")\13\n\13\n-- Internet utilities\13\n\13\nfunction cyan.readremote(source)\13\n\9local text = \"\"\13\n\9for line in internet.request(source) do\13\n\9\9--[[if #line == 0 then\13\n\9\9\9-- do nothing\13\n\9\9elseif #line >= 2 and line:sub(#line-1) == \"\\r\\n\" then\13\n\9\9\9text = text .. line:sub(1, #line - 2) .. \"\\n\"\13\n\9\9elseif line:sub(#line) == \"\\n\" then\13\n\9\9\9]]text = text .. line--[[\13\n\9\9else\13\n\9\9\9text = text .. line .. \"\\n\"\13\n\9\9end]]\13\n\9end\13\n\9return text\13\nend\13\n\13\nfunction cyan.readremoteserialized(source)\13\n\9return serialization.unserialize(cyan.readremote(source))\13\nend\13\n\13\n-- IO utilities\13\n\13\nfunction cyan.readall(source)\13\n\9local f, err = io.open(source)\13\n\9if not f then\13\n\9\9error(\"Cannot read \" .. source .. \": \" .. err)\13\n\9end\13\n\9local out = f:read(\"*a\")\13\n\9assert(out)\13\n\9f:close()\13\n\9return out\13\nend\13\n\13\nfunction cyan.readserialized(source)\13\n\9return serialization.unserialize(cyan.readall(source))\13\nend\13\n\13\nfunction cyan.writeall(target, data)\13\n\9local f, err = io.open(target, \"w\")\13\n\9if not f then\13\n\9\9error(\"Cannot write \" .. target .. \": \" .. err)\13\n\9end\13\n\9local out, err = f:write(data)\13\n\9if not out then\13\n\9\9error(\"Cannot write \" .. target .. \": \" .. err)\13\n\9end\13\n\9f:close()\13\nend\13\n\13\nfunction cyan.writeserialized(target, data)\13\n\9cyan.writeall(target, serialization.serialize(data))\13\nend\13\n\13\nfunction cyan.isDirectoryEmpty(dir)\13\n\9local listing, err = filesystem.list(dir)\13\n\9if not listing then\13\n\9\9error(\"Cannot list directory\" .. dir .. \": \" .. err)\13\n\9end\13\n\9local empty = true\13\n\9for entry in listing do\13\n\9\9empty = false\13\n\9end\13\n\9return empty\13\nend\13\n\13\nfunction cyan.removeSingleFile(file)\13\n\9if filesystem.isDirectory(file) then\13\n\9\9error(\"Cannot remove file \" .. file .. \": Not supposed to be a directory!\")\13\n\9end\13\n\9if not filesystem.exists(file) then\13\n\9\9error(\"Cannot remove file \" .. file .. \": Does not exist!\")\13\n\9end\13\n\9local out, err = filesystem.remove(file) -- TODO: Check error returning from this.\13\n\9if not out then\13\n\9\9error(\"Cannot remove file \" .. file .. \": \" .. err)\13\n\9end\13\nend\13\n\13\nfunction cyan.makeParentDirectory(file)\13\n\9local parent = filesystem.path(file)\13\n\9if not filesystem.exists(parent) then\13\n\9\9local out, err = filesystem.makeDirectory(parent)\13\n\9\9if not out then\13\n\9\9\9error(\"Cannot make parent directory \" .. parent .. \": \" .. err)\13\n\9\9end\13\n\9elseif not filesystem.isDirectory(parent) then\13\n\9\9error(\"Parent directory is not a directory: \" .. parent)\13\n\9end\13\nend\13\n\13\n-- Table utilities\13\n\13\nfunction cyan.keylist(map)\13\n\9local out = {}\13\n\9for k, _ in pairs(map) do\13\n\9\9table.insert(out, k)\13\n\9end\13\n\9return out\13\nend\13\n\13\nfunction cyan.valueset(list)\13\n\9local out = {}\13\n\9for _, v in ipairs(list) do\13\n\9\9out[v] = true\13\n\9end\13\n\9return out\13\nend\13\n\13\nfunction cyan.instance(class, object)\13\n\9return setmetatable(object or {}, {__index=class})\13\nend\13\n\13\nfunction cyan.writeinstance(target, self)\13\n\9local meta = getmetatable(self)\13\n\9setmetatable(self, {})\13\n\9cyan.writeserialized(target, self)\13\n\9setmetatable(self, meta)\13\nend\13\n\13\n-- String utilities\13\n\13\nfunction cyan.cut(str, pattern, errmsg)\13\n\9at = str:find(pattern)\13\n\9if not at then\13\n\9\9if errmsg then\13\n\9\9\9error(errmsg)\13\n\9\9end\13\n\9\9return str, nil\13\n\9end\13\n\9return str:sub(1, at - 1), str:sub(at + 1)\13\nend\13\n\13\nfunction cyan.ltrim(str)\13\n\9if not str then return end\13\n\9index = str:find(\"[^ \\t\\r\\n]\")\13\n\9if not index then return end\13\n\9return str:sub(index)\13\nend\13\n\13\nfunction cyan.rtrim(str)\13\n\9if not str then return end\13\n\9return str:match(\"^(.*[^ \\t\\r\\n])[ \\t\\r\\n]*$\")\13\nend\13\n\13\nfunction cyan.trim(str)\13\n\9return cyan.rtrim(cyan.ltrim(str))\13\nend\13\n\13\nreturn cyan\13\n")
require("cptcache").configpath = filesystem.concat(dirout, "cpt.list")
local success, reason = os.execute("cpt reroot " .. dirout .. " strap")
assert((filesystem.remove(filesystem.concat(dirout, "cpt.list"))), "Could not remove: cpt.list")assert((filesystem.remove(filesystem.concat(dirout, "cpt.lua"))), "Could not remove: cpt.lua")assert((filesystem.remove(filesystem.concat(dirout, "cptcache.lua"))), "Could not remove: cptcache.lua")assert((filesystem.remove(filesystem.concat(dirout, "cptinstall.lua"))), "Could not remove: cptinstall.lua")assert((filesystem.remove(filesystem.concat(dirout, "cptlock.lua"))), "Could not remove: cptlock.lua")assert((filesystem.remove(filesystem.concat(dirout, "cptpack.lua"))), "Could not remove: cptpack.lua")assert((filesystem.remove(filesystem.concat(dirout, "crypto.lua"))), "Could not remove: crypto.lua")assert((filesystem.remove(filesystem.concat(dirout, "sha2.lua"))), "Could not remove: sha2.lua")assert((filesystem.remove(filesystem.concat(dirout, "cyan.lua"))), "Could not remove: cyan.lua")assert(success, "Installation failed: " .. tostring(reason) .. "\nMake sure to remove /var/cache/cpt and /var/lib/cpt in the target directory before trying again.")
